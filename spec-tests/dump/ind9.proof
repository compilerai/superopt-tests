=FunctionName: make_list
=result: 1
=cg_with_asm_annotation
=cg_with_backtracker
=cg_with_rank
=corr_graph make_list.A2.B1.C1.D1.E2
=src_tfg
=TFG_SSA:
=TFG_SPEC src.spec.make_list:
=TFG:
=Nodes: L0%0%d L3%6%bbentry L3%7%d L3%8%bbentry L3%10%bbentry E0%0%d
=Edges:
L0%0%d => L3%6%bbentry
L3%6%bbentry => L3%7%d
L3%7%d => L3%10%bbentry
L3%7%d => L3%8%bbentry
L3%8%bbentry => E0%0%d
L3%10%bbentry => L3%6%bbentry (backedge) 
=graph done
=is_ssa_graph:
1
=StartState:
=spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=state_end
=PC to var-version map at L0%0%d
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=PC to var-version map at L3%6%bbentry
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=PC to var-version map at L3%7%d
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=PC to var-version map at L3%8%bbentry
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=PC to var-version map at L3%10%bbentry
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=PC to var-version map at E0%0%d
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=graph_with_var_versions done
=FunctionName: make_list
=Input: tfg-method-arg.0
=arg addr
1 : (undefined) : UNDEFINED
=arg val
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=arg end
=Node outputs: E0%0%d
=Output: spec-%ret-reg
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Node outputs done for E0%0%d
=input_outputs done
=Symbol-map:
=Touched symbols:
=Symbol-map done
=Locals-map:
=Locals-map done
=Global assumes
=global assume predicate_set done
Memlabel map for call-context {*;make_list}
=memlabel_map.0 for call-context {*;make_list}
mlheap.src.spec.make_list : memlabel-mem--heap
=Edge: L0%0%d => L3%6%bbentry
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=spec-%tmpvar-10.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : unit : UNIT
4 : sum_init(1, 2, 3) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=spec-%var-arr-0.L3%6%bbentry
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=spec-%var-l-0.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : unit : UNIT
4 : sum_init(1, 2, 3) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:2:((((func_head*ctor_bv)*ctor_sum)*(inline_entry*func_head))*(ghost_var.itervar.firstedge*ghost_var.itervar.secondedge))
tfg_edge_comment end

=Edge: L3%6%bbentry => L3%7%d
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=spec-%tmpvar-0.L3%7%d
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : map_get(1, 2) : SUM[UNIT,BV:32]
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:-1:(bb_entry*intrinsic_app_map_get)
tfg_edge_comment end

=Edge: L3%7%d => L3%10%bbentry
=Edge.EdgeCond: 
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : sum_is(1, 2) : BOOL
=Edge.StateTo: 
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:6:match_sum_cond_1
tfg_edge_comment end

=Edge: L3%7%d => L3%8%bbentry
=Edge.EdgeCond: 
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : sum_is(1, 2) : BOOL
=Edge.StateTo: 
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:4:match_sum_cond_0
tfg_edge_comment end

=Edge: L3%8%bbentry => E0%0%d
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=spec-%tmpvar-11.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-7.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%var-u-0.E0%0%d
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : sum_get(1, 2) : UNIT
=spec-%tmpvar-12.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-8.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:-1:((((bb_entry*match_sum_val_0)*match_sum_merge_0)*func_ret)*(inline_exit*func_ret))
tfg_edge_comment end

=Edge: L3%10%bbentry => L3%6%bbentry
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : input.src.spec-ghostvar.itervar.1.L3%6%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=spec-%var-arr-0.L3%6%bbentry
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=spec-%var-i-0.L3%6%bbentry
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=spec-%var-l-0.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-1.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
2 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : sum_get(2, 3) : BV:32
5 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : prod_init(1, 4, 5) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=spec-%var-arr_i-0.L3%6%bbentry
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : sum_get(1, 2) : BV:32
=spec-%tmpvar-2.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=spec-%tmpvar-4.L3%6%bbentry
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=spec-%var-new_l-0.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:-1:(((bb_entry*match_sum_val_1)*ctor_prod)*((((ctor_sum*letin_def)*ctor_bv)*(intrinsic_app_bvadd*tailrec_backedge))*(ghost_var.itervar.firstedge*ghost_var.itervar.secondedge)))
tfg_edge_comment end

=graph_with_predicates_done

=start_pc_preconditions
=graph_with_precondition_done

=Locs in src.spec.make_list
=Loc 1 in src.spec.make_list.
REGMEM
spec-%var-arr-1
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=Loc 20 in src.spec.make_list.
MASKED
=mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--heap
=Loc 21 in src.spec.make_list.
MASKED
=mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.0
=Loc 22 in src.spec.make_list.
REGMEM
spec-%tmpvar-0.L3%7%d
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
=Loc 23 in src.spec.make_list.
REGMEM
spec-%var-arr-0.L3%6%bbentry
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=Loc 24 in src.spec.make_list.
REGMEM
spec-%var-i-0.L3%6%bbentry
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=Loc 25 in src.spec.make_list.
REGMEM
spec-%tmpvar-11.E0%0%d
1 : input.spec-%tmpvar-11.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 26 in src.spec.make_list.
REGMEM
spec-%tmpvar-12.E0%0%d
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 27 in src.spec.make_list.
REGMEM
spec-%tmpvar-7.E0%0%d
1 : input.spec-%tmpvar-7.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 28 in src.spec.make_list.
REGMEM
spec-%tmpvar-8.E0%0%d
1 : input.spec-%tmpvar-8.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 29 in src.spec.make_list.
REGMEM
spec-%var-l-0.L3%6%bbentry
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 30 in src.spec.make_list.
REGMEM
spec-%var-u-0.E0%0%d
1 : input.spec-%var-u-0.E0%0%d : UNIT
=Loc 31 in src.spec.make_list.
REGMEM
spec-%tmpvar-10.L3%6%bbentry
1 : input.spec-%tmpvar-10.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 32 in src.spec.make_list.
REGMEM
spec-%tmpvar-9.L3%6%bbentry
1 : input.spec-%tmpvar-9.L3%6%bbentry : BV:32
=Loc 33 in src.spec.make_list.
REGMEM
src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : input.src.spec-ghostvar.itervar.1.L3%6%bbentry : BV:32
=Loc 34 in src.spec.make_list.
REGMEM
spec-%tmpvar-1.L3%6%bbentry
1 : input.spec-%tmpvar-1.L3%6%bbentry : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=Loc 35 in src.spec.make_list.
REGMEM
spec-%tmpvar-2.L3%6%bbentry
1 : input.spec-%tmpvar-2.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 36 in src.spec.make_list.
REGMEM
spec-%tmpvar-3.L3%6%bbentry
1 : input.spec-%tmpvar-3.L3%6%bbentry : BV:32
=Loc 37 in src.spec.make_list.
REGMEM
spec-%tmpvar-4.L3%6%bbentry
1 : input.spec-%tmpvar-4.L3%6%bbentry : BV:32
=Loc 38 in src.spec.make_list.
REGMEM
spec-%var-arr_i-0.L3%6%bbentry
1 : input.spec-%var-arr_i-0.L3%6%bbentry : BV:32
=Loc 39 in src.spec.make_list.
REGMEM
spec-%var-new_l-0.L3%6%bbentry
1 : input.spec-%var-new_l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Locs end
=Liveness in src.spec.make_list
=live locs at L0%0%d
1, 
=live locs at L3%6%bbentry
23, 24, 29, 
=live locs at L3%7%d
22, 23, 24, 29, 
=live locs at L3%8%bbentry
29, 
=live locs at L3%10%bbentry
22, 23, 24, 29, 
=live locs at E0%0%d
26, 

=Definedness in src.spec.make_list
=loc definedness at L0%0%d
1, 20, 21
=loc definedness at L3%6%bbentry
1, 20, 21, 23, 24, 29, 31, 32, 33
=loc definedness at L3%7%d
1, 20, 21, 22, 23, 24, 29, 31, 32, 33
=loc definedness at L3%8%bbentry
1, 20, 21, 22, 23, 24, 29, 31, 32, 33
=loc definedness at L3%10%bbentry
1, 20, 21, 22, 23, 24, 29, 31, 32, 33
=loc definedness at E0%0%d
1, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33

=Branch affecting variable locs in src.spec.make_list
=branch affecting variable locs at L0%0%d
1
=branch affecting variable locs at L3%6%bbentry
23, 24
=branch affecting variable locs at L3%7%d
22, 23, 24
=branch affecting variable locs at L3%8%bbentry

=branch affecting variable locs at L3%10%bbentry
23, 24
=branch affecting variable locs at E0%0%d


=Relevant Memlabels in src.spec.make_list
=relevant memlabels
=function: make_list
memlabel-mem--heap
memlabel-mem--arg.0
=touched symbol ids

=relevant memlabels done
=graph_with_locs_done
=graph_with_edge_structures
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 23 {input.spec-%var-arr-0.L3%6%bbentry }
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 24 {input.spec-%var-i-0.L3%6%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 29 {input.spec-%var-l-0.L3%6%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 31 {input.spec-%tmpvar-10.L3%6%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 32 {input.spec-%tmpvar-9.L3%6%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 33 {input.src.spec-ghostvar.itervar.1.L3%6%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry done
=graph_with_edge_structures.loc_to_expr_map at L3%6%bbentry=>L3%7%d
=graph_with_edge_structures.loc_to_expr_map at L3%6%bbentry=>L3%7%d for loc_id 22 {input.spec-%tmpvar-0.L3%7%d }
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : map_get(1, 2) : SUM[UNIT,BV:32]
=graph_with_edge_structures.loc_to_expr_map at L3%6%bbentry=>L3%7%d done
=graph_with_edge_structures.loc_to_expr_map at L3%7%d=>L3%8%bbentry
=graph_with_edge_structures.loc_to_expr_map at L3%7%d=>L3%8%bbentry done
=graph_with_edge_structures.loc_to_expr_map at L3%7%d=>L3%10%bbentry
=graph_with_edge_structures.loc_to_expr_map at L3%7%d=>L3%10%bbentry done
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d for loc_id 25 {input.spec-%tmpvar-11.E0%0%d }
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d for loc_id 26 {input.spec-%tmpvar-12.E0%0%d }
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d for loc_id 27 {input.spec-%tmpvar-7.E0%0%d }
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d for loc_id 28 {input.spec-%tmpvar-8.E0%0%d }
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d for loc_id 30 {input.spec-%var-u-0.E0%0%d }
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : sum_get(1, 2) : UNIT
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d done
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 24 {input.spec-%var-i-0.L3%6%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 29 {input.spec-%var-l-0.L3%6%bbentry }
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 33 {input.src.spec-ghostvar.itervar.1.L3%6%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.src.spec-ghostvar.itervar.1.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 34 {input.spec-%tmpvar-1.L3%6%bbentry }
1 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
2 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : sum_get(2, 3) : BV:32
5 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : prod_init(1, 4, 5) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 35 {input.spec-%tmpvar-2.L3%6%bbentry }
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 36 {input.spec-%tmpvar-3.L3%6%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 37 {input.spec-%tmpvar-4.L3%6%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 38 {input.spec-%var-arr_i-0.L3%6%bbentry }
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : sum_get(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 39 {input.spec-%var-new_l-0.L3%6%bbentry }
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry done
=graph_with_edge_structures.loc_to_expr_map done
=graph_with_edge_structures done
=graph_with_ml_contiguity_info vacuous mls
vacuous mls at L0%0%d:
vacuous mls at L3%6%bbentry:
vacuous mls at L3%7%d:
vacuous mls at L3%8%bbentry:
vacuous mls at L3%10%bbentry:
vacuous mls at E0%0%d:
=graph_with_ml_contiguity_info non-vacuous mls
non-vacuous mls at L0%0%d:
non-vacuous mls at L3%6%bbentry:
non-vacuous mls at L3%7%d:
non-vacuous mls at L3%8%bbentry:
non-vacuous mls at L3%10%bbentry:
non-vacuous mls at E0%0%d:
=graph_with_ml_contiguity_info discontiguous mls
discontiguous mls:
=graph_with_ml_contiguity_info done
=Available expressions in src.spec.make_list
=avail_exprs begin
=loc 1
=loc_expr
140273 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 23
=loc_expr
140368 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=avail_exprs_val.end
=loc 31
=loc_expr
140400 : input.spec-%tmpvar-10.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=avail_exprs_val.end
=loc 32
=loc_expr
140401 : input.spec-%tmpvar-9.L3%6%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 36
=loc_expr
140404 : input.spec-%tmpvar-3.L3%6%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 1 { 0x1 +1.11e129 } : BV:32
=avail_exprs_val.end
=avail_exprs end
=sprel_map in src.spec.make_list
=loc 31 expr
1 : input.spec-%tmpvar-10.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=loc 31 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140279 : unit : UNIT
140408 : Indxform7 : BV:32
140411 : Lambda14 : BV:32
140412 : lambda(140411, 140411) : FUNCTION[BV:32 -> BV:32]
140413 : Lambda15 : BV:32
140409 : sum(140276, 140279, 140408) : SUM[UNIT,BV:32]
140410 : prod(140276, 140409) : PROD[BV:32,SUM[UNIT,BV:32]]
140414 : lambda(140413, 140410) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
140417 : ind(140276, 140408, 140412, 140414) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
140418 : sum(140276, 140279, 140417) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
140419 : sym_const(140418) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=loc 32 expr
1 : input.spec-%tmpvar-9.L3%6%bbentry : BV:32
=loc 32 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 36 expr
1 : input.spec-%tmpvar-3.L3%6%bbentry : BV:32
=loc 36 spreled-expr
140298 : 1 { 0x1 +1.11e129 } : BV:32
=sprel_map done
=lr-status-map
=lr-status-map at call-context {*;make_list}
=loc_id 1 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 20 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, )
=loc_id 21 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, )
=loc_id 22 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 23 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 24 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 25 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 26 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 27 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 28 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 29 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 30 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 31 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 32 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 33 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 34 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 35 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 36 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 37 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 38 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 39 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=lr-status-map done
=lr-status-for-sprel-locs-map
=loc_id 31 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 32 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 36 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=lr-status-for-sprel-locs-map done
=graph_with_aliasing_done
=Memlabel assertions empty
=Memlabel assertions done
=graph_with_proofs done
=graph_with_ce done
=graph_with_points done
=graph_with_guessing done
=graph_with_simplified_assets
=graph_with_simplified_assets.simplified_edgecond at L0%0%d=>L3%6%bbentry
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at L3%6%bbentry=>L3%7%d
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at L3%7%d=>L3%8%bbentry
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : sum_is(1, 2) : BOOL
=graph_with_simplified_assets.simplified_edgecond at L3%7%d=>L3%10%bbentry
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : sum_is(1, 2) : BOOL
=graph_with_simplified_assets.simplified_edgecond at L3%8%bbentry=>E0%0%d
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at L3%10%bbentry=>L3%6%bbentry
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond done
=graph_with_simplified_assets.simplified_to_state at L0%0%d=>L3%6%bbentry
=spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=spec-%var-arr-0.L3%6%bbentry
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=state_end
=graph_with_simplified_assets.simplified_to_state at L3%6%bbentry=>L3%7%d
=spec-%tmpvar-0.L3%7%d
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : map_get(1, 2) : SUM[UNIT,BV:32]
=state_end
=graph_with_simplified_assets.simplified_to_state at L3%7%d=>L3%8%bbentry
=state_end
=graph_with_simplified_assets.simplified_to_state at L3%7%d=>L3%10%bbentry
=state_end
=graph_with_simplified_assets.simplified_to_state at L3%8%bbentry=>E0%0%d
=spec-%tmpvar-11.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-7.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%var-u-0.E0%0%d
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : sum_get(1, 2) : UNIT
=spec-%tmpvar-12.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-8.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=state_end
=graph_with_simplified_assets.simplified_to_state at L3%10%bbentry=>L3%6%bbentry
=src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.src.spec-ghostvar.itervar.1.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=spec-%var-l-0.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-1.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
2 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : sum_get(2, 3) : BV:32
5 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : prod_init(1, 4, 5) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=spec-%var-arr_i-0.L3%6%bbentry
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : sum_get(1, 2) : BV:32
=spec-%tmpvar-2.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=spec-%tmpvar-4.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=spec-%var-new_l-0.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=state_end
=graph_with_simplified_assets.simplified_to_state done
=graph_with_simplified_assets.simplified_assumes at L0%0%d=>L3%6%bbentry
=graph_with_simplified_assets.simplified_assumes at L0%0%d=>L3%6%bbentry done
=graph_with_simplified_assets.simplified_assumes at L3%6%bbentry=>L3%7%d
=graph_with_simplified_assets.simplified_assumes at L3%6%bbentry=>L3%7%d done
=graph_with_simplified_assets.simplified_assumes at L3%7%d=>L3%8%bbentry
=graph_with_simplified_assets.simplified_assumes at L3%7%d=>L3%8%bbentry done
=graph_with_simplified_assets.simplified_assumes at L3%7%d=>L3%10%bbentry
=graph_with_simplified_assets.simplified_assumes at L3%7%d=>L3%10%bbentry done
=graph_with_simplified_assets.simplified_assumes at L3%8%bbentry=>E0%0%d
=graph_with_simplified_assets.simplified_assumes at L3%8%bbentry=>E0%0%d done
=graph_with_simplified_assets.simplified_assumes at L3%10%bbentry=>L3%6%bbentry
=graph_with_simplified_assets.simplified_assumes at L3%10%bbentry=>L3%6%bbentry done
=graph_with_simplified_assets.simplified_assumes done
=graph_with_simplified_assets done
=max-memlabel-varnum
0
=String-contents:
=Nextpc-map:
=Nextpc-map done
=suffixpaths for src.spec.make_list
=suffixpath_at_L0%0%d for src.spec.make_list
=suffixpath_at_L0%0%d.graph_edge_composition
(epsilon)
=suffixpath_at_L3%6%bbentry for src.spec.make_list
=suffixpath_at_L3%6%bbentry.graph_edge_composition
(L0%0%d=>L3%6%bbentry)
=suffixpath_at_L3%7%d for src.spec.make_list
=suffixpath_at_L3%7%d.graph_edge_composition
((L0%0%d=>L3%6%bbentry)*(L3%6%bbentry=>L3%7%d))
=suffixpath_at_L3%8%bbentry for src.spec.make_list
=suffixpath_at_L3%8%bbentry.graph_edge_composition
((L0%0%d=>L3%6%bbentry)*((L3%6%bbentry=>L3%7%d)*(L3%7%d=>L3%8%bbentry)))
=suffixpath_at_L3%10%bbentry for src.spec.make_list
=suffixpath_at_L3%10%bbentry.graph_edge_composition
((L0%0%d=>L3%6%bbentry)*((L3%6%bbentry=>L3%7%d)*(L3%7%d=>L3%10%bbentry)))
=suffixpath_at_E0%0%d for src.spec.make_list
=suffixpath_at_E0%0%d.graph_edge_composition
((L0%0%d=>L3%6%bbentry)*((L3%6%bbentry=>L3%7%d)*((L3%7%d=>L3%8%bbentry)*(L3%8%bbentry=>E0%0%d))))
=suffixpaths for src.spec.make_list done
=tfg.assumes_around_edge
tfg.assumes_around_edge at L0%0%d=>L3%6%bbentry
tfg.assumes_around_edge at L0%0%d=>L3%6%bbentry done
tfg.assumes_around_edge at L3%6%bbentry=>L3%7%d
tfg.assumes_around_edge at L3%6%bbentry=>L3%7%d done
tfg.assumes_around_edge at L3%7%d=>L3%8%bbentry
tfg.assumes_around_edge at L3%7%d=>L3%8%bbentry done
tfg.assumes_around_edge at L3%7%d=>L3%10%bbentry
tfg.assumes_around_edge at L3%7%d=>L3%10%bbentry done
tfg.assumes_around_edge at L3%8%bbentry=>E0%0%d
tfg.assumes_around_edge at L3%8%bbentry=>E0%0%d done
tfg.assumes_around_edge at L3%10%bbentry=>L3%6%bbentry
tfg.assumes_around_edge at L3%10%bbentry=>L3%6%bbentry done
tfg.assumes_around_edge done
=TFGdone
=TFG_SPEC_done
=TFG_SSA_done
=dst_tfg
=TFG_SSA:
=TFG_LLVM dst.llvm.make_list:
=TFG:
=Nodes: L0%0%d Lfor.body%1%intermediateVal1 Lfor.body%1%fcallStart Lfor.body%1%fcallEnd Lfor.body%2%d Lfor.cond%1%bbentry Lfor.cond%2%d Lfor.end%1%d E0%0%d
=Edges:
L0%0%d => Lfor.cond%1%bbentry
Lfor.cond%1%bbentry => Lfor.cond%2%d
Lfor.cond%2%d => Lfor.body%1%fcallStart
Lfor.cond%2%d => Lfor.end%1%d
Lfor.end%1%d => E0%0%d
Lfor.body%1%fcallStart => Lfor.body%1%fcallEnd
Lfor.body%1%fcallEnd => Lfor.body%1%intermediateVal1
Lfor.body%1%intermediateVal1 => Lfor.body%2%d
Lfor.body%2%d => Lfor.cond%1%bbentry (backedge) 
=graph done
=is_ssa_graph:
1
=StartState:
=dst.llvm-%n
1 : input.dst.llvm-%n : BV:32
=dst.llvm-%arr
1 : input.dst.llvm-%arr : BV:32
=dst.llvm-mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=state_end
=PC to var-version map at L0%0%d
=version for dst.llvm-mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.body%1%intermediateVal1
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.body%1%fcallStart
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.body%1%fcallEnd
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.body%2%d
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.cond%1%bbentry
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.cond%2%d
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.end%1%d
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at E0%0%d
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=graph_with_var_versions done
=FunctionName: make_list
=Input: tfg-method-arg.0
=arg addr
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
=arg val
1 : input.dst.llvm-%arr : BV:32
=arg end
=Input: tfg-method-arg.1
=arg addr
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
=arg val
1 : input.dst.llvm-%n : BV:32
=arg end
=Node outputs: E0%0%d
=Output: heap
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=Output: llvm-indir_tgt
1 : retaddr_const : BV:32
=Output: llvm-%ret-reg
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=Node outputs done for E0%0%d
=input_outputs done
=Symbol-map:
C_SYMBOL1 : make_list : 26 : 1 : 0
=Touched symbols:
=Symbol-map done
=Locals-map:
C_LOCAL=L0%0%argnum0= : dst.llvm-%arr : 4 : 4 : 0
C_LOCAL=L0%0%argnum1= : dst.llvm-%n : 4 : 4 : 0
=Locals-map done
=Global assumes
=global assume predicate_set done
Memlabel map for call-context {*;make_list}
=memlabel_map.0 for call-context {*;make_list}
mlcall.dst.llvm.make_list.3 : memlabel-mem-
=memlabel_map.1 for call-context {*;make_list}
mlcall.dst.llvm.make_list.4 : memlabel-mem-
=memlabel_map.2 for call-context {*;make_list}
mlheap.dst.llvm.make_list : memlabel-mem-may-straddle-symbol.1-heap
=memlabel_map.3 for call-context {*;make_list}
mlvar.dst.llvm.make_list.0 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0
=memlabel_map.4 for call-context {*;make_list}
mlvar.dst.llvm.make_list.1 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=memlabel_map.5 for call-context {*;make_list}
mlvar.dst.llvm.make_list.2 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Edge: L0%0%d => Lfor.cond%1%bbentry
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=dst.llvm-%arr.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr : BV:32
=dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%n.Lfor.cond%1%bbentry
1 : input.dst.llvm-%n : BV:32
=dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-mem.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.cond%1%bbentry
1 : input.dst.local_alloc_count.=L0%0%d= : COUNT
=state_end
=Edge.Assumes.begin:
=EdgeAssume.0
1 : input.dst.llvm-%arr : BV:32
2 : 4 { 0x4 +1.0e1025 } : INT
3 : islangaligned(1, 2) : BOOL
=Edge.Assumes.end
=Edge.te_comment
0:-1:((((((start_pc_edge*  br label %for.cond, !dbg !28)*  %l.0 = phi %struct.list* [ null, %entry ], [ %0, %for.inc ], !dbg !22)*(  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ], !dbg !27*  br label %for.cond, !dbg !28))*  br label %for.cond, !dbg !28)*(  br label %for.cond, !dbg !28*  br label %for.cond, !dbg !28))*(ghost_var.itervar.firstedge*ghost_var.itervar.secondedge))
tfg_edge_comment end

=Edge: Lfor.cond%1%bbentry => Lfor.cond%2%d
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.llvm-%cmp.Lfor.cond%2%d
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:-1:(bb_entry*  %cmp = icmp ult i32 %i.0, %n, !dbg !29)
tfg_edge_comment end

=Edge: Lfor.cond%2%d => Lfor.body%1%fcallStart
=Edge.EdgeCond: 
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=Edge.StateTo: 
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:2:((  br i1 %cmp, label %for.body, label %for.end, !dbg !31*  br i1 %cmp, label %for.body, label %for.end, !dbg !31)*(  br i1 %cmp, label %for.body, label %for.end, !dbg !31*fcall_edge_start))
tfg_edge_comment end

=Edge: Lfor.cond%2%d => Lfor.end%1%d
=Edge.EdgeCond: 
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
2 : not(1) : BOOL
=Edge.StateTo: 
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:2:((  br i1 %cmp, label %for.body, label %for.end, !dbg !31*  br i1 %cmp, label %for.body, label %for.end, !dbg !31)*  br i1 %cmp, label %for.body, label %for.end, !dbg !31)
tfg_edge_comment end

=Edge: Lfor.end%1%d => E0%0%d
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.llvm-%hidden-reg.E0%0%d
1 : input.dst.llvm-%hidden-reg : BV:32
2 : input.dst.llvm-callee-save.0 : BV:32
3 : bvxor(1, 2) : BV:32
4 : input.dst.llvm-callee-save.1 : BV:32
5 : bvxor(3, 4) : BV:32
6 : input.dst.llvm-callee-save.2 : BV:32
7 : bvxor(5, 6) : BV:32
8 : input.dst.llvm-callee-save.3 : BV:32
9 : bvxor(7, 8) : BV:32
=dst.llvm-%ret-reg.E0%0%d
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=dst.llvm-indir_tgt.E0%0%d
1 : retaddr_const : BV:32
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:1:  ret %struct.list* %l.0, !dbg !46
tfg_edge_comment end

=Edge: Lfor.body%1%fcallStart => Lfor.body%1%fcallEnd
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.llvm-%call.Lfor.body%1%fcallEnd
1 : func.calla4bcb626de6152719ca44f8b649b9c4a.reg : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
2 : mlcall.dst.llvm.make_list.3 : MEMLABEL
3 : mlcall.dst.llvm.make_list.4 : MEMLABEL
4 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : nextpc_const.1 : BV:32
7 : 1000 { 0x3e8 +1.11920e129 } : REGID
8 : 8 { 0x8 +1.95e129 } : BV:32
9 : function_call(1, 2, 3, 4, 5, 6, 7, 8) : BV:32
=dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=dst.llvm-mem.Lfor.body%1%fcallEnd
1 : func.call30eccc4aa0775a3174483e053ab761b.mem : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> ARRAY[BV:32 -> BV:8]]
2 : mlcall.dst.llvm.make_list.3 : MEMLABEL
3 : mlcall.dst.llvm.make_list.4 : MEMLABEL
4 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : nextpc_const.1 : BV:32
7 : 0 { 0x0 +1.0e129 } : REGID
8 : 8 { 0x8 +1.95e129 } : BV:32
9 : function_call(1, 2, 3, 4, 5, 6, 7, 8) : ARRAY[BV:32 -> BV:8]
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:-1:(fcall_edge_arg*  %call = call i8* @malloc(i32 8), !dbg !32)
tfg_edge_comment end

=Edge: Lfor.body%1%fcallEnd => Lfor.body%1%intermediateVal1
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=state_end
=Edge.Assumes.begin:
=EdgeAssume.0
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : islangaligned(1, 2) : BOOL
=Edge.Assumes.end
=Edge.te_comment
0:-1:(fcall_edge_end*  %call = call i8* @malloc(i32 8), !dbg !32)
tfg_edge_comment end

=Edge: Lfor.body%1%intermediateVal1 => Lfor.body%2%d
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.llvm-%arr.Lfor.body%2%d
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%call.Lfor.body%2%d
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
5 : heap_alloc_ptr(1, 4) : BV:32
6 : ite(3, 2, 5) : BV:32
=dst.llvm-%i.0.Lfor.body%2%d
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%l.0.Lfor.body%2%d
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%n.Lfor.body%2%d
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-mem.Lfor.body%2%d
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 1, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 1, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.body%2%d
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
6 : 8 { 0x8 +1.95e129 } : BV:32
7 : heap_alloc(4, 5, 1, 6) : ARRAY[BV:32 -> MEMLABEL]
8 : ite(3, 4, 7) : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.body%2%d
1 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
2 : increment_count(1) : COUNT
=state_end
=Edge.Assumes.begin:
=EdgeAssume.0
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 8 { 0x8 +1.95e129 } : BV:32
5 : eq(4, 2) : BOOL
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : heap_alloc_ptr(1, 6) : BV:32
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : bvadd(7, 9) : BV:32
11 : bvule(7, 10) : BOOL
12 : or(5, 11) : BOOL
13 : or(3, 12) : BOOL
=EdgeAssume.1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : 8 { 0x8 +1.95e129 } : BV:32
6 : mlheap.dst.llvm.make_list : MEMLABEL
7 : region_agrees_with_memlabel(4, 1, 5, 6) : BOOL
8 : or(3, 7) : BOOL
=Edge.Assumes.end
=Edge.te_comment
0:1:  %call = call i8* @malloc(i32 8), !dbg !32
tfg_edge_comment end

=Edge: Lfor.body%2%d => Lfor.cond%1%bbentry
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.llvm-%arr.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=dst.llvm-%n.Lfor.cond%1%bbentry
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-mem.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : mlvar.dst.llvm.make_list.1 : MEMLABEL
4 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : 8 { 0x8 +1.95e129 } : BV:32
7 : bvmul(5, 6) : BV:32
8 : bvadd(5, 7) : BV:32
9 : bvadd(8, 5) : BV:32
10 : bvadd(4, 9) : BV:32
11 : mlvar.dst.llvm.make_list.0 : MEMLABEL
12 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
13 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
14 : 4 { 0x4 +1.47e129 } : BV:32
15 : bvmul(13, 14) : BV:32
16 : bvadd(5, 15) : BV:32
17 : bvadd(12, 16) : BV:32
18 : 4 { 0x4 +1.0e1025 } : INT
19 : 0 { 0x0 } : BOOL
20 : select(1, 2, 11, 17, 18, 19) : BV:32
21 : store(1, 2, 3, 10, 20, 18, 19) : ARRAY[BV:32 -> BV:8]
22 : mlvar.dst.llvm.make_list.2 : MEMLABEL
23 : bvadd(8, 14) : BV:32
24 : bvadd(4, 23) : BV:32
25 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
26 : store(21, 2, 22, 24, 25, 18, 19) : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.cond%1%bbentry
1 : input.dst.local_alloc_count.Lfor.body%2%d : COUNT
=dst.llvm-%0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%1.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : mlvar.dst.llvm.make_list.0 : MEMLABEL
4 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
7 : 4 { 0x4 +1.47e129 } : BV:32
8 : bvmul(6, 7) : BV:32
9 : bvadd(5, 8) : BV:32
10 : bvadd(4, 9) : BV:32
11 : 4 { 0x4 +1.0e1025 } : INT
12 : 0 { 0x0 } : BOOL
13 : select(1, 2, 3, 10, 11, 12) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(3, 4) : BV:32
6 : bvadd(2, 5) : BV:32
7 : bvadd(1, 6) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : bvmul(1, 2) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvadd(1, 3) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvadd(1, 3) : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvadd(4, 5) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 8 { 0x8 +1.95e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(2, 4) : BV:32
6 : 4 { 0x4 +1.47e129 } : BV:32
7 : bvadd(5, 6) : BV:32
8 : bvadd(1, 7) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(3, 4) : BV:32
6 : bvadd(2, 5) : BV:32
7 : bvadd(1, 6) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvadd(1, 3) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvadd(1, 3) : BV:32
5 : bvadd(4, 1) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 8 { 0x8 +1.95e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(2, 4) : BV:32
6 : bvadd(5, 2) : BV:32
7 : bvadd(1, 6) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%next.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 8 { 0x8 +1.95e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(2, 4) : BV:32
6 : 4 { 0x4 +1.47e129 } : BV:32
7 : bvadd(5, 6) : BV:32
8 : bvadd(1, 7) : BV:32
=dst.llvm-%val.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 8 { 0x8 +1.95e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(2, 4) : BV:32
6 : bvadd(5, 2) : BV:32
7 : bvadd(1, 6) : BV:32
=state_end
=Edge.Assumes.begin:
=EdgeAssume.0
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 8 { 0x8 +1.95e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(2, 4) : BV:32
6 : 4 { 0x4 +1.47e129 } : BV:32
7 : bvadd(5, 6) : BV:32
8 : bvadd(1, 7) : BV:32
9 : 4 { 0x4 +1.0e1025 } : INT
10 : islangaligned(8, 9) : BOOL
=EdgeAssume.1
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvslt(1, 2) : BOOL
4 : 32 { 0x20 +1.0e1025 } : INT
5 : bvsign_ext(1, 4) : BV:64
6 : 4 { 0x4 +1.47e129 } : BV:32
7 : bvzero_ext(6, 4) : BV:64
8 : bvmul(5, 7) : BV:64
9 : 63 { 0x3f +1.0e1025 } : INT
10 : bvextract(8, 9, 4) : BV:32
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : eq(10, 11) : BOOL
13 : eq(10, 2) : BOOL
14 : ite(3, 12, 13) : BOOL
15 : 4 { 0x4 +1.0e1025 } : INT
16 : isindexforsize(14, 15) : BOOL
17 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
18 : bvmul(1, 6) : BV:32
19 : bvadd(2, 18) : BV:32
20 : bvadd(17, 19) : BV:32
21 : isgepoffset(20, 18) : BOOL
22 : and(16, 21) : BOOL
23 : islangaligned(20, 15) : BOOL
24 : and(22, 23) : BOOL
25 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
26 : 8 { 0x8 +1.95e129 } : BV:32
27 : bvmul(2, 26) : BV:32
28 : bvadd(2, 27) : BV:32
29 : bvadd(25, 28) : BV:32
30 : isgepoffset(29, 27) : BOOL
31 : bvslt(2, 2) : BOOL
32 : bvsign_ext(2, 4) : BV:64
33 : bvzero_ext(26, 4) : BV:64
34 : bvmul(32, 33) : BV:64
35 : bvextract(34, 9, 4) : BV:32
36 : eq(35, 11) : BOOL
37 : eq(35, 2) : BOOL
38 : ite(31, 36, 37) : BOOL
39 : 8 { 0x8 +1.0e1025 } : INT
40 : isindexforsize(38, 39) : BOOL
41 : and(30, 40) : BOOL
42 : bvadd(28, 2) : BV:32
43 : bvadd(25, 42) : BV:32
44 : isgepoffset(43, 2) : BOOL
45 : and(41, 44) : BOOL
46 : and(24, 45) : BOOL
47 : islangaligned(43, 15) : BOOL
48 : and(46, 47) : BOOL
49 : bvadd(28, 6) : BV:32
50 : bvadd(25, 49) : BV:32
51 : isgepoffset(50, 6) : BOOL
52 : and(41, 51) : BOOL
53 : and(48, 52) : BOOL
=Edge.Assumes.end
=Edge.te_comment
0:2:(((((((  %0 = bitcast i8* %call to %struct.list*, !dbg !32*  %arrayidx = getelementptr inbounds i32, i32* %arr, i32 %i.0, !dbg !36)*(  %arrayidx = getelementptr inbounds i32, i32* %arr, i32 %i.0, !dbg !36*  %arrayidx = getelementptr inbounds i32, i32* %arr, i32 %i.0, !dbg !36))*(  %1 = load i32, i32* %arrayidx, align 4, !dbg !36*  %1 = load i32, i32* %arrayidx, align 4, !dbg !36))*((  %val = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 0, !dbg !37*  %val = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 0, !dbg !37)*(  %val = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 0, !dbg !37*  %val = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 0, !dbg !37)))*  store i32 %1, i32* %val, align 4, !dbg !38)*((  %next = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 1, !dbg !39*  %next = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 1, !dbg !39)*(  %next = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 1, !dbg !39*  %next = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 1, !dbg !39)))*(((((  store %struct.list* %l.0, %struct.list** %next, align 4, !dbg !40*  br label %for.inc, !dbg !41)*  br label %for.inc, !dbg !41)*  br label %for.inc, !dbg !41)*(((((  %inc = add i32 %i.0, 1, !dbg !42*  br label %for.cond, !dbg !43, !llvm.loop !44)*  %l.0 = phi %struct.list* [ null, %entry ], [ %0, %for.inc ], !dbg !22)*(  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ], !dbg !27*  br label %for.cond, !dbg !43, !llvm.loop !44))*  br label %for.cond, !dbg !43, !llvm.loop !44)*(  br label %for.cond, !dbg !43, !llvm.loop !44*  br label %for.cond, !dbg !43, !llvm.loop !44)))*(ghost_var.itervar.firstedge*ghost_var.itervar.secondedge)))
tfg_edge_comment end

=graph_with_predicates_done

=start_pc_preconditions
=start_pc_precondition.0
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
5 : 4 { 0x4 +1.0e1025 } : INT
6 : 0 { 0x0 } : BOOL
7 : select(1, 2, 3, 4, 5, 6) : BV:32
=RhsExpr
1 : input.dst.llvm-%arr : BV:32
=predicate done
=start_pc_precondition.1
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
5 : 4 { 0x4 +1.0e1025 } : INT
6 : 0 { 0x0 } : BOOL
7 : select(1, 2, 3, 4, 5, 6) : BV:32
=RhsExpr
1 : input.dst.llvm-%n : BV:32
=predicate done
=graph_with_precondition_done

=Locs in dst.llvm.make_list
=Loc 100006 in dst.llvm.make_list.
REGMEM
dst.llvm-%n
1 : input.dst.llvm-%n : BV:32
=Loc 100008 in dst.llvm.make_list.
REGMEM
dst.llvm-%arr
1 : input.dst.llvm-%arr : BV:32
=Loc 100031 in dst.llvm.make_list.
REGMEM
dst.llvm-%hidden-reg
1 : input.dst.llvm-%hidden-reg : BV:32
=Loc 100033 in dst.llvm.make_list.
REGMEM
dst.llvm-callee-save.0
1 : input.dst.llvm-callee-save.0 : BV:32
=Loc 100034 in dst.llvm.make_list.
REGMEM
dst.llvm-callee-save.1
1 : input.dst.llvm-callee-save.1 : BV:32
=Loc 100035 in dst.llvm.make_list.
REGMEM
dst.llvm-callee-save.2
1 : input.dst.llvm-callee-save.2 : BV:32
=Loc 100036 in dst.llvm.make_list.
REGMEM
dst.llvm-callee-save.3
1 : input.dst.llvm-callee-save.3 : BV:32
=Loc 100040 in dst.llvm.make_list.
REGMEM
dst.local_alloc_count.=L0%0%d=
1 : input.dst.local_alloc_count.=L0%0%d= : COUNT
=Loc 100041 in dst.llvm.make_list.
REGMEM
dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
=Loc 100042 in dst.llvm.make_list.
REGMEM
dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
=Loc 100044 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.0
=Loc 100045 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100046 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
=Loc 100047 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem-may-straddle-symbol.1-heap
=Loc 100048 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
=Loc 100049 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100050 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.1
=Loc 100051 in dst.llvm.make_list.
REGMEM
dst.llvm-%arr.Lfor.body%2%d
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=Loc 100052 in dst.llvm.make_list.
REGMEM
dst.llvm-%arr.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=Loc 100053 in dst.llvm.make_list.
REGMEM
dst.llvm-%call.Lfor.body%1%fcallEnd
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=Loc 100054 in dst.llvm.make_list.
REGMEM
dst.llvm-%call.Lfor.body%2%d
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=Loc 100055 in dst.llvm.make_list.
REGMEM
dst.llvm-%i.0.Lfor.body%2%d
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=Loc 100056 in dst.llvm.make_list.
REGMEM
dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=Loc 100057 in dst.llvm.make_list.
REGMEM
dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=Loc 100058 in dst.llvm.make_list.
REGMEM
dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=Loc 100059 in dst.llvm.make_list.
REGMEM
dst.llvm-%l.0.Lfor.body%2%d
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=Loc 100060 in dst.llvm.make_list.
REGMEM
dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=Loc 100061 in dst.llvm.make_list.
REGMEM
dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=Loc 100062 in dst.llvm.make_list.
REGMEM
dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=Loc 100063 in dst.llvm.make_list.
REGMEM
dst.llvm-%n.Lfor.body%2%d
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=Loc 100064 in dst.llvm.make_list.
REGMEM
dst.llvm-%n.Lfor.cond%1%bbentry
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=Loc 100065 in dst.llvm.make_list.
REGMEM
dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=Loc 100066 in dst.llvm.make_list.
REGMEM
dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=Loc 100067 in dst.llvm.make_list.
REGMEM
dst.llvm-%hidden-reg.E0%0%d
1 : input.dst.llvm-%hidden-reg.E0%0%d : BV:32
=Loc 100068 in dst.llvm.make_list.
REGMEM
dst.llvm-%ret-reg.E0%0%d
1 : input.dst.llvm-%ret-reg.E0%0%d : BV:32
=Loc 100069 in dst.llvm.make_list.
REGMEM
dst.llvm-indir_tgt.E0%0%d
1 : input.dst.llvm-indir_tgt.E0%0%d : BV:32
=Loc 100070 in dst.llvm.make_list.
REGMEM
dst.llvm-%cmp.Lfor.cond%2%d
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=Loc 100071 in dst.llvm.make_list.
REGMEM
dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=Loc 100072 in dst.llvm.make_list.
REGMEM
dst.llvm-%0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=Loc 100073 in dst.llvm.make_list.
REGMEM
dst.llvm-%1.Lfor.cond%1%bbentry
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=Loc 100074 in dst.llvm.make_list.
REGMEM
dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100075 in dst.llvm.make_list.
REGMEM
dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100076 in dst.llvm.make_list.
REGMEM
dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=Loc 100077 in dst.llvm.make_list.
REGMEM
dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100078 in dst.llvm.make_list.
REGMEM
dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100079 in dst.llvm.make_list.
REGMEM
dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100080 in dst.llvm.make_list.
REGMEM
dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=Loc 100081 in dst.llvm.make_list.
REGMEM
dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=Loc 100082 in dst.llvm.make_list.
REGMEM
dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=Loc 100083 in dst.llvm.make_list.
REGMEM
dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100084 in dst.llvm.make_list.
REGMEM
dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100085 in dst.llvm.make_list.
REGMEM
dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100086 in dst.llvm.make_list.
REGMEM
dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=Loc 100087 in dst.llvm.make_list.
REGMEM
dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=Loc 100088 in dst.llvm.make_list.
REGMEM
dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=Loc 100089 in dst.llvm.make_list.
REGMEM
dst.llvm-%inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=Loc 100090 in dst.llvm.make_list.
REGMEM
dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=Loc 100091 in dst.llvm.make_list.
REGMEM
dst.llvm-%next.Lfor.cond%1%bbentry
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=Loc 100092 in dst.llvm.make_list.
REGMEM
dst.llvm-%val.Lfor.cond%1%bbentry
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=Loc 100093 in dst.llvm.make_list.
REGMEM
dst.local_alloc_count.Lfor.body%2%d
1 : input.dst.local_alloc_count.Lfor.body%2%d : COUNT
=Loc 100094 in dst.llvm.make_list.
REGMEM
dst.local_alloc_count.Lfor.cond%1%bbentry
1 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
=Loc 100095 in dst.llvm.make_list.
REGMEM
dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : input.dst.cur_rounding_mode.Lfor.cond%1%bbentry : ROUNDING_MODE
=Loc 100096 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.0
=Loc 100097 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem-may-straddle-symbol.1-heap
=Loc 100098 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100099 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100100 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
=Loc 100101 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
=Loc 100102 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.1
=Loc 100103 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.0
=Loc 100104 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem-may-straddle-symbol.1-heap
=Loc 100105 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100106 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100107 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
=Loc 100108 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
=Loc 100109 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.1
=Loc 100110 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.0
=Loc 100111 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem-may-straddle-symbol.1-heap
=Loc 100112 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100113 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100114 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
=Loc 100115 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
=Loc 100116 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.1
=Locs end
=Liveness in dst.llvm.make_list
=live locs at L0%0%d
100006, 100008, 100040, 100045, 100046, 100047, 100048, 100049, 
=live locs at Lfor.body%1%intermediateVal1
100052, 100053, 100056, 100060, 100064, 100094, 100097, 100098, 100099, 100100, 100101, 
=live locs at Lfor.body%1%fcallStart
100052, 100056, 100060, 100064, 100094, 100104, 100105, 100106, 100107, 100108, 
=live locs at Lfor.body%1%fcallEnd
100052, 100053, 100056, 100060, 100064, 100094, 100097, 100098, 100099, 100100, 100101, 
=live locs at Lfor.body%2%d
100051, 100054, 100055, 100059, 100063, 100093, 100111, 100112, 100113, 100114, 100115, 
=live locs at Lfor.cond%1%bbentry
100052, 100056, 100060[f], 100064, 100094, 100104, 100105, 100106, 100107, 100108, 
=live locs at Lfor.cond%2%d
100052, 100056, 100060[f], 100064, 100070, 100094, 100104, 100105, 100106, 100107, 100108, 
=live locs at Lfor.end%1%d
100060[f], 100104, 
=live locs at E0%0%d
100060[f], 100104, 

=Definedness in dst.llvm.make_list
=loc definedness at L0%0%d
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050
=loc definedness at Lfor.body%1%intermediateVal1
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100053, 100056, 100058, 100060, 100062, 100064, 100065, 100070, 100071, 100094, 100095, 100096, 100097, 100098, 100099, 100100, 100101, 100102, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at Lfor.body%1%fcallStart
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100056, 100058, 100060, 100062, 100064, 100070, 100071, 100094, 100095, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at Lfor.body%1%fcallEnd
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100053, 100056, 100058, 100060, 100062, 100064, 100065, 100070, 100071, 100094, 100095, 100096, 100097, 100098, 100099, 100100, 100101, 100102, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at Lfor.body%2%d
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100051, 100052, 100053, 100054, 100055, 100056, 100057, 100058, 100059, 100060, 100061, 100062, 100063, 100064, 100065, 100066, 100070, 100071, 100093, 100094, 100095, 100096, 100097, 100098, 100099, 100100, 100101, 100102, 100103, 100104, 100105, 100106, 100107, 100108, 100109, 100110, 100111, 100112, 100113, 100114, 100115, 100116
=loc definedness at Lfor.cond%1%bbentry
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100056, 100058, 100060, 100062, 100064, 100071, 100094, 100095, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at Lfor.cond%2%d
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100056, 100058, 100060, 100062, 100064, 100070, 100071, 100094, 100095, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at Lfor.end%1%d
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100056, 100058, 100060, 100062, 100064, 100070, 100071, 100094, 100095, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at E0%0%d
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100056, 100058, 100060, 100062, 100064, 100067, 100068, 100069, 100070, 100071, 100094, 100095, 100103, 100104, 100105, 100106, 100107, 100108, 100109

=Branch affecting variable locs in dst.llvm.make_list
=branch affecting variable locs at L0%0%d
100006
=branch affecting variable locs at Lfor.body%1%intermediateVal1
100056, 100064
=branch affecting variable locs at Lfor.body%1%fcallStart
100056, 100064
=branch affecting variable locs at Lfor.body%1%fcallEnd
100056, 100064
=branch affecting variable locs at Lfor.body%2%d
100055, 100063
=branch affecting variable locs at Lfor.cond%1%bbentry
100056, 100064
=branch affecting variable locs at Lfor.cond%2%d
100056, 100064, 100070
=branch affecting variable locs at Lfor.end%1%d

=branch affecting variable locs at E0%0%d


=Relevant Memlabels in dst.llvm.make_list
=relevant memlabels
=function: make_list
memlabel-mem--arg.0
memlabel-mem-may-straddle-symbol.1-heap
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
memlabel-mem--arg.1
=touched symbol ids

=relevant memlabels done
=graph_with_locs_done
=graph_with_edge_structures
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100052 {input.dst.llvm-%arr.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%arr : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100056 {input.dst.llvm-%i.0.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100058 {input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100060 {input.dst.llvm-%l.0.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100062 {input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100064 {input.dst.llvm-%n.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%n : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100071 {input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100094 {input.dst.local_alloc_count.Lfor.cond%1%bbentry }
1 : input.dst.local_alloc_count.=L0%0%d= : COUNT
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100095 {input.dst.cur_rounding_mode.Lfor.cond%1%bbentry }
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100103 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.0) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100104 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem-may-straddle-symbol.1-heap) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100105 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100106 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100107 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100108 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100109 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.1) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry done
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100051 {input.dst.llvm-%arr.Lfor.body%2%d }
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100054 {input.dst.llvm-%call.Lfor.body%2%d }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
5 : heap_alloc_ptr(2, 4) : BV:32
6 : ite(3, 1, 5) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100055 {input.dst.llvm-%i.0.Lfor.body%2%d }
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100057 {input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d }
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100059 {input.dst.llvm-%l.0.Lfor.body%2%d }
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100061 {input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d }
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100063 {input.dst.llvm-%n.Lfor.body%2%d }
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100066 {input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d }
1 : 8 { 0x8 +1.95e129 } : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : heap_alloc(5, 6, 3, 1) : ARRAY[BV:32 -> MEMLABEL]
8 : ite(4, 5, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : malloc_side_effect(1, 8, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100093 {input.dst.local_alloc_count.Lfor.body%2%d }
1 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
2 : increment_count(1) : COUNT
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100110 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--arg.0) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem--arg.0 : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100111 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem-may-straddle-symbol.1-heap) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100112 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memmask(13, 12, 6) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100113 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100114 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100115 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100116 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--arg.1) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem--arg.1 : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d done
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100053 {input.dst.llvm-%call.Lfor.body%1%fcallEnd }
1 : func.calla4bcb626de6152719ca44f8b649b9c4a.reg : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
2 : memlabel-mem- : MEMLABEL
3 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : nextpc_const.1 : BV:32
6 : 1000 { 0x3e8 +1.11920e129 } : REGID
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : function_call(1, 2, 2, 3, 4, 5, 6, 7) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100065 {input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd }
1 : 8 { 0x8 +1.95e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100096 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.0) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100097 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem-may-straddle-symbol.1-heap) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100098 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100099 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100100 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100101 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100102 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.1) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd done
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 done
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100052 {input.dst.llvm-%arr.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100056 {input.dst.llvm-%i.0.Lfor.cond%1%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100058 {input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100060 {input.dst.llvm-%l.0.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100062 {input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100064 {input.dst.llvm-%n.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100071 {input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100072 {input.dst.llvm-%0.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100073 {input.dst.llvm-%1.Lfor.cond%1%bbentry }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0 : MEMLABEL
4 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
7 : bvmul(5, 6) : BV:32
8 : bvadd(4, 7) : BV:32
9 : 4 { 0x4 +1.0e1025 } : INT
10 : 0 { 0x0 } : BOOL
11 : select(1, 2, 3, 8, 9, 10) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100074 {input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100075 {input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100076 {input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100077 {input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100078 {input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100079 {input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100080 {input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100081 {input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100082 {input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100083 {input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100084 {input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100085 {input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100086 {input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100087 {input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100088 {input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100089 {input.dst.llvm-%inc.Lfor.cond%1%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100090 {input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100091 {input.dst.llvm-%next.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100092 {input.dst.llvm-%val.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100094 {input.dst.local_alloc_count.Lfor.cond%1%bbentry }
1 : input.dst.local_alloc_count.Lfor.body%2%d : COUNT
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100103 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.0) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100104 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem-may-straddle-symbol.1-heap) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100105 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
5 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0 : MEMLABEL
6 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
7 : 4 { 0x4 +1.47e129 } : BV:32
8 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
9 : bvmul(7, 8) : BV:32
10 : bvadd(6, 9) : BV:32
11 : 4 { 0x4 +1.0e1025 } : INT
12 : 0 { 0x0 } : BOOL
13 : select(1, 2, 5, 10, 11, 12) : BV:32
14 : store(1, 2, 3, 4, 13, 11, 12) : ARRAY[BV:32 -> BV:8]
15 : bvadd(7, 4) : BV:32
16 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
17 : store(14, 2, 3, 15, 16, 11, 12) : ARRAY[BV:32 -> BV:8]
18 : memmask(17, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100106 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100107 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100108 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100109 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.1) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry done
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%1%bbentry=>Lfor.cond%2%d
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%1%bbentry=>Lfor.cond%2%d for loc_id 100070 {input.dst.llvm-%cmp.Lfor.cond%2%d }
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%1%bbentry=>Lfor.cond%2%d done
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%2%d=>Lfor.body%1%fcallStart
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%2%d=>Lfor.body%1%fcallStart done
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%2%d=>Lfor.end%1%d
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%2%d=>Lfor.end%1%d done
=graph_with_edge_structures.loc_to_expr_map at Lfor.end%1%d=>E0%0%d
=graph_with_edge_structures.loc_to_expr_map at Lfor.end%1%d=>E0%0%d for loc_id 100067 {input.dst.llvm-%hidden-reg.E0%0%d }
1 : input.dst.llvm-%hidden-reg : BV:32
2 : input.dst.llvm-callee-save.0 : BV:32
3 : bvxor(1, 2) : BV:32
4 : input.dst.llvm-callee-save.1 : BV:32
5 : bvxor(3, 4) : BV:32
6 : input.dst.llvm-callee-save.2 : BV:32
7 : bvxor(5, 6) : BV:32
8 : input.dst.llvm-callee-save.3 : BV:32
9 : bvxor(7, 8) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.end%1%d=>E0%0%d for loc_id 100068 {input.dst.llvm-%ret-reg.E0%0%d }
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.end%1%d=>E0%0%d for loc_id 100069 {input.dst.llvm-indir_tgt.E0%0%d }
1 : retaddr_const : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.end%1%d=>E0%0%d done
=graph_with_edge_structures.loc_to_expr_map done
=graph_with_edge_structures done
=graph_with_ml_contiguity_info vacuous mls
vacuous mls at L0%0%d:
vacuous mls at Lfor.body%1%intermediateVal1:
vacuous mls at Lfor.body%1%fcallStart:
vacuous mls at Lfor.body%1%fcallEnd:
vacuous mls at Lfor.body%2%d:
vacuous mls at Lfor.cond%1%bbentry:
vacuous mls at Lfor.cond%2%d:
vacuous mls at Lfor.end%1%d:
vacuous mls at E0%0%d:
=graph_with_ml_contiguity_info non-vacuous mls
non-vacuous mls at L0%0%d:
non-vacuous mls at Lfor.body%1%intermediateVal1:
non-vacuous mls at Lfor.body%1%fcallStart:
non-vacuous mls at Lfor.body%1%fcallEnd:
non-vacuous mls at Lfor.body%2%d:
non-vacuous mls at Lfor.cond%1%bbentry:
non-vacuous mls at Lfor.cond%2%d:
non-vacuous mls at Lfor.end%1%d:
non-vacuous mls at E0%0%d:
=graph_with_ml_contiguity_info discontiguous mls
discontiguous mls:
=graph_with_ml_contiguity_info done
=Available expressions in dst.llvm.make_list
=avail_exprs begin
=loc 100006
=loc_expr
140456 : input.dst.llvm-%n : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100008
=loc_expr
140457 : input.dst.llvm-%arr : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100031
=loc_expr
140574 : input.dst.llvm-%hidden-reg : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100033
=loc_expr
140575 : input.dst.llvm-callee-save.0 : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100034
=loc_expr
140577 : input.dst.llvm-callee-save.1 : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100035
=loc_expr
140579 : input.dst.llvm-callee-save.2 : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100036
=loc_expr
140581 : input.dst.llvm-callee-save.3 : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100040
=loc_expr
140465 : input.dst.local_alloc_count.=L0%0%d= : COUNT
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100041
=loc_expr
140460 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100042
=loc_expr
140461 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100051
=loc_expr
140760 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=avail_exprs_val.end
=loc 100054
=loc_expr
140757 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
5 : heap_alloc_ptr(2, 4) : BV:32
6 : ite(3, 1, 5) : BV:32
=avail_exprs_val.end
=loc 100063
=loc_expr
140771 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=avail_exprs_val.end
=loc 100065
=loc_expr
140736 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 8 { 0x8 +1.95e129 } : BV:32
=avail_exprs_val.end
=loc 100066
=loc_expr
140806 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 8 { 0x8 +1.95e129 } : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : heap_alloc(5, 6, 3, 1) : ARRAY[BV:32 -> MEMLABEL]
8 : ite(4, 5, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : malloc_side_effect(1, 8, 6) : BV:32
=avail_exprs_val.end
=loc 100067
=loc_expr
140807 : input.dst.llvm-%hidden-reg.E0%0%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%hidden-reg : BV:32
2 : input.dst.llvm-callee-save.0 : BV:32
3 : bvxor(1, 2) : BV:32
4 : input.dst.llvm-callee-save.1 : BV:32
5 : bvxor(3, 4) : BV:32
6 : input.dst.llvm-callee-save.2 : BV:32
7 : bvxor(5, 6) : BV:32
8 : input.dst.llvm-callee-save.3 : BV:32
9 : bvxor(7, 8) : BV:32
=avail_exprs_val.end
=loc 100068
=loc_expr
140808 : input.dst.llvm-%ret-reg.E0%0%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.end
=loc 100069
=loc_expr
140809 : input.dst.llvm-indir_tgt.E0%0%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : retaddr_const : BV:32
=avail_exprs_val.end
=loc 100072
=loc_expr
140810 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=avail_exprs_val.end
=loc 100073
=loc_expr
140811 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0 : MEMLABEL
4 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
7 : bvmul(5, 6) : BV:32
8 : bvadd(4, 7) : BV:32
9 : 4 { 0x4 +1.0e1025 } : INT
10 : 0 { 0x0 } : BOOL
11 : select(1, 2, 3, 8, 9, 10) : BV:32
=avail_exprs_val.end
=loc 100074
=loc_expr
140812 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=avail_exprs_val.end
=loc 100075
=loc_expr
140813 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=avail_exprs_val.end
=loc 100076
=loc_expr
140814 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=avail_exprs_val.end
=loc 100077
=loc_expr
140815 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100078
=loc_expr
140816 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
=avail_exprs_val.end
=loc 100079
=loc_expr
140817 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=avail_exprs_val.end
=loc 100080
=loc_expr
140818 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100081
=loc_expr
140819 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
=avail_exprs_val.end
=loc 100082
=loc_expr
140820 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=avail_exprs_val.end
=loc 100083
=loc_expr
140821 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100084
=loc_expr
140822 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100085
=loc_expr
140823 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=avail_exprs_val.end
=loc 100086
=loc_expr
140824 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100087
=loc_expr
140825 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100088
=loc_expr
140826 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=avail_exprs_val.end
=loc 100089
=loc_expr
140827 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=avail_exprs_val.end
=loc 100090
=loc_expr
140828 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=avail_exprs_val.end
=loc 100091
=loc_expr
140829 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=avail_exprs_val.end
=loc 100092
=loc_expr
140830 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=avail_exprs_val.end
=loc 100095
=loc_expr
140831 : input.dst.cur_rounding_mode.Lfor.cond%1%bbentry : ROUNDING_MODE
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=avail_exprs_val.end
=avail_exprs end
=sprel_map in dst.llvm.make_list
=loc 100065 expr
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=loc 100065 spreled-expr
140474 : 8 { 0x8 +1.95e129 } : BV:32
=loc 100069 expr
1 : input.dst.llvm-indir_tgt.E0%0%d : BV:32
=loc 100069 spreled-expr
140267 : retaddr_const : BV:32
=loc 100077 expr
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=loc 100077 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100078 expr
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=loc 100078 spreled-expr
140427 : 4 { 0x4 +1.47e129 } : BV:32
=loc 100080 expr
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=loc 100080 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100081 expr
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=loc 100081 spreled-expr
140427 : 4 { 0x4 +1.47e129 } : BV:32
=loc 100083 expr
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=loc 100083 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100084 expr
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=loc 100084 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100086 expr
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=loc 100086 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100087 expr
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=loc 100087 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100095 expr
1 : input.dst.cur_rounding_mode.Lfor.cond%1%bbentry : ROUNDING_MODE
=loc 100095 spreled-expr
140466 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=sprel_map done
=lr-status-map
=lr-status-map at call-context {*;make_list}
=loc_id 100006 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=loc_id 100008 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100031 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100033 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100034 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100035 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100036 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100040 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100041 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100042 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100044 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100045 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100046 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100047 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100048 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100049 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100050 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100051 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100052 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100053 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; )
=loc_id 100054 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100055 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100056 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100057 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100058 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100059 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100060 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100061 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100062 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100063 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=loc_id 100064 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=loc_id 100065 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100066 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100067 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100068 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100069 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100070 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100071 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100072 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100073 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100074 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100075 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100076 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100077 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100078 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100079 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100080 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100081 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100082 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100083 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100084 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100085 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100086 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100087 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100088 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100089 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100090 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100091 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100092 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100093 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100094 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100095 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100096 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100097 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100098 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100099 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100100 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100101 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100102 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100103 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100104 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100105 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100106 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100107 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100108 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100109 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100110 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100111 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100112 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100113 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100114 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100115 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100116 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=lr-status-map done
=lr-status-for-sprel-locs-map
=loc_id 100065 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100069 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100077 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100078 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100080 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100081 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100083 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100084 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100086 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100087 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100095 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=lr-status-for-sprel-locs-map done
=graph_with_aliasing_done
=Memlabel assertions empty
=Memlabel assertions done
=graph_with_proofs done
=graph_with_ce done
=graph_with_points done
=graph_with_guessing done
=graph_with_simplified_assets
=graph_with_simplified_assets.simplified_edgecond at L0%0%d=>Lfor.cond%1%bbentry
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.body%1%intermediateVal1=>Lfor.body%2%d
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.body%2%d=>Lfor.cond%1%bbentry
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.cond%1%bbentry=>Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.cond%2%d=>Lfor.body%1%fcallStart
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.cond%2%d=>Lfor.end%1%d
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
2 : not(1) : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.end%1%d=>E0%0%d
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond done
=graph_with_simplified_assets.simplified_to_state at L0%0%d=>Lfor.cond%1%bbentry
=dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=dst.llvm-%arr.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr : BV:32
=dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%n.Lfor.cond%1%bbentry
1 : input.dst.llvm-%n : BV:32
=dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-mem.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.cond%1%bbentry
1 : input.dst.local_alloc_count.=L0%0%d= : COUNT
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=dst.llvm-%arr.Lfor.body%2%d
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%call.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
5 : heap_alloc_ptr(2, 4) : BV:32
6 : ite(3, 1, 5) : BV:32
=dst.llvm-%i.0.Lfor.body%2%d
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%l.0.Lfor.body%2%d
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%n.Lfor.body%2%d
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : heap_alloc(5, 6, 3, 1) : ARRAY[BV:32 -> MEMLABEL]
8 : ite(4, 5, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : malloc_side_effect(1, 8, 6) : BV:32
=dst.llvm-mem.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
6 : 8 { 0x8 +1.95e129 } : BV:32
7 : heap_alloc(4, 5, 2, 6) : ARRAY[BV:32 -> MEMLABEL]
8 : ite(3, 4, 7) : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.body%2%d
1 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
2 : increment_count(1) : COUNT
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=dst.llvm-%call.Lfor.body%1%fcallEnd
1 : func.calla4bcb626de6152719ca44f8b649b9c4a.reg : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
2 : memlabel-mem- : MEMLABEL
3 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : nextpc_const.1 : BV:32
6 : 1000 { 0x3e8 +1.11920e129 } : REGID
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : function_call(1, 2, 2, 3, 4, 5, 6, 7) : BV:32
=dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=dst.llvm-mem.Lfor.body%1%fcallEnd
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.body%2%d=>Lfor.cond%1%bbentry
=dst.llvm-%arr.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=dst.llvm-%n.Lfor.cond%1%bbentry
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-mem.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
5 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0 : MEMLABEL
6 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
7 : 4 { 0x4 +1.47e129 } : BV:32
8 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
9 : bvmul(7, 8) : BV:32
10 : bvadd(6, 9) : BV:32
11 : 4 { 0x4 +1.0e1025 } : INT
12 : 0 { 0x0 } : BOOL
13 : select(1, 2, 5, 10, 11, 12) : BV:32
14 : store(1, 2, 3, 4, 13, 11, 12) : ARRAY[BV:32 -> BV:8]
15 : bvadd(7, 4) : BV:32
16 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
17 : store(14, 2, 3, 15, 16, 11, 12) : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.cond%1%bbentry
1 : input.dst.local_alloc_count.Lfor.body%2%d : COUNT
=dst.llvm-%0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%1.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0 : MEMLABEL
4 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
7 : bvmul(5, 6) : BV:32
8 : bvadd(4, 7) : BV:32
9 : 4 { 0x4 +1.0e1025 } : INT
10 : 0 { 0x0 } : BOOL
11 : select(1, 2, 3, 8, 9, 10) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%next.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%val.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.cond%1%bbentry=>Lfor.cond%2%d
=dst.llvm-%cmp.Lfor.cond%2%d
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.cond%2%d=>Lfor.body%1%fcallStart
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.cond%2%d=>Lfor.end%1%d
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.end%1%d=>E0%0%d
=dst.llvm-%hidden-reg.E0%0%d
1 : input.dst.llvm-%hidden-reg : BV:32
2 : input.dst.llvm-callee-save.0 : BV:32
3 : bvxor(1, 2) : BV:32
4 : input.dst.llvm-callee-save.1 : BV:32
5 : bvxor(3, 4) : BV:32
6 : input.dst.llvm-callee-save.2 : BV:32
7 : bvxor(5, 6) : BV:32
8 : input.dst.llvm-callee-save.3 : BV:32
9 : bvxor(7, 8) : BV:32
=dst.llvm-%ret-reg.E0%0%d
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=dst.llvm-indir_tgt.E0%0%d
1 : retaddr_const : BV:32
=state_end
=graph_with_simplified_assets.simplified_to_state done
=graph_with_simplified_assets.simplified_assumes at L0%0%d=>Lfor.cond%1%bbentry
=graph_with_simplified_assets.simplified_assumes at L0%0%d=>Lfor.cond%1%bbentry assume# 0
1 : input.dst.llvm-%arr : BV:32
2 : 4 { 0x4 +1.0e1025 } : INT
3 : islangaligned(1, 2) : BOOL
=graph_with_simplified_assets.simplified_assumes at L0%0%d=>Lfor.cond%1%bbentry done
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume# 0
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : 8 { 0x8 +1.95e129 } : BV:32
6 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
7 : region_agrees_with_memlabel(4, 2, 5, 6) : BOOL
8 : or(3, 7) : BOOL
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume# 1
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 } : BOOL
5 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
6 : heap_alloc_ptr(2, 5) : BV:32
7 : 7 { 0x7 +1.83e129 } : BV:32
8 : bvadd(7, 6) : BV:32
9 : bvule(6, 8) : BOOL
10 : or(4, 9) : BOOL
11 : or(3, 10) : BOOL
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%intermediateVal1=>Lfor.body%2%d done
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd done
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 assume# 0
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : islangaligned(1, 2) : BOOL
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 done
=graph_with_simplified_assets.simplified_assumes at Lfor.body%2%d=>Lfor.cond%1%bbentry
=graph_with_simplified_assets.simplified_assumes at Lfor.body%2%d=>Lfor.cond%1%bbentry assume# 0
1 : 1 { 0x1 } : BOOL
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : isgepoffset(2, 3) : BOOL
5 : and(1, 4) : BOOL
6 : 4 { 0x4 +1.0e1025 } : BV:64
7 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
8 : 32 { 0x20 +1.0e1025 } : INT
9 : bvsign_ext(7, 8) : BV:64
10 : bvmul(6, 9) : BV:64
11 : 63 { 0x3f +1.0e1025 } : INT
12 : bvextract(10, 11, 8) : BV:32
13 : bvslt(7, 3) : BOOL
14 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
15 : ite(13, 14, 3) : BV:32
16 : eq(12, 15) : BOOL
17 : 4 { 0x4 +1.0e1025 } : INT
18 : isindexforsize(16, 17) : BOOL
19 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 7) : BV:32
22 : bvadd(19, 21) : BV:32
23 : isgepoffset(22, 21) : BOOL
24 : and(18, 23) : BOOL
25 : islangaligned(22, 17) : BOOL
26 : and(24, 25, 4, 5) : BOOL
27 : islangaligned(2, 17) : BOOL
28 : bvadd(20, 2) : BV:32
29 : isgepoffset(28, 20) : BOOL
30 : and(5, 26, 27, 29) : BOOL
=graph_with_simplified_assets.simplified_assumes at Lfor.body%2%d=>Lfor.cond%1%bbentry assume# 1
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
4 : 4 { 0x4 +1.0e1025 } : INT
5 : islangaligned(3, 4) : BOOL
=graph_with_simplified_assets.simplified_assumes at Lfor.body%2%d=>Lfor.cond%1%bbentry done
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%1%bbentry=>Lfor.cond%2%d
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%1%bbentry=>Lfor.cond%2%d done
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%2%d=>Lfor.body%1%fcallStart
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%2%d=>Lfor.body%1%fcallStart done
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%2%d=>Lfor.end%1%d
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%2%d=>Lfor.end%1%d done
=graph_with_simplified_assets.simplified_assumes at Lfor.end%1%d=>E0%0%d
=graph_with_simplified_assets.simplified_assumes at Lfor.end%1%d=>E0%0%d done
=graph_with_simplified_assets.simplified_assumes done
=graph_with_simplified_assets done
=max-memlabel-varnum
5
=String-contents:
=Nextpc-map:
C_NEXTPC1 : malloc
=Nextpc-map done
=suffixpaths for dst.llvm.make_list
=suffixpath_at_L0%0%d for dst.llvm.make_list
=suffixpath_at_L0%0%d.graph_edge_composition
(epsilon)
=suffixpath_at_Lfor.body%1%intermediateVal1 for dst.llvm.make_list
=suffixpath_at_Lfor.body%1%intermediateVal1.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*((Lfor.cond%2%d=>Lfor.body%1%fcallStart)*((Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd)*(Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1)))))
=suffixpath_at_Lfor.body%1%fcallStart for dst.llvm.make_list
=suffixpath_at_Lfor.body%1%fcallStart.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*(Lfor.cond%2%d=>Lfor.body%1%fcallStart)))
=suffixpath_at_Lfor.body%1%fcallEnd for dst.llvm.make_list
=suffixpath_at_Lfor.body%1%fcallEnd.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*((Lfor.cond%2%d=>Lfor.body%1%fcallStart)*(Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd))))
=suffixpath_at_Lfor.body%2%d for dst.llvm.make_list
=suffixpath_at_Lfor.body%2%d.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*((Lfor.cond%2%d=>Lfor.body%1%fcallStart)*((Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd)*((Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1)*(Lfor.body%1%intermediateVal1=>Lfor.body%2%d))))))
=suffixpath_at_Lfor.cond%1%bbentry for dst.llvm.make_list
=suffixpath_at_Lfor.cond%1%bbentry.graph_edge_composition
(L0%0%d=>Lfor.cond%1%bbentry)
=suffixpath_at_Lfor.cond%2%d for dst.llvm.make_list
=suffixpath_at_Lfor.cond%2%d.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*(Lfor.cond%1%bbentry=>Lfor.cond%2%d))
=suffixpath_at_Lfor.end%1%d for dst.llvm.make_list
=suffixpath_at_Lfor.end%1%d.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*(Lfor.cond%2%d=>Lfor.end%1%d)))
=suffixpath_at_E0%0%d for dst.llvm.make_list
=suffixpath_at_E0%0%d.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*((Lfor.cond%2%d=>Lfor.end%1%d)*(Lfor.end%1%d=>E0%0%d))))
=suffixpaths for dst.llvm.make_list done
=tfg.assumes_around_edge
tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry
tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry assume #0
tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry assume #0.ec
tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry assume #0.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry assume #0.pred
=Comment
undef-behaviour-align-assume.edge.L0%0%d=>Lfor.cond%1%bbentry
=LhsExpr
140457 : input.dst.llvm-%arr : BV:32
140430 : 4 { 0x4 +1.0e1025 } : INT
140467 : islangaligned(140457, 140430) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry done
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #0
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #0.ec
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #0.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #0.pred
=Comment
undef-behavioursome.edge.Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140903 : eq(140276, 140713) : BOOL
140714 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
140474 : 8 { 0x8 +1.95e129 } : BV:32
140462 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
141257 : region_agrees_with_memlabel(140714, 140713, 140474, 140462) : BOOL
141263 : or(140903, 141257) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #1
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #1.ec
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #1.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #1.pred
=Comment
undef-behavioursome.edge.Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140903 : eq(140276, 140713) : BOOL
140431 : 0 { 0x0 } : BOOL
140487 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
140722 : heap_alloc_ptr(140713, 140487) : BV:32
140647 : 7 { 0x7 +1.83e129 } : BV:32
140944 : bvadd(140647, 140722) : BV:32
140947 : bvule(140722, 140944) : BOOL
140950 : or(140431, 140947) : BOOL
140954 : or(140903, 140950) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d done
tfg.assumes_around_edge at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
tfg.assumes_around_edge at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd done
tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 assume #0
tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 assume #0.ec
tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 assume #0.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 assume #0.pred
=Comment
undef-behaviour-align-assume.edge.Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
=LhsExpr
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140287 : 1 { 0x1 +1.0e1025 } : INT
140750 : islangaligned(140713, 140287) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 done
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #0
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #0.ec
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #0.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #0.pred
=Comment
undef-behavioursome.edge.Lfor.body%2%d=>Lfor.cond%1%bbentry
=LhsExpr
140275 : 1 { 0x1 } : BOOL
140757 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
140276 : 0 { 0x0 +1.0e129 } : BV:32
141130 : isgepoffset(140757, 140276) : BOOL
141141 : and(140275, 141130) : BOOL
140652 : 4 { 0x4 +1.0e1025 } : BV:64
140761 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
140519 : 32 { 0x20 +1.0e1025 } : INT
140781 : bvsign_ext(140761, 140519) : BV:64
141102 : bvmul(140652, 140781) : BV:64
140523 : 63 { 0x3f +1.0e1025 } : INT
141103 : bvextract(141102, 140523, 140519) : BV:32
140780 : bvslt(140761, 140276) : BOOL
140505 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
141116 : ite(140780, 140505, 140276) : BV:32
141118 : eq(141103, 141116) : BOOL
140430 : 4 { 0x4 +1.0e1025 } : INT
141120 : isindexforsize(141118, 140430) : BOOL
140760 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
140427 : 4 { 0x4 +1.47e129 } : BV:32
141073 : bvmul(140427, 140761) : BV:32
141077 : bvadd(140760, 141073) : BV:32
141122 : isgepoffset(141077, 141073) : BOOL
141124 : and(141120, 141122) : BOOL
141126 : islangaligned(141077, 140430) : BOOL
141147 : and(141124, 141126, 141130, 141141) : BOOL
141149 : islangaligned(140757, 140430) : BOOL
141080 : bvadd(140427, 140757) : BV:32
141155 : isgepoffset(141080, 140427) : BOOL
141163 : and(141141, 141147, 141149, 141155) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #1
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #1.ec
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #1.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #1.pred
=Comment
undef-behaviour-align-assume.edge.Lfor.body%2%d=>Lfor.cond%1%bbentry
=LhsExpr
140427 : 4 { 0x4 +1.47e129 } : BV:32
140757 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
141080 : bvadd(140427, 140757) : BV:32
140430 : 4 { 0x4 +1.0e1025 } : INT
141094 : islangaligned(141080, 140430) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry done
tfg.assumes_around_edge at Lfor.cond%1%bbentry=>Lfor.cond%2%d
tfg.assumes_around_edge at Lfor.cond%1%bbentry=>Lfor.cond%2%d done
tfg.assumes_around_edge at Lfor.cond%2%d=>Lfor.body%1%fcallStart
tfg.assumes_around_edge at Lfor.cond%2%d=>Lfor.body%1%fcallStart done
tfg.assumes_around_edge at Lfor.cond%2%d=>Lfor.end%1%d
tfg.assumes_around_edge at Lfor.cond%2%d=>Lfor.end%1%d done
tfg.assumes_around_edge at Lfor.end%1%d=>E0%0%d
tfg.assumes_around_edge at Lfor.end%1%d=>E0%0%d done
tfg.assumes_around_edge done
=TFGdone
=PC_to_linename:
=pc
Lentry%1%d
=linename
line 8
=pc
Lfor.body%1%d
=linename
line 9
=pc
Lfor.body%2%d
=linename
line 9
=pc
Lfor.body%3%d
=linename
line 10
=pc
Lfor.body%4%d
=linename
line 10
=pc
Lfor.body%5%d
=linename
line 10
=pc
Lfor.body%6%d
=linename
line 10
=pc
Lfor.body%7%d
=linename
line 11
=pc
Lfor.body%8%d
=linename
line 11
=pc
Lfor.body%9%d
=linename
line 13
=pc
Lfor.cond%1%d
=linename
line 8
=pc
Lfor.cond%2%d
=linename
line 8
=pc
Lfor.end%1%d
=linename
line 14
=pc
Lfor.inc%1%d
=linename
line 8
=pc
Lfor.inc%2%d
=linename
line 8
=PC_to_linename done
=PC_to_column_name:
=pc
Lentry%1%d
=column_name
 at column 8
=pc
Lfor.body%1%d
=column_name
 at column 18
=pc
Lfor.body%2%d
=column_name
 at column 18
=pc
Lfor.body%3%d
=column_name
 at column 17
=pc
Lfor.body%4%d
=column_name
 at column 17
=pc
Lfor.body%5%d
=column_name
 at column 11
=pc
Lfor.body%6%d
=column_name
 at column 15
=pc
Lfor.body%7%d
=column_name
 at column 11
=pc
Lfor.body%8%d
=column_name
 at column 16
=pc
Lfor.body%9%d
=column_name
 at column 3
=pc
Lfor.cond%1%d
=column_name
 at column 26
=pc
Lfor.cond%2%d
=column_name
 at column 3
=pc
Lfor.end%1%d
=column_name
 at column 3
=pc
Lfor.inc%1%d
=column_name
 at column 31
=pc
Lfor.inc%2%d
=column_name
 at column 3
=PC_to_column_name done
=PC_to_line_and_column:
=pc
Lentry%1%d
=line_and_column
(line 8 at column 8)
=pc
Lfor.body%1%d
=line_and_column
line 9
=pc
Lfor.body%2%d
=line_and_column
line 9
=pc
Lfor.body%3%d
=line_and_column
(line 10 at column 17)
=pc
Lfor.body%4%d
=line_and_column
(line 10 at column 17)
=pc
Lfor.body%5%d
=line_and_column
(line 10 at column 11)
=pc
Lfor.body%6%d
=line_and_column
(line 10 at column 15)
=pc
Lfor.body%7%d
=line_and_column
(line 11 at column 11)
=pc
Lfor.body%8%d
=line_and_column
(line 11 at column 16)
=pc
Lfor.body%9%d
=line_and_column
line 13
=pc
Lfor.cond%1%d
=line_and_column
(line 8 at column 26)
=pc
Lfor.cond%2%d
=line_and_column
(line 8 at column 3)
=pc
Lfor.end%1%d
=line_and_column
line 14
=pc
Lfor.inc%1%d
=line_and_column
(line 8 at column 31)
=pc
Lfor.inc%2%d
=line_and_column
(line 8 at column 3)
=PC_to_line_and_column done
=SourceToLLVMVarnames:
=SourceToLLVMVarnames done
=InputLLVMToSourceVarnames:
input.dst.llvm-%n : L0%0%d : n'
input.dst.llvm-%arr : L0%0%d : arr'
input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : L0%0%d : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : L0%0%d : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
input.dst.llvm-%l.0 : Lfor.cond%1%bbentry : l'
input.dst.local_alloc_count.=L0%0%d= : L0%0%d : input.dst.local_alloc_count.=L0%0%d=
input.dst.llvm-%i.0 : Lfor.cond%1%bbentry : i'
input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset : L0%0%d : bvmul(input.dst.llvm-%i.0, 4)
input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset : L0%0%d : (arr' + input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset)
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset : L0%0%d : 0
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset : L0%0%d : 0
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset : L0%0%d : input.dst.llvm-%0
input.dst.llvm-%1 : L0%0%d : DSTMEM[input.dst.llvm-%arrayidx]_4
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset : L0%0%d : 0
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset : L0%0%d : 4
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset : L0%0%d : (4 + input.dst.llvm-%0)
input.dst.llvm-%inc : Lfor.inc%2%bbentry : i'
input.dst.llvm-%hidden-reg : L0%0%d : input.dst.llvm-%hidden-reg
input.dst.llvm-callee-save.0 : L0%0%d : input.dst.llvm-callee-save.0
input.dst.llvm-callee-save.1 : L0%0%d : input.dst.llvm-callee-save.1
input.dst.llvm-callee-save.2 : L0%0%d : input.dst.llvm-callee-save.2
input.dst.llvm-callee-save.3 : L0%0%d : input.dst.llvm-callee-save.3
input.dst.llvm-%0 : Lfor.body%3%bbentry : node'
input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset : L0%0%d : bvmul(input.dst.llvm-%i.0, 4)
input.dst.llvm-%arrayidx : L0%0%d : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset : L0%0%d : 0
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset : L0%0%d : 0
input.dst.llvm-%val : L0%0%d : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset : L0%0%d : 0
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset : L0%0%d : 4
input.dst.llvm-%next : L0%0%d : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset
input.dst.llvm-%l.0.phi.tmpvar.for.inc : L0%0%d : input.dst.llvm-%0
input.dst.llvm-%i.0.phi.tmpvar.for.inc : L0%0%d : input.dst.llvm-%inc
input.dst.llvm-%ret-reg : L0%0%d : input.dst.llvm-%l.0
input.dst.llvm-indir_tgt : L0%0%d : return-address
input.dst.cur_rounding_mode : L0%0%d : ROUND_to_nearest_ties_to_even
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : L0%0%d : 8
input.dst.llvm-%n.Lfor.body%2%d : L0%0%d : malloc_side_effect(input.dst.llvm-%n.Lfor.cond%1%bbentry, ite(input.dst.llvm-%call.Lfor.body%1%fcallEnd = 0, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, heap_alloc(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, input.dst.llvm-%call.Lfor.body%1%fcallEnd, 8)), memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/)
input.dst.llvm-%arr.Lfor.body%2%d : L0%0%d : malloc_side_effect(input.dst.llvm-%arr.Lfor.cond%1%bbentry, ite(input.dst.llvm-%call.Lfor.body%1%fcallEnd = 0, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, heap_alloc(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, input.dst.llvm-%call.Lfor.body%1%fcallEnd, 8)), memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/)
input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : L0%0%d : (1 + input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%call.Lfor.body%2%d : L0%0%d : ite(input.dst.llvm-%call.Lfor.body%1%fcallEnd = 0, 0, heap_alloc_ptr(input.dst.llvm-%call.Lfor.body%1%fcallEnd, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/))
input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : L0%0%d : bvmul(4, input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : L0%0%d : 4
input.dst.llvm-indir_tgt.E0%0%d : L0%0%d : return-address
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : L0%0%d : (4 + input.dst.llvm-%call.Lfor.body%2%d)
input.dst.llvm-%ret-reg.E0%0%d : L0%0%d : input.dst.llvm-%l.0.Lfor.cond%1%bbentry
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : L0%0%d : malloc_side_effect(8, ite(input.dst.llvm-%call.Lfor.body%1%fcallEnd = 0, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, heap_alloc(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, input.dst.llvm-%call.Lfor.body%1%fcallEnd, 8)), memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/)
input.dst.llvm-%hidden-reg.E0%0%d : L0%0%d : bvxor(bvxor(bvxor(bvxor(input.dst.llvm-%hidden-reg, input.dst.llvm-callee-save.0), input.dst.llvm-callee-save.1), input.dst.llvm-callee-save.2), input.dst.llvm-callee-save.3)
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : L0%0%d : 4
input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : L0%0%d : (input.dst.llvm-%arr.Lfor.body%2%d + 4*input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%0.Lfor.cond%1%bbentry : L0%0%d : input.dst.llvm-%call.Lfor.body%2%d
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-%1.Lfor.cond%1%bbentry : L0%0%d : input.dst.llvm-mem.Lfor.body%2%d[(input.dst.llvm-%arr.Lfor.body%2%d + 4*input.dst.llvm-%i.0.Lfor.body%2%d)]_4
input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : L0%0%d : bvmul(4, input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : L0%0%d : (input.dst.llvm-%arr.Lfor.body%2%d + 4*input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : L0%0%d : input.dst.llvm-%call.Lfor.body%2%d
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : L0%0%d : input.dst.llvm-%call.Lfor.body%2%d
input.dst.llvm-%inc.Lfor.cond%1%bbentry : L0%0%d : (1 + input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%next.Lfor.cond%1%bbentry : L0%0%d : (4 + input.dst.llvm-%call.Lfor.body%2%d)
input.dst.llvm-%val.Lfor.cond%1%bbentry : L0%0%d : input.dst.llvm-%call.Lfor.body%2%d
input.dst.cur_rounding_mode.Lfor.cond%1%bbentry : L0%0%d : ROUND_to_nearest_ties_to_even
=InputLLVMToSourceVarnames done
=PotentialSCEVRelations:
=dst.llvm-%i.0
=dst.llvm-%i.0 loop pc: Lfor.cond%1%d
=dst.llvm-%i.0 val_scevb
=dst.llvm-%i.0 val_scevb scev
=dst.llvm-%i.0 val_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%i.0 val_scevb scev scev_overflow_flag: 
=dst.llvm-%i.0 val_scevb scev scev_expr
1 : 00000000000000000000000000000000b
2 : 00000000000000000000000000000001b
3 : scev_op_addrec(1, 2) : loop Lfor.cond%1%d : 
=dst.llvm-%i.0 val_scevb scev scev_expr done
=dst.llvm-%i.0 val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%i.0 val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%i.0 val_scevb signed lower bound: 32:4294967295
=dst.llvm-%i.0 val_scevb signed upper bound: 32:4294967295
=dst.llvm-%i.0 atuse_scevb
=dst.llvm-%i.0 atuse_scevb scev
=dst.llvm-%i.0 atuse_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%i.0 atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%i.0 atuse_scevb scev scev_expr
1 : 00000000000000000000000000000000b
2 : 00000000000000000000000000000001b
3 : scev_op_addrec(1, 2) : loop Lfor.cond%1%d : 
=dst.llvm-%i.0 atuse_scevb scev scev_expr done
=dst.llvm-%i.0 atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%i.0 atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%i.0 atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%i.0 atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%i.0 atexit_scev
=dst.llvm-%i.0 atexit_scev loop: L0%0%d
=dst.llvm-%i.0 atexit_scev scev_overflow_flag: 
=dst.llvm-%i.0 atexit_scev scev_expr
4 : input.dst.llvm-%n : BV32
=dst.llvm-%i.0 atexit_scev scev_expr done
=dst.llvm-%l.0
=dst.llvm-%l.0 loop pc: Lfor.cond%1%d
=dst.llvm-%l.0 val_scevb
=dst.llvm-%l.0 val_scevb scev
=dst.llvm-%l.0 val_scevb scev loop: L0%0%d
=dst.llvm-%l.0 val_scevb scev scev_overflow_flag: 
=dst.llvm-%l.0 val_scevb scev scev_expr
5 : input.dst.llvm-%l.0 : BV32
=dst.llvm-%l.0 val_scevb scev scev_expr done
=dst.llvm-%l.0 val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%l.0 val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%l.0 val_scevb signed lower bound: 32:4294967295
=dst.llvm-%l.0 val_scevb signed upper bound: 32:4294967295
=dst.llvm-%l.0 atuse_scevb
=dst.llvm-%l.0 atuse_scevb scev
=dst.llvm-%l.0 atuse_scevb scev loop: L0%0%d
=dst.llvm-%l.0 atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%l.0 atuse_scevb scev scev_expr
5 : input.dst.llvm-%l.0 : BV32
=dst.llvm-%l.0 atuse_scevb scev scev_expr done
=dst.llvm-%l.0 atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%l.0 atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%l.0 atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%l.0 atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%l.0 atexit_scev
=dst.llvm-%l.0 atexit_scev loop: L0%0%d
=dst.llvm-%l.0 atexit_scev scev_overflow_flag: 
=dst.llvm-%l.0 atexit_scev scev_expr
5 : input.dst.llvm-%l.0 : BV32
=dst.llvm-%l.0 atexit_scev scev_expr done
=dst.llvm-%call
=dst.llvm-%call loop pc: Lfor.cond%1%d
=dst.llvm-%call val_scevb
=dst.llvm-%call val_scevb scev
=dst.llvm-%call val_scevb scev loop: L0%0%d
=dst.llvm-%call val_scevb scev scev_overflow_flag: 
=dst.llvm-%call val_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%call val_scevb scev scev_expr done
=dst.llvm-%call val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%call val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%call val_scevb signed lower bound: 32:4294967295
=dst.llvm-%call val_scevb signed upper bound: 32:4294967295
=dst.llvm-%call atuse_scevb
=dst.llvm-%call atuse_scevb scev
=dst.llvm-%call atuse_scevb scev loop: L0%0%d
=dst.llvm-%call atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%call atuse_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%call atuse_scevb scev scev_expr done
=dst.llvm-%call atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%call atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%call atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%call atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%call atexit_scev
=dst.llvm-%call atexit_scev loop: L0%0%d
=dst.llvm-%call atexit_scev scev_overflow_flag: 
=dst.llvm-%call atexit_scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%call atexit_scev scev_expr done
=dst.llvm-%0
=dst.llvm-%0 loop pc: Lfor.cond%1%d
=dst.llvm-%0 val_scevb
=dst.llvm-%0 val_scevb scev
=dst.llvm-%0 val_scevb scev loop: L0%0%d
=dst.llvm-%0 val_scevb scev scev_overflow_flag: 
=dst.llvm-%0 val_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%0 val_scevb scev scev_expr done
=dst.llvm-%0 val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%0 val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%0 val_scevb signed lower bound: 32:4294967295
=dst.llvm-%0 val_scevb signed upper bound: 32:4294967295
=dst.llvm-%0 atuse_scevb
=dst.llvm-%0 atuse_scevb scev
=dst.llvm-%0 atuse_scevb scev loop: L0%0%d
=dst.llvm-%0 atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%0 atuse_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%0 atuse_scevb scev scev_expr done
=dst.llvm-%0 atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%0 atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%0 atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%0 atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%0 atexit_scev
=dst.llvm-%0 atexit_scev loop: L0%0%d
=dst.llvm-%0 atexit_scev scev_overflow_flag: 
=dst.llvm-%0 atexit_scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%0 atexit_scev scev_expr done
=dst.llvm-%arrayidx
=dst.llvm-%arrayidx loop pc: Lfor.cond%1%d
=dst.llvm-%arrayidx val_scevb
=dst.llvm-%arrayidx val_scevb scev
=dst.llvm-%arrayidx val_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%arrayidx val_scevb scev scev_overflow_flag: 
=dst.llvm-%arrayidx val_scevb scev scev_expr
7 : input.dst.llvm-%arr : BV32
8 : 00000000000000000000000000000100b
9 : scev_op_addrec(7, 8) : loop Lfor.cond%1%d : 
=dst.llvm-%arrayidx val_scevb scev scev_expr done
=dst.llvm-%arrayidx val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%arrayidx val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%arrayidx val_scevb signed lower bound: 32:4294967295
=dst.llvm-%arrayidx val_scevb signed upper bound: 32:4294967295
=dst.llvm-%arrayidx atuse_scevb
=dst.llvm-%arrayidx atuse_scevb scev
=dst.llvm-%arrayidx atuse_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%arrayidx atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%arrayidx atuse_scevb scev scev_expr
7 : input.dst.llvm-%arr : BV32
8 : 00000000000000000000000000000100b
9 : scev_op_addrec(7, 8) : loop Lfor.cond%1%d : 
=dst.llvm-%arrayidx atuse_scevb scev scev_expr done
=dst.llvm-%arrayidx atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%arrayidx atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%arrayidx atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%arrayidx atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%arrayidx atexit_scev
=dst.llvm-%arrayidx atexit_scev loop: L0%0%d
=dst.llvm-%arrayidx atexit_scev scev_overflow_flag: 
=dst.llvm-%arrayidx atexit_scev scev_expr
8 : 00000000000000000000000000000100b
4 : input.dst.llvm-%n : BV32
10 : scev_op_mul(8, 4) : loop L0%0%d : 
7 : input.dst.llvm-%arr : BV32
11 : scev_op_add(10, 7) : loop L0%0%d : 
=dst.llvm-%arrayidx atexit_scev scev_expr done
=dst.llvm-%1
=dst.llvm-%1 loop pc: Lfor.cond%1%d
=dst.llvm-%1 val_scevb
=dst.llvm-%1 val_scevb scev
=dst.llvm-%1 val_scevb scev loop: L0%0%d
=dst.llvm-%1 val_scevb scev scev_overflow_flag: 
=dst.llvm-%1 val_scevb scev scev_expr
12 : input.dst.llvm-%1 : BV32
=dst.llvm-%1 val_scevb scev scev_expr done
=dst.llvm-%1 val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%1 val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%1 val_scevb signed lower bound: 32:4294967295
=dst.llvm-%1 val_scevb signed upper bound: 32:4294967295
=dst.llvm-%1 atuse_scevb
=dst.llvm-%1 atuse_scevb scev
=dst.llvm-%1 atuse_scevb scev loop: L0%0%d
=dst.llvm-%1 atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%1 atuse_scevb scev scev_expr
12 : input.dst.llvm-%1 : BV32
=dst.llvm-%1 atuse_scevb scev scev_expr done
=dst.llvm-%1 atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%1 atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%1 atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%1 atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%1 atexit_scev
=dst.llvm-%1 atexit_scev loop: L0%0%d
=dst.llvm-%1 atexit_scev scev_overflow_flag: 
=dst.llvm-%1 atexit_scev scev_expr
12 : input.dst.llvm-%1 : BV32
=dst.llvm-%1 atexit_scev scev_expr done
=dst.llvm-%val
=dst.llvm-%val loop pc: Lfor.cond%1%d
=dst.llvm-%val val_scevb
=dst.llvm-%val val_scevb scev
=dst.llvm-%val val_scevb scev loop: L0%0%d
=dst.llvm-%val val_scevb scev scev_overflow_flag: 
=dst.llvm-%val val_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%val val_scevb scev scev_expr done
=dst.llvm-%val val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%val val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%val val_scevb signed lower bound: 32:4294967295
=dst.llvm-%val val_scevb signed upper bound: 32:4294967295
=dst.llvm-%val atuse_scevb
=dst.llvm-%val atuse_scevb scev
=dst.llvm-%val atuse_scevb scev loop: L0%0%d
=dst.llvm-%val atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%val atuse_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%val atuse_scevb scev scev_expr done
=dst.llvm-%val atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%val atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%val atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%val atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%val atexit_scev
=dst.llvm-%val atexit_scev loop: L0%0%d
=dst.llvm-%val atexit_scev scev_overflow_flag: 
=dst.llvm-%val atexit_scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%val atexit_scev scev_expr done
=dst.llvm-%next
=dst.llvm-%next loop pc: Lfor.cond%1%d
=dst.llvm-%next val_scevb
=dst.llvm-%next val_scevb scev
=dst.llvm-%next val_scevb scev loop: L0%0%d
=dst.llvm-%next val_scevb scev scev_overflow_flag: nsw
=dst.llvm-%next val_scevb scev scev_expr
8 : 00000000000000000000000000000100b
6 : input.dst.llvm-%call : BV32
13 : scev_op_add(8, 6) : loop L0%0%d : nsw
=dst.llvm-%next val_scevb scev scev_expr done
=dst.llvm-%next val_scevb unsigned lower bound: 32:2147483652
=dst.llvm-%next val_scevb unsigned upper bound: 32:2147483648
=dst.llvm-%next val_scevb signed lower bound: 32:2147483652
=dst.llvm-%next val_scevb signed upper bound: 32:2147483648
=dst.llvm-%next atuse_scevb
=dst.llvm-%next atuse_scevb scev
=dst.llvm-%next atuse_scevb scev loop: L0%0%d
=dst.llvm-%next atuse_scevb scev scev_overflow_flag: nsw
=dst.llvm-%next atuse_scevb scev scev_expr
8 : 00000000000000000000000000000100b
6 : input.dst.llvm-%call : BV32
13 : scev_op_add(8, 6) : loop L0%0%d : nsw
=dst.llvm-%next atuse_scevb scev scev_expr done
=dst.llvm-%next atuse_scevb unsigned lower bound: 32:2147483652
=dst.llvm-%next atuse_scevb unsigned upper bound: 32:2147483648
=dst.llvm-%next atuse_scevb signed lower bound: 32:2147483652
=dst.llvm-%next atuse_scevb signed upper bound: 32:2147483648
=dst.llvm-%next atexit_scev
=dst.llvm-%next atexit_scev loop: L0%0%d
=dst.llvm-%next atexit_scev scev_overflow_flag: nsw
=dst.llvm-%next atexit_scev scev_expr
8 : 00000000000000000000000000000100b
6 : input.dst.llvm-%call : BV32
13 : scev_op_add(8, 6) : loop L0%0%d : nsw
=dst.llvm-%next atexit_scev scev_expr done
=dst.llvm-%inc
=dst.llvm-%inc loop pc: Lfor.cond%1%d
=dst.llvm-%inc val_scevb
=dst.llvm-%inc val_scevb scev
=dst.llvm-%inc val_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%inc val_scevb scev scev_overflow_flag: 
=dst.llvm-%inc val_scevb scev scev_expr
2 : 00000000000000000000000000000001b
14 : scev_op_addrec(2, 2) : loop Lfor.cond%1%d : 
=dst.llvm-%inc val_scevb scev scev_expr done
=dst.llvm-%inc val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%inc val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%inc val_scevb signed lower bound: 32:4294967295
=dst.llvm-%inc val_scevb signed upper bound: 32:4294967295
=dst.llvm-%inc atuse_scevb
=dst.llvm-%inc atuse_scevb scev
=dst.llvm-%inc atuse_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%inc atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%inc atuse_scevb scev scev_expr
2 : 00000000000000000000000000000001b
14 : scev_op_addrec(2, 2) : loop Lfor.cond%1%d : 
=dst.llvm-%inc atuse_scevb scev scev_expr done
=dst.llvm-%inc atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%inc atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%inc atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%inc atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%inc atexit_scev
=dst.llvm-%inc atexit_scev loop: L0%0%d
=dst.llvm-%inc atexit_scev scev_overflow_flag: 
=dst.llvm-%inc atexit_scev scev_expr
2 : 00000000000000000000000000000001b
4 : input.dst.llvm-%n : BV32
15 : scev_op_add(2, 4) : loop L0%0%d : 
=dst.llvm-%inc atexit_scev scev_expr done
=PotentialSCEVRelations done
=ReachingDefinitionsForLocs:
=Reaching Definitions at L0%0%d
=reaching defns for expr 0
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 1 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 2 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 3 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 4 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 5 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 8 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 8 edges done
=reaching defns done
=Reaching Definitions at Lfor.body%1%intermediateVal1
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 4 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 5 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 8 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 9 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 11 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 12 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 13 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 14 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 15 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 16 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.body%1%fcallStart
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 4 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 5 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 8 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 9 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 11 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 12 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 13 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 14 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 15 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 16 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.body%1%fcallEnd
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 4 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 5 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 8 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 9 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 11 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 12 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 13 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 14 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 15 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 16 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.body%2%d
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 4 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 5 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 8 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 9 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 11 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 12 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 13 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 14 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 15 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 16 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.cond%1%bbentry
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 4 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 5 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 8 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 9 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 11 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 12 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 13 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 14 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 15 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 16 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.cond%2%d
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 4 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 5 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 8 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 9 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 11 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 12 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 13 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 14 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 15 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 16 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.end%1%d
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 4 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 5 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 8 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 9 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 11 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 12 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 13 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 14 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 15 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 16 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at E0%0%d
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 4 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 5 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 8 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 9 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 11 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 12 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 13 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 14 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 15 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 16 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%hidden-reg.E0%0%d : BV:32
=reaching defns for expr 27 edges
  Lfor.end%1%d=>E0%0%d
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%ret-reg.E0%0%d : BV:32
=reaching defns for expr 28 edges
  Lfor.end%1%d=>E0%0%d
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-indir_tgt.E0%0%d : BV:32
=reaching defns for expr 29 edges
  Lfor.end%1%d=>E0%0%d
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns for expr 48
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 48 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 48 edges done
=reaching defns for expr 49
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 49 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 49 edges done
=reaching defns for expr 50
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 50 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 50 edges done
=reaching defns done
=ReachingDefinitionsForLocs done
=VarnameToLRStatus Begin:
=LR status for var input.dst.llvm-%arr.Lfor.cond%1%bbentry
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%n
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=LR status for var input.dst.llvm-%arr
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
lr_status_top
=LR status for var input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
lr_status_top
=LR status for var input.dst.local_alloc_count.=L0%0%d=
lr_status_top
=LR status for var input.dst.llvm-%n.Lfor.cond%1%bbentry
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=LR status for var input.dst.llvm-%hidden-reg
lr_status_top
=LR status for var input.dst.llvm-callee-save.0
lr_status_top
=LR status for var input.dst.llvm-callee-save.1
lr_status_top
=LR status for var input.dst.llvm-callee-save.2
lr_status_top
=LR status for var input.dst.llvm-callee-save.3
lr_status_top
=LR status for var input.dst.llvm-%call.Lfor.body%1%fcallEnd
lr_status_bottom(; )
=LR status for var input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%cmp.Lfor.cond%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.local_alloc_count.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%i.0.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%l.0.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%n.Lfor.body%2%d
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=LR status for var input.dst.llvm-%arr.Lfor.body%2%d
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%i.0.Lfor.body%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%l.0.Lfor.body%2%d
lr_status_linearly_related(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.local_alloc_count.Lfor.body%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%call.Lfor.body%2%d
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-indir_tgt.E0%0%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%ret-reg.E0%0%d
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%hidden-reg.E0%0%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%0.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%1.Lfor.cond%1%bbentry
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%inc.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%next.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%val.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=VarnameToLRStatus End
=TFG_LLVM_done
=TFG_SSA_done
=eqcheck_info
=eqcheck
=proof_filename ind9.proof
=function_name make_list
=asm_filename NONE
=fixed_reg_mappings begin
0 : 0 : 0
0 : 4 : 4
=fixed_reg_mappings end
=rodata_map begin
=rodata_map end
=dst_iseq
=dst_iseq done
=dst_insn_pcs
=dst_insn_pcs done
=xml_output_format text-color
=use_only_relocatable_memlabels 0
=run_safety_check 0
=debug_header_pc_lsprels
=Local offsets from compile log
=Local offsets from compile log done
=done
=spec_iospecs
=SpecFuncIOSpecs
=FunctionName: make_list
=EntryPreconds
=pred 0
=Comment
pointer-implements-map
=LhsExpr
1 : $spec-arg-0 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : $llvm-arg-1 : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : $llvm-md : ARRAY[BV:32 -> BV:8]
11 : $llvm-ma : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : $llvm-arg-0 : BV:32
14 : 4 { 0x4 +1.47e129 } : BV:32
15 : bvmul(9, 14) : BV:32
16 : bvadd(13, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=predicate_set done
=EntryPreconds done
=ExitAsserts
=pred 0
=Comment
ret-pointer-implements-inductive-list
=LhsExpr
1 : $spec-ret : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : $llvm-ret : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : $llvm-md : ARRAY[BV:32 -> BV:8]
6 : $llvm-ma : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(14, 15) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=predicate_set done
=ExitAsserts done
=SpecFuncIOSpecs done
=eqcheck done
=graph_with_guessing
=Nodes: L0%0%d_L0%0%d L3%6%bbentry_Lfor.body%1%fcallStart L3%6%bbentry_Lfor.body%1%fcallEnd L3%6%bbentry_Lfor.cond%1%bbentry E0%0%d_E0%0%d
=Edges:
L0%0%d_L0%0%d => L3%6%bbentry_Lfor.cond%1%bbentry
L3%6%bbentry_Lfor.cond%1%bbentry => E0%0%d_E0%0%d
L3%6%bbentry_Lfor.cond%1%bbentry => L3%6%bbentry_Lfor.body%1%fcallStart
L3%6%bbentry_Lfor.body%1%fcallStart => L3%6%bbentry_Lfor.body%1%fcallEnd
L3%6%bbentry_Lfor.body%1%fcallEnd => L3%6%bbentry_Lfor.cond%1%bbentry
=graph done
=is_ssa_graph:
0
=StartState:
=state_end
=graph_with_var_versions done
=FunctionName: make_list
=Input: tfg-method-arg.0
=arg addr
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
=arg val
1 : input.dst.llvm-%arr : BV:32
=arg end
=Input: tfg-method-arg.1
=arg addr
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
=arg val
1 : input.dst.llvm-%n : BV:32
=arg end
=Node outputs: E0%0%d_E0%0%d
=Node outputs done for E0%0%d_E0%0%d
=input_outputs done
=Symbol-map:
C_SYMBOL1 : make_list : 26 : 1 : 0
=Touched symbols:
=Symbol-map done
=Locals-map:
C_LOCAL=L0%0%argnum0= : dst.llvm-%arr : 4 : 4 : 0
C_LOCAL=L0%0%argnum1= : dst.llvm-%n : 4 : 4 : 0
=Locals-map done
=Global assumes
=global assume predicate_set done
=Edge: L0%0%d_L0%0%d => L3%6%bbentry_Lfor.cond%1%bbentry
=Edge.src_tfg_full_pathset
=Edge.src_tfg_full_pathset.ec from L0%0%d to L3%6%bbentry at unroll 1 delta {1,0}
=Edge.src_tfg_full_pathset.graph_edge_composition
(L0%0%d#{0,0}=>L3%6%bbentry#{0,0})
=Edge.src_tfg_full_pathset done
=Edge.dst_tfg_full_pathset
=Edge.dst_tfg_full_pathset.ec from L0%0%d to Lfor.cond%1%bbentry at unroll 1 delta {1,0}
=Edge.dst_tfg_full_pathset.graph_edge_composition
(L0%0%d#{0,0}=>Lfor.cond%1%bbentry#{0,0})
=Edge.dst_tfg_full_pathset done
=Edge.cg_edge_assumes.Assumes.begin:
=Edge.cg_edge_assumes.Assumes.end

=Edge: L3%6%bbentry_Lfor.cond%1%bbentry => E0%0%d_E0%0%d
=Edge.src_tfg_full_pathset
=Edge.src_tfg_full_pathset.ec from L3%6%bbentry to E0%0%d at unroll 1 delta {1,0}
=Edge.src_tfg_full_pathset.graph_edge_composition
((L3%6%bbentry#{0,0}=>L3%7%d#{0,0})*((L3%7%d#{0,0}=>L3%8%bbentry#{0,0})*(L3%8%bbentry#{0,0}=>E0%0%d#{0,0})))
=Edge.src_tfg_full_pathset done
=Edge.dst_tfg_full_pathset
=Edge.dst_tfg_full_pathset.ec from Lfor.cond%1%bbentry to E0%0%d at unroll 1 delta {1,0}
=Edge.dst_tfg_full_pathset.graph_edge_composition
((Lfor.cond%1%bbentry#{0,0}=>Lfor.cond%2%d#{0,0})*((Lfor.cond%2%d#{0,0}=>Lfor.end%1%d#{0,0})*(Lfor.end%1%d#{0,0}=>E0%0%d#{0,0})))
=Edge.dst_tfg_full_pathset done
=Edge.cg_edge_assumes.Assumes.begin:
=Edge.cg_edge_assumes.Assumes.end

=Edge: L3%6%bbentry_Lfor.cond%1%bbentry => L3%6%bbentry_Lfor.body%1%fcallStart
=Edge.src_tfg_full_pathset
=Edge.src_tfg_full_pathset.ec from L3%6%bbentry to L3%6%bbentry at unroll 0 delta {0,0}
=Edge.src_tfg_full_pathset.graph_edge_composition
(epsilon)
=Edge.src_tfg_full_pathset done
=Edge.dst_tfg_full_pathset
=Edge.dst_tfg_full_pathset.ec from Lfor.cond%1%bbentry to Lfor.body%1%fcallStart at unroll 1 delta {1,0}
=Edge.dst_tfg_full_pathset.graph_edge_composition
((Lfor.cond%1%bbentry#{0,0}=>Lfor.cond%2%d#{0,0})*(Lfor.cond%2%d#{0,0}=>Lfor.body%1%fcallStart#{0,0}))
=Edge.dst_tfg_full_pathset done
=Edge.cg_edge_assumes.Assumes.begin:
=Edge.cg_edge_assumes.Assumes.end

=Edge: L3%6%bbentry_Lfor.body%1%fcallStart => L3%6%bbentry_Lfor.body%1%fcallEnd
=Edge.src_tfg_full_pathset
=Edge.src_tfg_full_pathset.ec from L3%6%bbentry to L3%6%bbentry at unroll 0 delta {0,0}
=Edge.src_tfg_full_pathset.graph_edge_composition
(epsilon)
=Edge.src_tfg_full_pathset done
=Edge.dst_tfg_full_pathset
=Edge.dst_tfg_full_pathset.ec from Lfor.body%1%fcallStart to Lfor.body%1%fcallEnd at unroll 1 delta {1,0}
=Edge.dst_tfg_full_pathset.graph_edge_composition
(Lfor.body%1%fcallStart#{0,0}=>Lfor.body%1%fcallEnd#{0,0})
=Edge.dst_tfg_full_pathset done
=Edge.cg_edge_assumes.Assumes.begin:
=Edge.cg_edge_assumes.Assumes.end

=Edge: L3%6%bbentry_Lfor.body%1%fcallEnd => L3%6%bbentry_Lfor.cond%1%bbentry
=Edge.src_tfg_full_pathset
=Edge.src_tfg_full_pathset.ec from L3%6%bbentry to L3%6%bbentry at unroll 1 delta {1,0}
=Edge.src_tfg_full_pathset.graph_edge_composition
((L3%6%bbentry#{0,0}=>L3%7%d#{0,0})*((L3%7%d#{0,0}=>L3%10%bbentry#{0,0})*(L3%10%bbentry#{0,0}=>L3%6%bbentry#{1,0})))
=Edge.src_tfg_full_pathset done
=Edge.dst_tfg_full_pathset
=Edge.dst_tfg_full_pathset.ec from Lfor.body%1%fcallEnd to Lfor.cond%1%bbentry at unroll 1 delta {1,0}
=Edge.dst_tfg_full_pathset.graph_edge_composition
((Lfor.body%1%fcallEnd#{0,0}=>Lfor.body%1%intermediateVal1#{0,0})*((Lfor.body%1%intermediateVal1#{0,0}=>Lfor.body%2%d#{0,0})*(Lfor.body%2%d#{0,0}=>Lfor.cond%1%bbentry#{0,0})))
=Edge.dst_tfg_full_pathset done
=Edge.cg_edge_assumes.Assumes.begin:
=Edge.cg_edge_assumes.Assumes.end

=graph_with_predicates_done

=start_pc_preconditions
=start_pc_precondition.0
=Comment
precond-mlasserts
=LhsExpr
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=start_pc_precondition.1
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
5 : 4 { 0x4 +1.0e1025 } : INT
6 : 0 { 0x0 } : BOOL
7 : select(1, 2, 3, 4, 5, 6) : BV:32
=RhsExpr
1 : input.dst.llvm-%n : BV:32
=predicate done
=start_pc_precondition.2
=Comment
pointer-implements-map
=LhsExpr
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=start_pc_precondition.3
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
5 : 4 { 0x4 +1.0e1025 } : INT
6 : 0 { 0x0 } : BOOL
7 : select(1, 2, 3, 4, 5, 6) : BV:32
=RhsExpr
1 : input.dst.llvm-%arr : BV:32
=predicate done
=graph_with_precondition_done

=Locs in make_list.A2.B1.C1.D1.E2
=Locs end
=Liveness in make_list.A2.B1.C1.D1.E2
=live locs at L0%0%d_L0%0%d

=live locs at L3%6%bbentry_Lfor.body%1%fcallStart

=live locs at L3%6%bbentry_Lfor.body%1%fcallEnd

=live locs at L3%6%bbentry_Lfor.cond%1%bbentry

=live locs at E0%0%d_E0%0%d


=Definedness in make_list.A2.B1.C1.D1.E2

=Branch affecting variable locs in make_list.A2.B1.C1.D1.E2

=Relevant Memlabels in make_list.A2.B1.C1.D1.E2
=relevant memlabels
=function: make_list
memlabel-mem--arg.0
memlabel-mem-may-straddle-symbol.1-heap
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
memlabel-mem--arg.1
=touched symbol ids

=relevant memlabels done
=graph_with_locs_done
=graph_with_edge_structures
=graph_with_edge_structures.loc_to_expr_map done
=graph_with_edge_structures done
=graph_with_ml_contiguity_info vacuous mls
=graph_with_ml_contiguity_info non-vacuous mls
=graph_with_ml_contiguity_info discontiguous mls
discontiguous mls:
=graph_with_ml_contiguity_info done
=Available expressions in make_list.A2.B1.C1.D1.E2
=avail_exprs begin
=avail_exprs end
=sprel_map in make_list.A2.B1.C1.D1.E2
=sprel_map done
=lr-status-map
=lr-status-map done
=lr-status-for-sprel-locs-map
=lr-status-for-sprel-locs-map done
=graph_with_aliasing_done
=Memlabel assertions empty
=Memlabel assertions done
=graph_with_proofs done
=global counterexamples for reason inductive-invariants
=global nodece 0
=global nodece 0 nodece z3v487.ce5.num_edges_traversed0
=global nodece 0 nodece_path
=global nodece 0 nodece_path.graph_edge_composition
(epsilon)
=global nodece 0 nodece_cached_counterexample
=counter_example_begin z3v487.ce5 3ff61d309e59bf6a1c2d35611a5ff
=input.spec-%var-arr-1
1 : Lambda89 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 67372035 { 0x4040403 +1.3137242e137 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 67372036 { 0x4040404 +1.3137254e137 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda90 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : 84215045 { 0x5050505 +1.3921568e139 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : bvule(2, 22) : BOOL
24 : 639 { 0x27f +1.7617e129 } : BV:32
25 : bvule(22, 24) : BOOL
26 : and(23, 25) : BOOL
27 : 1 { 0x1 } : BV:8
28 : 640 { 0x280 +1.7629e129 } : BV:32
29 : bvule(28, 22) : BOOL
30 : 643 { 0x283 +1.7665e129 } : BV:32
31 : bvule(22, 30) : BOOL
32 : and(29, 31) : BOOL
33 : 4 { 0x4 } : BV:8
34 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
35 : bvule(34, 22) : BOOL
36 : 556557207 { 0x212c6397 +1.34678924e195 } : BV:32
37 : bvule(22, 36) : BOOL
38 : and(35, 37) : BOOL
39 : 5 { 0x5 } : BV:8
40 : 556557208 { 0x212c6398 +1.34678936e195 } : BV:32
41 : bvule(40, 22) : BOOL
42 : bvule(22, 10) : BOOL
43 : and(41, 42) : BOOL
44 : 0 { 0x0 } : BV:8
45 : 644 { 0x284 +1.7677e129 } : BV:32
46 : bvule(45, 22) : BOOL
47 : 556557203 { 0x212c6393 +1.34678876e195 } : BV:32
48 : bvule(22, 47) : BOOL
49 : and(46, 48) : BOOL
50 : ite(49, 44, 44) : BV:8
51 : ite(43, 44, 50) : BV:8
52 : ite(38, 39, 51) : BV:8
53 : ite(32, 33, 52) : BV:8
54 : ite(26, 27, 53) : BV:8
55 : 2 { 0x2 +1.23e129 } : BV:32
56 : bvadd(55, 20, 21) : BV:32
57 : bvule(2, 56) : BOOL
58 : bvule(56, 24) : BOOL
59 : and(57, 58) : BOOL
60 : bvule(28, 56) : BOOL
61 : bvule(56, 30) : BOOL
62 : and(60, 61) : BOOL
63 : bvule(34, 56) : BOOL
64 : bvule(56, 36) : BOOL
65 : and(63, 64) : BOOL
66 : bvule(40, 56) : BOOL
67 : bvule(56, 10) : BOOL
68 : and(66, 67) : BOOL
69 : bvule(45, 56) : BOOL
70 : bvule(56, 47) : BOOL
71 : and(69, 70) : BOOL
72 : ite(71, 44, 44) : BV:8
73 : ite(68, 44, 72) : BV:8
74 : ite(65, 39, 73) : BV:8
75 : ite(62, 33, 74) : BV:8
76 : ite(59, 27, 75) : BV:8
77 : 1 { 0x1 +1.11e129 } : BV:32
78 : bvadd(77, 20, 21) : BV:32
79 : bvule(2, 78) : BOOL
80 : bvule(78, 24) : BOOL
81 : and(79, 80) : BOOL
82 : bvule(28, 78) : BOOL
83 : bvule(78, 30) : BOOL
84 : and(82, 83) : BOOL
85 : bvule(34, 78) : BOOL
86 : bvule(78, 36) : BOOL
87 : and(85, 86) : BOOL
88 : bvule(40, 78) : BOOL
89 : bvule(78, 10) : BOOL
90 : and(88, 89) : BOOL
91 : bvule(45, 78) : BOOL
92 : bvule(78, 47) : BOOL
93 : and(91, 92) : BOOL
94 : ite(93, 44, 44) : BV:8
95 : ite(90, 44, 94) : BV:8
96 : ite(87, 39, 95) : BV:8
97 : ite(84, 33, 96) : BV:8
98 : ite(81, 27, 97) : BV:8
99 : bvadd(20, 21) : BV:32
100 : bvule(2, 99) : BOOL
101 : bvule(99, 24) : BOOL
102 : and(100, 101) : BOOL
103 : bvule(28, 99) : BOOL
104 : bvule(99, 30) : BOOL
105 : and(103, 104) : BOOL
106 : bvule(34, 99) : BOOL
107 : bvule(99, 36) : BOOL
108 : and(106, 107) : BOOL
109 : bvule(40, 99) : BOOL
110 : bvule(99, 10) : BOOL
111 : and(109, 110) : BOOL
112 : bvule(45, 99) : BOOL
113 : bvule(99, 47) : BOOL
114 : and(112, 113) : BOOL
115 : ite(114, 44, 44) : BV:8
116 : ite(111, 44, 115) : BV:8
117 : ite(108, 39, 116) : BV:8
118 : ite(105, 33, 117) : BV:8
119 : ite(102, 27, 118) : BV:8
120 : bvconcat(54, 76, 98, 119) : BV:32
121 : lambda(17, 120) : FUNCTION[BV:32 -> BV:32]
122 : map(16, 121) : MAP[BV:32 -> BV:32]
123 : sym_const(122) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda92 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 67372035 { 0x4040403 +1.3137242e137 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 67372036 { 0x4040404 +1.3137254e137 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda93 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : 84215045 { 0x5050505 +1.3921568e139 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : bvule(2, 22) : BOOL
24 : 639 { 0x27f +1.7617e129 } : BV:32
25 : bvule(22, 24) : BOOL
26 : and(23, 25) : BOOL
27 : 1 { 0x1 } : BV:8
28 : 640 { 0x280 +1.7629e129 } : BV:32
29 : bvule(28, 22) : BOOL
30 : 643 { 0x283 +1.7665e129 } : BV:32
31 : bvule(22, 30) : BOOL
32 : and(29, 31) : BOOL
33 : 4 { 0x4 } : BV:8
34 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
35 : bvule(34, 22) : BOOL
36 : 556557207 { 0x212c6397 +1.34678924e195 } : BV:32
37 : bvule(22, 36) : BOOL
38 : and(35, 37) : BOOL
39 : 5 { 0x5 } : BV:8
40 : 556557208 { 0x212c6398 +1.34678936e195 } : BV:32
41 : bvule(40, 22) : BOOL
42 : bvule(22, 10) : BOOL
43 : and(41, 42) : BOOL
44 : 0 { 0x0 } : BV:8
45 : 644 { 0x284 +1.7677e129 } : BV:32
46 : bvule(45, 22) : BOOL
47 : 556557203 { 0x212c6393 +1.34678876e195 } : BV:32
48 : bvule(22, 47) : BOOL
49 : and(46, 48) : BOOL
50 : ite(49, 44, 44) : BV:8
51 : ite(43, 44, 50) : BV:8
52 : ite(38, 39, 51) : BV:8
53 : ite(32, 33, 52) : BV:8
54 : ite(26, 27, 53) : BV:8
55 : 2 { 0x2 +1.23e129 } : BV:32
56 : bvadd(55, 20, 21) : BV:32
57 : bvule(2, 56) : BOOL
58 : bvule(56, 24) : BOOL
59 : and(57, 58) : BOOL
60 : bvule(28, 56) : BOOL
61 : bvule(56, 30) : BOOL
62 : and(60, 61) : BOOL
63 : bvule(34, 56) : BOOL
64 : bvule(56, 36) : BOOL
65 : and(63, 64) : BOOL
66 : bvule(40, 56) : BOOL
67 : bvule(56, 10) : BOOL
68 : and(66, 67) : BOOL
69 : bvule(45, 56) : BOOL
70 : bvule(56, 47) : BOOL
71 : and(69, 70) : BOOL
72 : ite(71, 44, 44) : BV:8
73 : ite(68, 44, 72) : BV:8
74 : ite(65, 39, 73) : BV:8
75 : ite(62, 33, 74) : BV:8
76 : ite(59, 27, 75) : BV:8
77 : 1 { 0x1 +1.11e129 } : BV:32
78 : bvadd(77, 20, 21) : BV:32
79 : bvule(2, 78) : BOOL
80 : bvule(78, 24) : BOOL
81 : and(79, 80) : BOOL
82 : bvule(28, 78) : BOOL
83 : bvule(78, 30) : BOOL
84 : and(82, 83) : BOOL
85 : bvule(34, 78) : BOOL
86 : bvule(78, 36) : BOOL
87 : and(85, 86) : BOOL
88 : bvule(40, 78) : BOOL
89 : bvule(78, 10) : BOOL
90 : and(88, 89) : BOOL
91 : bvule(45, 78) : BOOL
92 : bvule(78, 47) : BOOL
93 : and(91, 92) : BOOL
94 : ite(93, 44, 44) : BV:8
95 : ite(90, 44, 94) : BV:8
96 : ite(87, 39, 95) : BV:8
97 : ite(84, 33, 96) : BV:8
98 : ite(81, 27, 97) : BV:8
99 : bvadd(20, 21) : BV:32
100 : bvule(2, 99) : BOOL
101 : bvule(99, 24) : BOOL
102 : and(100, 101) : BOOL
103 : bvule(28, 99) : BOOL
104 : bvule(99, 30) : BOOL
105 : and(103, 104) : BOOL
106 : bvule(34, 99) : BOOL
107 : bvule(99, 36) : BOOL
108 : and(106, 107) : BOOL
109 : bvule(40, 99) : BOOL
110 : bvule(99, 10) : BOOL
111 : and(109, 110) : BOOL
112 : bvule(45, 99) : BOOL
113 : bvule(99, 47) : BOOL
114 : and(112, 113) : BOOL
115 : ite(114, 44, 44) : BV:8
116 : ite(111, 44, 115) : BV:8
117 : ite(108, 39, 116) : BV:8
118 : ite(105, 33, 117) : BV:8
119 : ite(102, 27, 118) : BV:8
120 : bvconcat(54, 76, 98, 119) : BV:32
121 : lambda(17, 120) : FUNCTION[BV:32 -> BV:32]
122 : map(16, 121) : MAP[BV:32 -> BV:32]
123 : sym_const(122) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 67372035 ] -> true, [ 67372036; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda72 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 3 { 0x3 +1.35e129 } : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(4, 1) : BV:32
6 : 84215045 { 0x5050505 +1.3921568e139 } : BV:32
7 : bvadd(3, 5, 6) : BV:32
8 : bvule(2, 7) : BOOL
9 : 639 { 0x27f +1.7617e129 } : BV:32
10 : bvule(7, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 1 { 0x1 } : BV:8
13 : 640 { 0x280 +1.7629e129 } : BV:32
14 : bvule(13, 7) : BOOL
15 : 643 { 0x283 +1.7665e129 } : BV:32
16 : bvule(7, 15) : BOOL
17 : and(14, 16) : BOOL
18 : 4 { 0x4 } : BV:8
19 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
20 : bvule(19, 7) : BOOL
21 : 556557207 { 0x212c6397 +1.34678924e195 } : BV:32
22 : bvule(7, 21) : BOOL
23 : and(20, 22) : BOOL
24 : 5 { 0x5 } : BV:8
25 : 556557208 { 0x212c6398 +1.34678936e195 } : BV:32
26 : bvule(25, 7) : BOOL
27 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
28 : bvule(7, 27) : BOOL
29 : and(26, 28) : BOOL
30 : 0 { 0x0 } : BV:8
31 : 644 { 0x284 +1.7677e129 } : BV:32
32 : bvule(31, 7) : BOOL
33 : 556557203 { 0x212c6393 +1.34678876e195 } : BV:32
34 : bvule(7, 33) : BOOL
35 : and(32, 34) : BOOL
36 : ite(35, 30, 30) : BV:8
37 : ite(29, 30, 36) : BV:8
38 : ite(23, 24, 37) : BV:8
39 : ite(17, 18, 38) : BV:8
40 : ite(11, 12, 39) : BV:8
41 : 2 { 0x2 +1.23e129 } : BV:32
42 : bvadd(41, 5, 6) : BV:32
43 : bvule(2, 42) : BOOL
44 : bvule(42, 9) : BOOL
45 : and(43, 44) : BOOL
46 : bvule(13, 42) : BOOL
47 : bvule(42, 15) : BOOL
48 : and(46, 47) : BOOL
49 : bvule(19, 42) : BOOL
50 : bvule(42, 21) : BOOL
51 : and(49, 50) : BOOL
52 : bvule(25, 42) : BOOL
53 : bvule(42, 27) : BOOL
54 : and(52, 53) : BOOL
55 : bvule(31, 42) : BOOL
56 : bvule(42, 33) : BOOL
57 : and(55, 56) : BOOL
58 : ite(57, 30, 30) : BV:8
59 : ite(54, 30, 58) : BV:8
60 : ite(51, 24, 59) : BV:8
61 : ite(48, 18, 60) : BV:8
62 : ite(45, 12, 61) : BV:8
63 : 1 { 0x1 +1.11e129 } : BV:32
64 : bvadd(63, 5, 6) : BV:32
65 : bvule(2, 64) : BOOL
66 : bvule(64, 9) : BOOL
67 : and(65, 66) : BOOL
68 : bvule(13, 64) : BOOL
69 : bvule(64, 15) : BOOL
70 : and(68, 69) : BOOL
71 : bvule(19, 64) : BOOL
72 : bvule(64, 21) : BOOL
73 : and(71, 72) : BOOL
74 : bvule(25, 64) : BOOL
75 : bvule(64, 27) : BOOL
76 : and(74, 75) : BOOL
77 : bvule(31, 64) : BOOL
78 : bvule(64, 33) : BOOL
79 : and(77, 78) : BOOL
80 : ite(79, 30, 30) : BV:8
81 : ite(76, 30, 80) : BV:8
82 : ite(73, 24, 81) : BV:8
83 : ite(70, 18, 82) : BV:8
84 : ite(67, 12, 83) : BV:8
85 : bvadd(5, 6) : BV:32
86 : bvule(2, 85) : BOOL
87 : bvule(85, 9) : BOOL
88 : and(86, 87) : BOOL
89 : bvule(13, 85) : BOOL
90 : bvule(85, 15) : BOOL
91 : and(89, 90) : BOOL
92 : bvule(19, 85) : BOOL
93 : bvule(85, 21) : BOOL
94 : and(92, 93) : BOOL
95 : bvule(25, 85) : BOOL
96 : bvule(85, 27) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(31, 85) : BOOL
99 : bvule(85, 33) : BOOL
100 : and(98, 99) : BOOL
101 : ite(100, 30, 30) : BV:8
102 : ite(97, 30, 101) : BV:8
103 : ite(94, 24, 102) : BV:8
104 : ite(91, 18, 103) : BV:8
105 : ite(88, 12, 104) : BV:8
106 : bvconcat(40, 62, 84, 105) : BV:32
107 : lambda(1, 106) : FUNCTION[BV:32 -> BV:32]
108 : sym_const(107) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform13 : BV:32
3 : Lambda94 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda95 : BV:32
6 : unit : UNIT
7 : 574694591 { 0x224124bf +1.50893390e197 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 67372035 ] -> true, [ 67372036; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda73 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 3 { 0x3 +1.35e129 } : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(4, 1) : BV:32
6 : 84215045 { 0x5050505 +1.3921568e139 } : BV:32
7 : bvadd(3, 5, 6) : BV:32
8 : bvule(2, 7) : BOOL
9 : 639 { 0x27f +1.7617e129 } : BV:32
10 : bvule(7, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 1 { 0x1 } : BV:8
13 : 640 { 0x280 +1.7629e129 } : BV:32
14 : bvule(13, 7) : BOOL
15 : 643 { 0x283 +1.7665e129 } : BV:32
16 : bvule(7, 15) : BOOL
17 : and(14, 16) : BOOL
18 : 4 { 0x4 } : BV:8
19 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
20 : bvule(19, 7) : BOOL
21 : 556557207 { 0x212c6397 +1.34678924e195 } : BV:32
22 : bvule(7, 21) : BOOL
23 : and(20, 22) : BOOL
24 : 5 { 0x5 } : BV:8
25 : 556557208 { 0x212c6398 +1.34678936e195 } : BV:32
26 : bvule(25, 7) : BOOL
27 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
28 : bvule(7, 27) : BOOL
29 : and(26, 28) : BOOL
30 : 0 { 0x0 } : BV:8
31 : 644 { 0x284 +1.7677e129 } : BV:32
32 : bvule(31, 7) : BOOL
33 : 556557203 { 0x212c6393 +1.34678876e195 } : BV:32
34 : bvule(7, 33) : BOOL
35 : and(32, 34) : BOOL
36 : ite(35, 30, 30) : BV:8
37 : ite(29, 30, 36) : BV:8
38 : ite(23, 24, 37) : BV:8
39 : ite(17, 18, 38) : BV:8
40 : ite(11, 12, 39) : BV:8
41 : 2 { 0x2 +1.23e129 } : BV:32
42 : bvadd(41, 5, 6) : BV:32
43 : bvule(2, 42) : BOOL
44 : bvule(42, 9) : BOOL
45 : and(43, 44) : BOOL
46 : bvule(13, 42) : BOOL
47 : bvule(42, 15) : BOOL
48 : and(46, 47) : BOOL
49 : bvule(19, 42) : BOOL
50 : bvule(42, 21) : BOOL
51 : and(49, 50) : BOOL
52 : bvule(25, 42) : BOOL
53 : bvule(42, 27) : BOOL
54 : and(52, 53) : BOOL
55 : bvule(31, 42) : BOOL
56 : bvule(42, 33) : BOOL
57 : and(55, 56) : BOOL
58 : ite(57, 30, 30) : BV:8
59 : ite(54, 30, 58) : BV:8
60 : ite(51, 24, 59) : BV:8
61 : ite(48, 18, 60) : BV:8
62 : ite(45, 12, 61) : BV:8
63 : 1 { 0x1 +1.11e129 } : BV:32
64 : bvadd(63, 5, 6) : BV:32
65 : bvule(2, 64) : BOOL
66 : bvule(64, 9) : BOOL
67 : and(65, 66) : BOOL
68 : bvule(13, 64) : BOOL
69 : bvule(64, 15) : BOOL
70 : and(68, 69) : BOOL
71 : bvule(19, 64) : BOOL
72 : bvule(64, 21) : BOOL
73 : and(71, 72) : BOOL
74 : bvule(25, 64) : BOOL
75 : bvule(64, 27) : BOOL
76 : and(74, 75) : BOOL
77 : bvule(31, 64) : BOOL
78 : bvule(64, 33) : BOOL
79 : and(77, 78) : BOOL
80 : ite(79, 30, 30) : BV:8
81 : ite(76, 30, 80) : BV:8
82 : ite(73, 24, 81) : BV:8
83 : ite(70, 18, 82) : BV:8
84 : ite(67, 12, 83) : BV:8
85 : bvadd(5, 6) : BV:32
86 : bvule(2, 85) : BOOL
87 : bvule(85, 9) : BOOL
88 : and(86, 87) : BOOL
89 : bvule(13, 85) : BOOL
90 : bvule(85, 15) : BOOL
91 : and(89, 90) : BOOL
92 : bvule(19, 85) : BOOL
93 : bvule(85, 21) : BOOL
94 : and(92, 93) : BOOL
95 : bvule(25, 85) : BOOL
96 : bvule(85, 27) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(31, 85) : BOOL
99 : bvule(85, 33) : BOOL
100 : and(98, 99) : BOOL
101 : ite(100, 30, 30) : BV:8
102 : ite(97, 30, 101) : BV:8
103 : ite(94, 24, 102) : BV:8
104 : ite(91, 18, 103) : BV:8
105 : ite(88, 12, 104) : BV:8
106 : bvconcat(40, 62, 84, 105) : BV:32
107 : lambda(1, 106) : FUNCTION[BV:32 -> BV:32]
108 : sym_const(107) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 67372036 { 0x4040404 +1.3137254e137 } : BV:32
=input.dst.llvm-%arr
1 : 84215045 { 0x5050505 +1.3921568e139 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 639 ] -> 1, [ 640; 643 ] -> 4, [ 644; 556557203 ] -> 0, [ 556557204; 556557207 ] -> 5, [ 556557208; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 639 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 640; 643 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 644; 556557203 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 556557204; 556557207 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 556557208; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 640 { 0x280 +1.7629e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 640 { 0x280 +1.7629e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 643 { 0x283 +1.7665e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 556557207 { 0x212c6397 +1.34678924e195 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
619445555
=counter_example_end
=global nodece 0 num_edges_traversed 0
=global nodece 0 nodece_visted_pcs: 
L0%0%d_L0%0%d
=global nodece 1
=global nodece 1 nodece z3.ce6.num_edges_traversed1
=global nodece 1 nodece_path
=global nodece 1 nodece_path.graph_edge_composition
(L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 1 nodece_cached_counterexample
=counter_example_begin z3.ce6 4b142da6ab75a3d169a76b2d4f6ca840
=input.spec-%var-arr-1
1 : Lambda103 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda104 : BV:32
11 : 3 { 0x3 +1.35e129 } : BV:32
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(12, 10) : BV:32
14 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
15 : bvadd(11, 13, 14) : BV:32
16 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
17 : eq(15, 16) : BOOL
18 : 0 { 0x0 } : BV:8
19 : 1256949363 { 0x4aeb8673 +1.84004056e22 } : BV:32
20 : eq(15, 19) : BOOL
21 : 170 { 0xaa -86 } : BV:8
22 : 1728446693 { 0x670600e5 +1.4690229e79 } : BV:32
23 : eq(15, 22) : BOOL
24 : 1256949361 { 0x4aeb8671 +1.84004032e22 } : BV:32
25 : eq(15, 24) : BOOL
26 : 53 { 0x35 } : BV:8
27 : 1256949362 { 0x4aeb8672 +1.84004044e22 } : BV:32
28 : eq(15, 27) : BOOL
29 : 117 { 0x75 } : BV:8
30 : 1728446694 { 0x670600e6 +1.4690241e79 } : BV:32
31 : eq(15, 30) : BOOL
32 : 1728446695 { 0x670600e7 +1.4690253e79 } : BV:32
33 : eq(15, 32) : BOOL
34 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
35 : eq(15, 34) : BOOL
36 : 244 { 0xf4 -12 } : BV:8
37 : 5 { 0x5 } : BV:8
38 : ite(35, 36, 37) : BV:8
39 : ite(33, 18, 38) : BV:8
40 : ite(31, 18, 39) : BV:8
41 : ite(28, 29, 40) : BV:8
42 : ite(25, 26, 41) : BV:8
43 : ite(23, 18, 42) : BV:8
44 : ite(20, 21, 43) : BV:8
45 : ite(17, 18, 44) : BV:8
46 : 2 { 0x2 +1.23e129 } : BV:32
47 : bvadd(46, 13, 14) : BV:32
48 : eq(47, 16) : BOOL
49 : eq(47, 19) : BOOL
50 : eq(47, 22) : BOOL
51 : eq(47, 24) : BOOL
52 : eq(47, 27) : BOOL
53 : eq(47, 30) : BOOL
54 : eq(47, 32) : BOOL
55 : eq(47, 34) : BOOL
56 : ite(55, 36, 37) : BV:8
57 : ite(54, 18, 56) : BV:8
58 : ite(53, 18, 57) : BV:8
59 : ite(52, 29, 58) : BV:8
60 : ite(51, 26, 59) : BV:8
61 : ite(50, 18, 60) : BV:8
62 : ite(49, 21, 61) : BV:8
63 : ite(48, 18, 62) : BV:8
64 : 1 { 0x1 +1.11e129 } : BV:32
65 : bvadd(64, 13, 14) : BV:32
66 : eq(65, 16) : BOOL
67 : eq(65, 19) : BOOL
68 : eq(65, 22) : BOOL
69 : eq(65, 24) : BOOL
70 : eq(65, 27) : BOOL
71 : eq(65, 30) : BOOL
72 : eq(65, 32) : BOOL
73 : eq(65, 34) : BOOL
74 : ite(73, 36, 37) : BV:8
75 : ite(72, 18, 74) : BV:8
76 : ite(71, 18, 75) : BV:8
77 : ite(70, 29, 76) : BV:8
78 : ite(69, 26, 77) : BV:8
79 : ite(68, 18, 78) : BV:8
80 : ite(67, 21, 79) : BV:8
81 : ite(66, 18, 80) : BV:8
82 : bvadd(13, 14) : BV:32
83 : eq(82, 16) : BOOL
84 : eq(82, 19) : BOOL
85 : eq(82, 22) : BOOL
86 : eq(82, 24) : BOOL
87 : eq(82, 27) : BOOL
88 : eq(82, 30) : BOOL
89 : eq(82, 32) : BOOL
90 : eq(82, 34) : BOOL
91 : ite(90, 36, 37) : BV:8
92 : ite(89, 18, 91) : BV:8
93 : ite(88, 18, 92) : BV:8
94 : ite(87, 29, 93) : BV:8
95 : ite(86, 26, 94) : BV:8
96 : ite(85, 18, 95) : BV:8
97 : ite(84, 21, 96) : BV:8
98 : ite(83, 18, 97) : BV:8
99 : bvconcat(45, 63, 81, 98) : BV:32
100 : lambda(10, 99) : FUNCTION[BV:32 -> BV:32]
101 : map(9, 100) : MAP[BV:32 -> BV:32]
102 : sym_const(101) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda103 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda104 : BV:32
11 : 3 { 0x3 +1.35e129 } : BV:32
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(12, 10) : BV:32
14 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
15 : bvadd(11, 13, 14) : BV:32
16 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
17 : eq(15, 16) : BOOL
18 : 0 { 0x0 } : BV:8
19 : 1256949363 { 0x4aeb8673 +1.84004056e22 } : BV:32
20 : eq(15, 19) : BOOL
21 : 170 { 0xaa -86 } : BV:8
22 : 1728446693 { 0x670600e5 +1.4690229e79 } : BV:32
23 : eq(15, 22) : BOOL
24 : 1256949361 { 0x4aeb8671 +1.84004032e22 } : BV:32
25 : eq(15, 24) : BOOL
26 : 53 { 0x35 } : BV:8
27 : 1256949362 { 0x4aeb8672 +1.84004044e22 } : BV:32
28 : eq(15, 27) : BOOL
29 : 117 { 0x75 } : BV:8
30 : 1728446694 { 0x670600e6 +1.4690241e79 } : BV:32
31 : eq(15, 30) : BOOL
32 : 1728446695 { 0x670600e7 +1.4690253e79 } : BV:32
33 : eq(15, 32) : BOOL
34 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
35 : eq(15, 34) : BOOL
36 : 244 { 0xf4 -12 } : BV:8
37 : 5 { 0x5 } : BV:8
38 : ite(35, 36, 37) : BV:8
39 : ite(33, 18, 38) : BV:8
40 : ite(31, 18, 39) : BV:8
41 : ite(28, 29, 40) : BV:8
42 : ite(25, 26, 41) : BV:8
43 : ite(23, 18, 42) : BV:8
44 : ite(20, 21, 43) : BV:8
45 : ite(17, 18, 44) : BV:8
46 : 2 { 0x2 +1.23e129 } : BV:32
47 : bvadd(46, 13, 14) : BV:32
48 : eq(47, 16) : BOOL
49 : eq(47, 19) : BOOL
50 : eq(47, 22) : BOOL
51 : eq(47, 24) : BOOL
52 : eq(47, 27) : BOOL
53 : eq(47, 30) : BOOL
54 : eq(47, 32) : BOOL
55 : eq(47, 34) : BOOL
56 : ite(55, 36, 37) : BV:8
57 : ite(54, 18, 56) : BV:8
58 : ite(53, 18, 57) : BV:8
59 : ite(52, 29, 58) : BV:8
60 : ite(51, 26, 59) : BV:8
61 : ite(50, 18, 60) : BV:8
62 : ite(49, 21, 61) : BV:8
63 : ite(48, 18, 62) : BV:8
64 : 1 { 0x1 +1.11e129 } : BV:32
65 : bvadd(64, 13, 14) : BV:32
66 : eq(65, 16) : BOOL
67 : eq(65, 19) : BOOL
68 : eq(65, 22) : BOOL
69 : eq(65, 24) : BOOL
70 : eq(65, 27) : BOOL
71 : eq(65, 30) : BOOL
72 : eq(65, 32) : BOOL
73 : eq(65, 34) : BOOL
74 : ite(73, 36, 37) : BV:8
75 : ite(72, 18, 74) : BV:8
76 : ite(71, 18, 75) : BV:8
77 : ite(70, 29, 76) : BV:8
78 : ite(69, 26, 77) : BV:8
79 : ite(68, 18, 78) : BV:8
80 : ite(67, 21, 79) : BV:8
81 : ite(66, 18, 80) : BV:8
82 : bvadd(13, 14) : BV:32
83 : eq(82, 16) : BOOL
84 : eq(82, 19) : BOOL
85 : eq(82, 22) : BOOL
86 : eq(82, 24) : BOOL
87 : eq(82, 27) : BOOL
88 : eq(82, 30) : BOOL
89 : eq(82, 32) : BOOL
90 : eq(82, 34) : BOOL
91 : ite(90, 36, 37) : BV:8
92 : ite(89, 18, 91) : BV:8
93 : ite(88, 18, 92) : BV:8
94 : ite(87, 29, 93) : BV:8
95 : ite(86, 26, 94) : BV:8
96 : ite(85, 18, 95) : BV:8
97 : ite(84, 21, 96) : BV:8
98 : ite(83, 18, 97) : BV:8
99 : bvconcat(45, 63, 81, 98) : BV:32
100 : lambda(10, 99) : FUNCTION[BV:32 -> BV:32]
101 : map(9, 100) : MAP[BV:32 -> BV:32]
102 : sym_const(101) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda76 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
8 : eq(6, 7) : BOOL
9 : 0 { 0x0 } : BV:8
10 : 1256949363 { 0x4aeb8673 +1.84004056e22 } : BV:32
11 : eq(6, 10) : BOOL
12 : 170 { 0xaa -86 } : BV:8
13 : 1728446693 { 0x670600e5 +1.4690229e79 } : BV:32
14 : eq(6, 13) : BOOL
15 : 1256949361 { 0x4aeb8671 +1.84004032e22 } : BV:32
16 : eq(6, 15) : BOOL
17 : 53 { 0x35 } : BV:8
18 : 1256949362 { 0x4aeb8672 +1.84004044e22 } : BV:32
19 : eq(6, 18) : BOOL
20 : 117 { 0x75 } : BV:8
21 : 1728446694 { 0x670600e6 +1.4690241e79 } : BV:32
22 : eq(6, 21) : BOOL
23 : 1728446695 { 0x670600e7 +1.4690253e79 } : BV:32
24 : eq(6, 23) : BOOL
25 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
26 : eq(6, 25) : BOOL
27 : 244 { 0xf4 -12 } : BV:8
28 : 5 { 0x5 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 9, 29) : BV:8
31 : ite(22, 9, 30) : BV:8
32 : ite(19, 20, 31) : BV:8
33 : ite(16, 17, 32) : BV:8
34 : ite(14, 9, 33) : BV:8
35 : ite(11, 12, 34) : BV:8
36 : ite(8, 9, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 4, 5) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 10) : BOOL
41 : eq(38, 13) : BOOL
42 : eq(38, 15) : BOOL
43 : eq(38, 18) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 9, 47) : BV:8
49 : ite(44, 9, 48) : BV:8
50 : ite(43, 20, 49) : BV:8
51 : ite(42, 17, 50) : BV:8
52 : ite(41, 9, 51) : BV:8
53 : ite(40, 12, 52) : BV:8
54 : ite(39, 9, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 4, 5) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 10) : BOOL
59 : eq(56, 13) : BOOL
60 : eq(56, 15) : BOOL
61 : eq(56, 18) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 9, 65) : BV:8
67 : ite(62, 9, 66) : BV:8
68 : ite(61, 20, 67) : BV:8
69 : ite(60, 17, 68) : BV:8
70 : ite(59, 9, 69) : BV:8
71 : ite(58, 12, 70) : BV:8
72 : ite(57, 9, 71) : BV:8
73 : bvadd(4, 5) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 10) : BOOL
76 : eq(73, 13) : BOOL
77 : eq(73, 15) : BOOL
78 : eq(73, 18) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 9, 82) : BV:8
84 : ite(79, 9, 83) : BV:8
85 : ite(78, 20, 84) : BV:8
86 : ite(77, 17, 85) : BV:8
87 : ite(76, 9, 86) : BV:8
88 : ite(75, 12, 87) : BV:8
89 : ite(74, 9, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : lambda(1, 90) : FUNCTION[BV:32 -> BV:32]
92 : sym_const(91) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1256949359 ] -> 5, [ 1256949360; 1256949360 ] -> 244, [ 1256949361; 1256949361 ] -> 53, [ 1256949362; 1256949362 ] -> 117, [ 1256949363; 1256949363 ] -> 170, [ 1256949364; 1728446691 ] -> 5, [ 1728446692; 1728446695 ] -> 0, [ 1728446696; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda77 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
8 : eq(6, 7) : BOOL
9 : 0 { 0x0 } : BV:8
10 : 1256949363 { 0x4aeb8673 +1.84004056e22 } : BV:32
11 : eq(6, 10) : BOOL
12 : 170 { 0xaa -86 } : BV:8
13 : 1728446693 { 0x670600e5 +1.4690229e79 } : BV:32
14 : eq(6, 13) : BOOL
15 : 1256949361 { 0x4aeb8671 +1.84004032e22 } : BV:32
16 : eq(6, 15) : BOOL
17 : 53 { 0x35 } : BV:8
18 : 1256949362 { 0x4aeb8672 +1.84004044e22 } : BV:32
19 : eq(6, 18) : BOOL
20 : 117 { 0x75 } : BV:8
21 : 1728446694 { 0x670600e6 +1.4690241e79 } : BV:32
22 : eq(6, 21) : BOOL
23 : 1728446695 { 0x670600e7 +1.4690253e79 } : BV:32
24 : eq(6, 23) : BOOL
25 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
26 : eq(6, 25) : BOOL
27 : 244 { 0xf4 -12 } : BV:8
28 : 5 { 0x5 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 9, 29) : BV:8
31 : ite(22, 9, 30) : BV:8
32 : ite(19, 20, 31) : BV:8
33 : ite(16, 17, 32) : BV:8
34 : ite(14, 9, 33) : BV:8
35 : ite(11, 12, 34) : BV:8
36 : ite(8, 9, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 4, 5) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 10) : BOOL
41 : eq(38, 13) : BOOL
42 : eq(38, 15) : BOOL
43 : eq(38, 18) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 9, 47) : BV:8
49 : ite(44, 9, 48) : BV:8
50 : ite(43, 20, 49) : BV:8
51 : ite(42, 17, 50) : BV:8
52 : ite(41, 9, 51) : BV:8
53 : ite(40, 12, 52) : BV:8
54 : ite(39, 9, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 4, 5) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 10) : BOOL
59 : eq(56, 13) : BOOL
60 : eq(56, 15) : BOOL
61 : eq(56, 18) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 9, 65) : BV:8
67 : ite(62, 9, 66) : BV:8
68 : ite(61, 20, 67) : BV:8
69 : ite(60, 17, 68) : BV:8
70 : ite(59, 9, 69) : BV:8
71 : ite(58, 12, 70) : BV:8
72 : ite(57, 9, 71) : BV:8
73 : bvadd(4, 5) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 10) : BOOL
76 : eq(73, 13) : BOOL
77 : eq(73, 15) : BOOL
78 : eq(73, 18) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 9, 82) : BV:8
84 : ite(79, 9, 83) : BV:8
85 : ite(78, 20, 84) : BV:8
86 : ite(77, 17, 85) : BV:8
87 : ite(76, 9, 86) : BV:8
88 : ite(75, 12, 87) : BV:8
89 : ite(74, 9, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : lambda(1, 90) : FUNCTION[BV:32 -> BV:32]
92 : sym_const(91) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%arr
1 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1256949359 ] -> 5, [ 1256949360; 1256949360 ] -> 244, [ 1256949361; 1256949361 ] -> 53, [ 1256949362; 1256949362 ] -> 117, [ 1256949363; 1256949363 ] -> 170, [ 1256949364; 1728446691 ] -> 5, [ 1728446692; 1728446695 ] -> 0, [ 1728446696; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1256949359 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1256949360; 1256949363 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1256949364; 1728446691 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1728446692; 1728446695 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1728446696; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
=input.dst.local_alloc_count.=L0%0%d=
1 : 966562793 { 0x399c93e9 +1.22326385e244 } : COUNT
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 966562793 { 0x399c93e9 +1.22326385e244 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1256949359 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1256949360; 1256949363 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1256949364; 1728446691 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1728446692; 1728446695 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1728446696; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1728446695 { 0x670600e7 +1.4690253e79 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1256949363 { 0x4aeb8673 +1.84004056e22 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3421045957
=counter_example_end
=global nodece 1 num_edges_traversed 1
=global nodece 1 nodece_visted_pcs: 
L0%0%d_L0%0%d -> L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 2
=global nodece 2 nodece z3.ce19.num_edges_traversed1
=global nodece 2 nodece_path
=global nodece 2 nodece_path.graph_edge_composition
(L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 2 nodece_cached_counterexample
=counter_example_begin z3.ce19 45d424cd3c318cfaf285dce2a7e54c41
=input.spec-%var-arr-1
1 : Lambda193 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda194 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda193 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda194 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda172 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda173 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.dst.llvm-%arr
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.local_alloc_count.=L0%0%d=
1 : 318648393 { 0x12fe3049 +1.98584854e166 } : COUNT
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 318648393 { 0x12fe3049 +1.98584854e166 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1903413019 { 0x7173c71b +1.90451371e99 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
340383979
=counter_example_end
=global nodece 2 num_edges_traversed 1
=global nodece 2 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 3
=global nodece 3 nodece z3v487.ce20.num_edges_traversed1
=global nodece 3 nodece_path
=global nodece 3 nodece_path.graph_edge_composition
(L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 3 nodece_cached_counterexample
=counter_example_begin z3v487.ce20 e92023b3262a64d2c46bb7e026b19553
=input.spec-%var-arr-1
1 : Lambda207 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda208 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda207 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda208 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda181 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda182 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-%arr
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.local_alloc_count.=L0%0%d=
1 : 211961543 { 0xca246c7 +1.26778495e154 } : COUNT
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 211961543 { 0xca246c7 +1.26778495e154 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 67 { 0x43 +1.798e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3721003027 { 0xddca0013 -573964269 -1.57812726e60 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
180861690
=counter_example_end
=global nodece 3 num_edges_traversed 1
=global nodece 3 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 4
=global nodece 4 nodece z3.ce41.num_edges_traversed1
=global nodece 4 nodece_path
=global nodece 4 nodece_path.graph_edge_composition
(L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 4 nodece_cached_counterexample
=counter_example_begin z3.ce41 92927c646ee874fcdea81e65fc066e
=input.spec-%var-arr-1
1 : Lambda297 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda298 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda297 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda298 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda276 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda277 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.dst.llvm-%arr
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.local_alloc_count.=L0%0%d=
1 : 961465037 { 0x394ecacd +1.61556398e243 } : COUNT
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 961465037 { 0x394ecacd +1.61556398e243 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1067701935 { 0x3fa3d6af +1.27998912e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3670926980
=counter_example_end
=global nodece 4 num_edges_traversed 1
=global nodece 4 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 5
=global nodece 5 nodece z3.ce63.num_edges_traversed1
=global nodece 5 nodece_path
=global nodece 5 nodece_path.graph_edge_composition
(L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 5 nodece_cached_counterexample
=counter_example_begin z3.ce63 97d2639752ab3038a32f03e6f88ba56
=input.spec-%var-arr-1
1 : Lambda401 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda402 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda401 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda402 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda380 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : ite(3, 2, 128) : BV:32
130 : lambda(1, 129) : FUNCTION[BV:32 -> BV:32]
131 : sym_const(130) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda381 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : lambda(1, 128) : FUNCTION[BV:32 -> BV:32]
130 : sym_const(129) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.dst.llvm-%arr
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.local_alloc_count.=L0%0%d=
1 : 1420111171 { 0x54a52d43 +1.29044377e42 } : COUNT
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1420111171 { 0x54a52d43 +1.29044377e42 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
155419542
=counter_example_end
=global nodece 5 num_edges_traversed 1
=global nodece 5 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 6
=global nodece 6 nodece z3v487.ce578.num_edges_traversed0
=global nodece 6 nodece_path
=global nodece 6 nodece_path.graph_edge_composition
(epsilon)
=global nodece 6 nodece_cached_counterexample
=counter_example_begin z3v487.ce578 cadf49c3beab66c460ad45ff07ee579
=input.spec-%var-arr-1
1 : Lambda4098 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda4099 : BV:32
11 : 3 { 0x3 +1.35e129 } : BV:32
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(12, 10) : BV:32
14 : bvadd(11, 13) : BV:32
15 : bvule(2, 14) : BOOL
16 : 536870911 { 0x1fffffff +1.99999988e192 } : BV:32
17 : bvule(14, 16) : BOOL
18 : and(15, 17) : BOOL
19 : 1 { 0x1 } : BV:8
20 : 536870912 { 0x20000000 +1.0e193 } : BV:32
21 : bvule(20, 14) : BOOL
22 : 536870915 { 0x20000003 +1.35e193 } : BV:32
23 : bvule(14, 22) : BOOL
24 : and(21, 23) : BOOL
25 : 4 { 0x4 } : BV:8
26 : 536870916 { 0x20000004 +1.47e193 } : BV:32
27 : bvule(26, 14) : BOOL
28 : 3448586623 { 0xcd8d417f -846380673 -1.10356128e28 } : BV:32
29 : bvule(14, 28) : BOOL
30 : and(27, 29) : BOOL
31 : 0 { 0x0 } : BV:8
32 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
33 : bvule(32, 14) : BOOL
34 : 3448586627 { 0xcd8d4183 -846380669 -1.10356175e28 } : BV:32
35 : bvule(14, 34) : BOOL
36 : and(33, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : 3448586628 { 0xcd8d4184 -846380668 -1.10356187e28 } : BV:32
39 : bvule(38, 14) : BOOL
40 : bvule(14, 4) : BOOL
41 : and(39, 40) : BOOL
42 : ite(41, 31, 31) : BV:8
43 : ite(36, 37, 42) : BV:8
44 : ite(30, 31, 43) : BV:8
45 : ite(24, 25, 44) : BV:8
46 : ite(18, 19, 45) : BV:8
47 : 2 { 0x2 +1.23e129 } : BV:32
48 : bvadd(47, 13) : BV:32
49 : bvule(2, 48) : BOOL
50 : bvule(48, 16) : BOOL
51 : and(49, 50) : BOOL
52 : bvule(20, 48) : BOOL
53 : bvule(48, 22) : BOOL
54 : and(52, 53) : BOOL
55 : bvule(26, 48) : BOOL
56 : bvule(48, 28) : BOOL
57 : and(55, 56) : BOOL
58 : bvule(32, 48) : BOOL
59 : bvule(48, 34) : BOOL
60 : and(58, 59) : BOOL
61 : bvule(38, 48) : BOOL
62 : bvule(48, 4) : BOOL
63 : and(61, 62) : BOOL
64 : ite(63, 31, 31) : BV:8
65 : ite(60, 37, 64) : BV:8
66 : ite(57, 31, 65) : BV:8
67 : ite(54, 25, 66) : BV:8
68 : ite(51, 19, 67) : BV:8
69 : 1 { 0x1 +1.11e129 } : BV:32
70 : bvadd(69, 13) : BV:32
71 : bvule(2, 70) : BOOL
72 : bvule(70, 16) : BOOL
73 : and(71, 72) : BOOL
74 : bvule(20, 70) : BOOL
75 : bvule(70, 22) : BOOL
76 : and(74, 75) : BOOL
77 : bvule(26, 70) : BOOL
78 : bvule(70, 28) : BOOL
79 : and(77, 78) : BOOL
80 : bvule(32, 70) : BOOL
81 : bvule(70, 34) : BOOL
82 : and(80, 81) : BOOL
83 : bvule(38, 70) : BOOL
84 : bvule(70, 4) : BOOL
85 : and(83, 84) : BOOL
86 : ite(85, 31, 31) : BV:8
87 : ite(82, 37, 86) : BV:8
88 : ite(79, 31, 87) : BV:8
89 : ite(76, 25, 88) : BV:8
90 : ite(73, 19, 89) : BV:8
91 : bvule(2, 13) : BOOL
92 : bvule(13, 16) : BOOL
93 : and(91, 92) : BOOL
94 : bvule(20, 13) : BOOL
95 : bvule(13, 22) : BOOL
96 : and(94, 95) : BOOL
97 : bvule(26, 13) : BOOL
98 : bvule(13, 28) : BOOL
99 : and(97, 98) : BOOL
100 : bvule(32, 13) : BOOL
101 : bvule(13, 34) : BOOL
102 : and(100, 101) : BOOL
103 : bvule(38, 13) : BOOL
104 : bvule(13, 4) : BOOL
105 : and(103, 104) : BOOL
106 : ite(105, 31, 31) : BV:8
107 : ite(102, 37, 106) : BV:8
108 : ite(99, 31, 107) : BV:8
109 : ite(96, 25, 108) : BV:8
110 : ite(93, 19, 109) : BV:8
111 : bvconcat(46, 68, 90, 110) : BV:32
112 : lambda(10, 111) : FUNCTION[BV:32 -> BV:32]
113 : map(9, 112) : MAP[BV:32 -> BV:32]
114 : sym_const(113) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4101 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda4102 : BV:32
11 : bvule(2, 10) : BOOL
12 : bvule(10, 4) : BOOL
13 : and(11, 12) : BOOL
14 : ite(13, 7, 7) : BOOL
15 : 3 { 0x3 +1.35e129 } : BV:32
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(16, 10) : BV:32
18 : bvadd(15, 17) : BV:32
19 : bvule(2, 18) : BOOL
20 : 536870911 { 0x1fffffff +1.99999988e192 } : BV:32
21 : bvule(18, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 1 { 0x1 } : BV:8
24 : 536870912 { 0x20000000 +1.0e193 } : BV:32
25 : bvule(24, 18) : BOOL
26 : 536870915 { 0x20000003 +1.35e193 } : BV:32
27 : bvule(18, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 4 { 0x4 } : BV:8
30 : 536870916 { 0x20000004 +1.47e193 } : BV:32
31 : bvule(30, 18) : BOOL
32 : 3448586623 { 0xcd8d417f -846380673 -1.10356128e28 } : BV:32
33 : bvule(18, 32) : BOOL
34 : and(31, 33) : BOOL
35 : 0 { 0x0 } : BV:8
36 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
37 : bvule(36, 18) : BOOL
38 : 3448586627 { 0xcd8d4183 -846380669 -1.10356175e28 } : BV:32
39 : bvule(18, 38) : BOOL
40 : and(37, 39) : BOOL
41 : 5 { 0x5 } : BV:8
42 : 3448586628 { 0xcd8d4184 -846380668 -1.10356187e28 } : BV:32
43 : bvule(42, 18) : BOOL
44 : bvule(18, 4) : BOOL
45 : and(43, 44) : BOOL
46 : ite(45, 35, 35) : BV:8
47 : ite(40, 41, 46) : BV:8
48 : ite(34, 35, 47) : BV:8
49 : ite(28, 29, 48) : BV:8
50 : ite(22, 23, 49) : BV:8
51 : 2 { 0x2 +1.23e129 } : BV:32
52 : bvadd(51, 17) : BV:32
53 : bvule(2, 52) : BOOL
54 : bvule(52, 20) : BOOL
55 : and(53, 54) : BOOL
56 : bvule(24, 52) : BOOL
57 : bvule(52, 26) : BOOL
58 : and(56, 57) : BOOL
59 : bvule(30, 52) : BOOL
60 : bvule(52, 32) : BOOL
61 : and(59, 60) : BOOL
62 : bvule(36, 52) : BOOL
63 : bvule(52, 38) : BOOL
64 : and(62, 63) : BOOL
65 : bvule(42, 52) : BOOL
66 : bvule(52, 4) : BOOL
67 : and(65, 66) : BOOL
68 : ite(67, 35, 35) : BV:8
69 : ite(64, 41, 68) : BV:8
70 : ite(61, 35, 69) : BV:8
71 : ite(58, 29, 70) : BV:8
72 : ite(55, 23, 71) : BV:8
73 : 1 { 0x1 +1.11e129 } : BV:32
74 : bvadd(73, 17) : BV:32
75 : bvule(2, 74) : BOOL
76 : bvule(74, 20) : BOOL
77 : and(75, 76) : BOOL
78 : bvule(24, 74) : BOOL
79 : bvule(74, 26) : BOOL
80 : and(78, 79) : BOOL
81 : bvule(30, 74) : BOOL
82 : bvule(74, 32) : BOOL
83 : and(81, 82) : BOOL
84 : bvule(36, 74) : BOOL
85 : bvule(74, 38) : BOOL
86 : and(84, 85) : BOOL
87 : bvule(42, 74) : BOOL
88 : bvule(74, 4) : BOOL
89 : and(87, 88) : BOOL
90 : ite(89, 35, 35) : BV:8
91 : ite(86, 41, 90) : BV:8
92 : ite(83, 35, 91) : BV:8
93 : ite(80, 29, 92) : BV:8
94 : ite(77, 23, 93) : BV:8
95 : bvule(2, 17) : BOOL
96 : bvule(17, 20) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(24, 17) : BOOL
99 : bvule(17, 26) : BOOL
100 : and(98, 99) : BOOL
101 : bvule(30, 17) : BOOL
102 : bvule(17, 32) : BOOL
103 : and(101, 102) : BOOL
104 : bvule(36, 17) : BOOL
105 : bvule(17, 38) : BOOL
106 : and(104, 105) : BOOL
107 : bvule(42, 17) : BOOL
108 : bvule(17, 4) : BOOL
109 : and(107, 108) : BOOL
110 : ite(109, 35, 35) : BV:8
111 : ite(106, 41, 110) : BV:8
112 : ite(103, 35, 111) : BV:8
113 : ite(100, 29, 112) : BV:8
114 : ite(97, 23, 113) : BV:8
115 : bvconcat(50, 72, 94, 114) : BV:32
116 : ite(14, 115, 115) : BV:32
117 : lambda(10, 116) : FUNCTION[BV:32 -> BV:32]
118 : map(9, 117) : MAP[BV:32 -> BV:32]
119 : sym_const(118) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda4076 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : 3 { 0x3 +1.35e129 } : BV:32
10 : 4 { 0x4 +1.47e129 } : BV:32
11 : bvmul(10, 1) : BV:32
12 : bvadd(9, 11) : BV:32
13 : bvule(2, 12) : BOOL
14 : 536870911 { 0x1fffffff +1.99999988e192 } : BV:32
15 : bvule(12, 14) : BOOL
16 : and(13, 15) : BOOL
17 : 1 { 0x1 } : BV:8
18 : 536870912 { 0x20000000 +1.0e193 } : BV:32
19 : bvule(18, 12) : BOOL
20 : 536870915 { 0x20000003 +1.35e193 } : BV:32
21 : bvule(12, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 4 { 0x4 } : BV:8
24 : 536870916 { 0x20000004 +1.47e193 } : BV:32
25 : bvule(24, 12) : BOOL
26 : 3448586623 { 0xcd8d417f -846380673 -1.10356128e28 } : BV:32
27 : bvule(12, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 0 { 0x0 } : BV:8
30 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
31 : bvule(30, 12) : BOOL
32 : 3448586627 { 0xcd8d4183 -846380669 -1.10356175e28 } : BV:32
33 : bvule(12, 32) : BOOL
34 : and(31, 33) : BOOL
35 : 5 { 0x5 } : BV:8
36 : 3448586628 { 0xcd8d4184 -846380668 -1.10356187e28 } : BV:32
37 : bvule(36, 12) : BOOL
38 : bvule(12, 4) : BOOL
39 : and(37, 38) : BOOL
40 : ite(39, 29, 29) : BV:8
41 : ite(34, 35, 40) : BV:8
42 : ite(28, 29, 41) : BV:8
43 : ite(22, 23, 42) : BV:8
44 : ite(16, 17, 43) : BV:8
45 : 2 { 0x2 +1.23e129 } : BV:32
46 : bvadd(45, 11) : BV:32
47 : bvule(2, 46) : BOOL
48 : bvule(46, 14) : BOOL
49 : and(47, 48) : BOOL
50 : bvule(18, 46) : BOOL
51 : bvule(46, 20) : BOOL
52 : and(50, 51) : BOOL
53 : bvule(24, 46) : BOOL
54 : bvule(46, 26) : BOOL
55 : and(53, 54) : BOOL
56 : bvule(30, 46) : BOOL
57 : bvule(46, 32) : BOOL
58 : and(56, 57) : BOOL
59 : bvule(36, 46) : BOOL
60 : bvule(46, 4) : BOOL
61 : and(59, 60) : BOOL
62 : ite(61, 29, 29) : BV:8
63 : ite(58, 35, 62) : BV:8
64 : ite(55, 29, 63) : BV:8
65 : ite(52, 23, 64) : BV:8
66 : ite(49, 17, 65) : BV:8
67 : 1 { 0x1 +1.11e129 } : BV:32
68 : bvadd(67, 11) : BV:32
69 : bvule(2, 68) : BOOL
70 : bvule(68, 14) : BOOL
71 : and(69, 70) : BOOL
72 : bvule(18, 68) : BOOL
73 : bvule(68, 20) : BOOL
74 : and(72, 73) : BOOL
75 : bvule(24, 68) : BOOL
76 : bvule(68, 26) : BOOL
77 : and(75, 76) : BOOL
78 : bvule(30, 68) : BOOL
79 : bvule(68, 32) : BOOL
80 : and(78, 79) : BOOL
81 : bvule(36, 68) : BOOL
82 : bvule(68, 4) : BOOL
83 : and(81, 82) : BOOL
84 : ite(83, 29, 29) : BV:8
85 : ite(80, 35, 84) : BV:8
86 : ite(77, 29, 85) : BV:8
87 : ite(74, 23, 86) : BV:8
88 : ite(71, 17, 87) : BV:8
89 : bvule(2, 11) : BOOL
90 : bvule(11, 14) : BOOL
91 : and(89, 90) : BOOL
92 : bvule(18, 11) : BOOL
93 : bvule(11, 20) : BOOL
94 : and(92, 93) : BOOL
95 : bvule(24, 11) : BOOL
96 : bvule(11, 26) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(30, 11) : BOOL
99 : bvule(11, 32) : BOOL
100 : and(98, 99) : BOOL
101 : bvule(36, 11) : BOOL
102 : bvule(11, 4) : BOOL
103 : and(101, 102) : BOOL
104 : ite(103, 29, 29) : BV:8
105 : ite(100, 35, 104) : BV:8
106 : ite(97, 29, 105) : BV:8
107 : ite(94, 23, 106) : BV:8
108 : ite(91, 17, 107) : BV:8
109 : bvconcat(44, 66, 88, 108) : BV:32
110 : ite(8, 109, 109) : BV:32
111 : lambda(1, 110) : FUNCTION[BV:32 -> BV:32]
112 : sym_const(111) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform417 : BV:32
4 : Lambda4105 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4106 : BV:32
7 : 527975818 { 0x1f78458a +1.93962216e191 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 536870911 ] -> 1, [ 536870912; 536870915 ] -> 4, [ 536870916; 3448586623 ] -> 0, [ 3448586624; 3448586627 ] -> 5, [ 3448586628; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda4080 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 3 { 0x3 +1.35e129 } : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(4, 1) : BV:32
6 : bvadd(3, 5) : BV:32
7 : bvule(2, 6) : BOOL
8 : 536870911 { 0x1fffffff +1.99999988e192 } : BV:32
9 : bvule(6, 8) : BOOL
10 : and(7, 9) : BOOL
11 : 1 { 0x1 } : BV:8
12 : 536870912 { 0x20000000 +1.0e193 } : BV:32
13 : bvule(12, 6) : BOOL
14 : 536870915 { 0x20000003 +1.35e193 } : BV:32
15 : bvule(6, 14) : BOOL
16 : and(13, 15) : BOOL
17 : 4 { 0x4 } : BV:8
18 : 536870916 { 0x20000004 +1.47e193 } : BV:32
19 : bvule(18, 6) : BOOL
20 : 3448586623 { 0xcd8d417f -846380673 -1.10356128e28 } : BV:32
21 : bvule(6, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
25 : bvule(24, 6) : BOOL
26 : 3448586627 { 0xcd8d4183 -846380669 -1.10356175e28 } : BV:32
27 : bvule(6, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 5 { 0x5 } : BV:8
30 : 3448586628 { 0xcd8d4184 -846380668 -1.10356187e28 } : BV:32
31 : bvule(30, 6) : BOOL
32 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
33 : bvule(6, 32) : BOOL
34 : and(31, 33) : BOOL
35 : ite(34, 23, 23) : BV:8
36 : ite(28, 29, 35) : BV:8
37 : ite(22, 23, 36) : BV:8
38 : ite(16, 17, 37) : BV:8
39 : ite(10, 11, 38) : BV:8
40 : 2 { 0x2 +1.23e129 } : BV:32
41 : bvadd(40, 5) : BV:32
42 : bvule(2, 41) : BOOL
43 : bvule(41, 8) : BOOL
44 : and(42, 43) : BOOL
45 : bvule(12, 41) : BOOL
46 : bvule(41, 14) : BOOL
47 : and(45, 46) : BOOL
48 : bvule(18, 41) : BOOL
49 : bvule(41, 20) : BOOL
50 : and(48, 49) : BOOL
51 : bvule(24, 41) : BOOL
52 : bvule(41, 26) : BOOL
53 : and(51, 52) : BOOL
54 : bvule(30, 41) : BOOL
55 : bvule(41, 32) : BOOL
56 : and(54, 55) : BOOL
57 : ite(56, 23, 23) : BV:8
58 : ite(53, 29, 57) : BV:8
59 : ite(50, 23, 58) : BV:8
60 : ite(47, 17, 59) : BV:8
61 : ite(44, 11, 60) : BV:8
62 : 1 { 0x1 +1.11e129 } : BV:32
63 : bvadd(62, 5) : BV:32
64 : bvule(2, 63) : BOOL
65 : bvule(63, 8) : BOOL
66 : and(64, 65) : BOOL
67 : bvule(12, 63) : BOOL
68 : bvule(63, 14) : BOOL
69 : and(67, 68) : BOOL
70 : bvule(18, 63) : BOOL
71 : bvule(63, 20) : BOOL
72 : and(70, 71) : BOOL
73 : bvule(24, 63) : BOOL
74 : bvule(63, 26) : BOOL
75 : and(73, 74) : BOOL
76 : bvule(30, 63) : BOOL
77 : bvule(63, 32) : BOOL
78 : and(76, 77) : BOOL
79 : ite(78, 23, 23) : BV:8
80 : ite(75, 29, 79) : BV:8
81 : ite(72, 23, 80) : BV:8
82 : ite(69, 17, 81) : BV:8
83 : ite(66, 11, 82) : BV:8
84 : bvule(2, 5) : BOOL
85 : bvule(5, 8) : BOOL
86 : and(84, 85) : BOOL
87 : bvule(12, 5) : BOOL
88 : bvule(5, 14) : BOOL
89 : and(87, 88) : BOOL
90 : bvule(18, 5) : BOOL
91 : bvule(5, 20) : BOOL
92 : and(90, 91) : BOOL
93 : bvule(24, 5) : BOOL
94 : bvule(5, 26) : BOOL
95 : and(93, 94) : BOOL
96 : bvule(30, 5) : BOOL
97 : bvule(5, 32) : BOOL
98 : and(96, 97) : BOOL
99 : ite(98, 23, 23) : BV:8
100 : ite(95, 29, 99) : BV:8
101 : ite(92, 23, 100) : BV:8
102 : ite(89, 17, 101) : BV:8
103 : ite(86, 11, 102) : BV:8
104 : bvconcat(39, 61, 83, 103) : BV:32
105 : lambda(1, 104) : FUNCTION[BV:32 -> BV:32]
106 : sym_const(105) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform416 : BV:32
3 : Lambda4103 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda4104 : BV:32
6 : unit : UNIT
7 : 1803953772 { 0x6b86266c +1.4804754e88 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 536870911 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 536870912; 536870915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 536870916; 3448586623 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3448586624; 3448586627 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3448586628; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 536870915 { 0x20000003 +1.35e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3448586627 { 0xcd8d4183 -846380669 -1.10356175e28 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
4230277750
=counter_example_end
=global nodece 6 num_edges_traversed 0
=global nodece 6 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 7
=global nodece 7 nodece z3.ce579.num_edges_traversed0
=global nodece 7 nodece_path
=global nodece 7 nodece_path.graph_edge_composition
(epsilon)
=global nodece 7 nodece_cached_counterexample
=counter_example_begin z3.ce579 78231888985970eb7153d051572031
=input.spec-%var-arr-1
1 : Lambda4116 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda4117 : BV:32
11 : bvule(2, 10) : BOOL
12 : bvule(10, 4) : BOOL
13 : and(11, 12) : BOOL
14 : ite(13, 7, 7) : BOOL
15 : 3 { 0x3 +1.35e129 } : BV:32
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(16, 10) : BV:32
18 : bvadd(15, 17) : BV:32
19 : bvule(2, 18) : BOOL
20 : 1703603503 { 0x658aed2f +1.8536326e76 } : BV:32
21 : bvule(18, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 1 { 0x1 } : BV:8
24 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
25 : bvule(24, 18) : BOOL
26 : 1703603507 { 0x658aed33 +1.8536374e76 } : BV:32
27 : bvule(18, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 4 { 0x4 } : BV:8
30 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
31 : bvule(30, 18) : BOOL
32 : 3726783631 { 0xde22348f -568183665 -1.26722896e61 } : BV:32
33 : bvule(18, 32) : BOOL
34 : and(31, 33) : BOOL
35 : 5 { 0x5 } : BV:8
36 : 1703603508 { 0x658aed34 +1.8536386e76 } : BV:32
37 : bvule(36, 18) : BOOL
38 : 3726783627 { 0xde22348b -568183669 -1.26722848e61 } : BV:32
39 : bvule(18, 38) : BOOL
40 : and(37, 39) : BOOL
41 : 0 { 0x0 } : BV:8
42 : 3726783632 { 0xde223490 -568183664 -1.26722908e61 } : BV:32
43 : bvule(42, 18) : BOOL
44 : bvule(18, 4) : BOOL
45 : and(43, 44) : BOOL
46 : ite(45, 41, 41) : BV:8
47 : ite(40, 41, 46) : BV:8
48 : ite(34, 35, 47) : BV:8
49 : ite(28, 29, 48) : BV:8
50 : ite(22, 23, 49) : BV:8
51 : 2 { 0x2 +1.23e129 } : BV:32
52 : bvadd(51, 17) : BV:32
53 : bvule(2, 52) : BOOL
54 : bvule(52, 20) : BOOL
55 : and(53, 54) : BOOL
56 : bvule(24, 52) : BOOL
57 : bvule(52, 26) : BOOL
58 : and(56, 57) : BOOL
59 : bvule(30, 52) : BOOL
60 : bvule(52, 32) : BOOL
61 : and(59, 60) : BOOL
62 : bvule(36, 52) : BOOL
63 : bvule(52, 38) : BOOL
64 : and(62, 63) : BOOL
65 : bvule(42, 52) : BOOL
66 : bvule(52, 4) : BOOL
67 : and(65, 66) : BOOL
68 : ite(67, 41, 41) : BV:8
69 : ite(64, 41, 68) : BV:8
70 : ite(61, 35, 69) : BV:8
71 : ite(58, 29, 70) : BV:8
72 : ite(55, 23, 71) : BV:8
73 : 1 { 0x1 +1.11e129 } : BV:32
74 : bvadd(73, 17) : BV:32
75 : bvule(2, 74) : BOOL
76 : bvule(74, 20) : BOOL
77 : and(75, 76) : BOOL
78 : bvule(24, 74) : BOOL
79 : bvule(74, 26) : BOOL
80 : and(78, 79) : BOOL
81 : bvule(30, 74) : BOOL
82 : bvule(74, 32) : BOOL
83 : and(81, 82) : BOOL
84 : bvule(36, 74) : BOOL
85 : bvule(74, 38) : BOOL
86 : and(84, 85) : BOOL
87 : bvule(42, 74) : BOOL
88 : bvule(74, 4) : BOOL
89 : and(87, 88) : BOOL
90 : ite(89, 41, 41) : BV:8
91 : ite(86, 41, 90) : BV:8
92 : ite(83, 35, 91) : BV:8
93 : ite(80, 29, 92) : BV:8
94 : ite(77, 23, 93) : BV:8
95 : bvule(2, 17) : BOOL
96 : bvule(17, 20) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(24, 17) : BOOL
99 : bvule(17, 26) : BOOL
100 : and(98, 99) : BOOL
101 : bvule(30, 17) : BOOL
102 : bvule(17, 32) : BOOL
103 : and(101, 102) : BOOL
104 : bvule(36, 17) : BOOL
105 : bvule(17, 38) : BOOL
106 : and(104, 105) : BOOL
107 : bvule(42, 17) : BOOL
108 : bvule(17, 4) : BOOL
109 : and(107, 108) : BOOL
110 : ite(109, 41, 41) : BV:8
111 : ite(106, 41, 110) : BV:8
112 : ite(103, 35, 111) : BV:8
113 : ite(100, 29, 112) : BV:8
114 : ite(97, 23, 113) : BV:8
115 : bvconcat(50, 72, 94, 114) : BV:32
116 : ite(14, 115, 115) : BV:32
117 : lambda(10, 116) : FUNCTION[BV:32 -> BV:32]
118 : map(9, 117) : MAP[BV:32 -> BV:32]
119 : sym_const(118) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4119 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda4120 : BV:32
11 : 3 { 0x3 +1.35e129 } : BV:32
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(12, 10) : BV:32
14 : bvadd(11, 13) : BV:32
15 : bvule(2, 14) : BOOL
16 : 1703603503 { 0x658aed2f +1.8536326e76 } : BV:32
17 : bvule(14, 16) : BOOL
18 : and(15, 17) : BOOL
19 : 1 { 0x1 } : BV:8
20 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
21 : bvule(20, 14) : BOOL
22 : 1703603507 { 0x658aed33 +1.8536374e76 } : BV:32
23 : bvule(14, 22) : BOOL
24 : and(21, 23) : BOOL
25 : 4 { 0x4 } : BV:8
26 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
27 : bvule(26, 14) : BOOL
28 : 3726783631 { 0xde22348f -568183665 -1.26722896e61 } : BV:32
29 : bvule(14, 28) : BOOL
30 : and(27, 29) : BOOL
31 : 5 { 0x5 } : BV:8
32 : 1703603508 { 0x658aed34 +1.8536386e76 } : BV:32
33 : bvule(32, 14) : BOOL
34 : 3726783627 { 0xde22348b -568183669 -1.26722848e61 } : BV:32
35 : bvule(14, 34) : BOOL
36 : and(33, 35) : BOOL
37 : 0 { 0x0 } : BV:8
38 : 3726783632 { 0xde223490 -568183664 -1.26722908e61 } : BV:32
39 : bvule(38, 14) : BOOL
40 : bvule(14, 4) : BOOL
41 : and(39, 40) : BOOL
42 : ite(41, 37, 37) : BV:8
43 : ite(36, 37, 42) : BV:8
44 : ite(30, 31, 43) : BV:8
45 : ite(24, 25, 44) : BV:8
46 : ite(18, 19, 45) : BV:8
47 : 2 { 0x2 +1.23e129 } : BV:32
48 : bvadd(47, 13) : BV:32
49 : bvule(2, 48) : BOOL
50 : bvule(48, 16) : BOOL
51 : and(49, 50) : BOOL
52 : bvule(20, 48) : BOOL
53 : bvule(48, 22) : BOOL
54 : and(52, 53) : BOOL
55 : bvule(26, 48) : BOOL
56 : bvule(48, 28) : BOOL
57 : and(55, 56) : BOOL
58 : bvule(32, 48) : BOOL
59 : bvule(48, 34) : BOOL
60 : and(58, 59) : BOOL
61 : bvule(38, 48) : BOOL
62 : bvule(48, 4) : BOOL
63 : and(61, 62) : BOOL
64 : ite(63, 37, 37) : BV:8
65 : ite(60, 37, 64) : BV:8
66 : ite(57, 31, 65) : BV:8
67 : ite(54, 25, 66) : BV:8
68 : ite(51, 19, 67) : BV:8
69 : 1 { 0x1 +1.11e129 } : BV:32
70 : bvadd(69, 13) : BV:32
71 : bvule(2, 70) : BOOL
72 : bvule(70, 16) : BOOL
73 : and(71, 72) : BOOL
74 : bvule(20, 70) : BOOL
75 : bvule(70, 22) : BOOL
76 : and(74, 75) : BOOL
77 : bvule(26, 70) : BOOL
78 : bvule(70, 28) : BOOL
79 : and(77, 78) : BOOL
80 : bvule(32, 70) : BOOL
81 : bvule(70, 34) : BOOL
82 : and(80, 81) : BOOL
83 : bvule(38, 70) : BOOL
84 : bvule(70, 4) : BOOL
85 : and(83, 84) : BOOL
86 : ite(85, 37, 37) : BV:8
87 : ite(82, 37, 86) : BV:8
88 : ite(79, 31, 87) : BV:8
89 : ite(76, 25, 88) : BV:8
90 : ite(73, 19, 89) : BV:8
91 : bvule(2, 13) : BOOL
92 : bvule(13, 16) : BOOL
93 : and(91, 92) : BOOL
94 : bvule(20, 13) : BOOL
95 : bvule(13, 22) : BOOL
96 : and(94, 95) : BOOL
97 : bvule(26, 13) : BOOL
98 : bvule(13, 28) : BOOL
99 : and(97, 98) : BOOL
100 : bvule(32, 13) : BOOL
101 : bvule(13, 34) : BOOL
102 : and(100, 101) : BOOL
103 : bvule(38, 13) : BOOL
104 : bvule(13, 4) : BOOL
105 : and(103, 104) : BOOL
106 : ite(105, 37, 37) : BV:8
107 : ite(102, 37, 106) : BV:8
108 : ite(99, 31, 107) : BV:8
109 : ite(96, 25, 108) : BV:8
110 : ite(93, 19, 109) : BV:8
111 : bvconcat(46, 68, 90, 110) : BV:32
112 : lambda(10, 111) : FUNCTION[BV:32 -> BV:32]
113 : map(9, 112) : MAP[BV:32 -> BV:32]
114 : sym_const(113) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda4083 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 3 { 0x3 +1.35e129 } : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(4, 1) : BV:32
6 : bvadd(3, 5) : BV:32
7 : bvule(2, 6) : BOOL
8 : 1703603503 { 0x658aed2f +1.8536326e76 } : BV:32
9 : bvule(6, 8) : BOOL
10 : and(7, 9) : BOOL
11 : 1 { 0x1 } : BV:8
12 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
13 : bvule(12, 6) : BOOL
14 : 1703603507 { 0x658aed33 +1.8536374e76 } : BV:32
15 : bvule(6, 14) : BOOL
16 : and(13, 15) : BOOL
17 : 4 { 0x4 } : BV:8
18 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
19 : bvule(18, 6) : BOOL
20 : 3726783631 { 0xde22348f -568183665 -1.26722896e61 } : BV:32
21 : bvule(6, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 5 { 0x5 } : BV:8
24 : 1703603508 { 0x658aed34 +1.8536386e76 } : BV:32
25 : bvule(24, 6) : BOOL
26 : 3726783627 { 0xde22348b -568183669 -1.26722848e61 } : BV:32
27 : bvule(6, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 0 { 0x0 } : BV:8
30 : 3726783632 { 0xde223490 -568183664 -1.26722908e61 } : BV:32
31 : bvule(30, 6) : BOOL
32 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
33 : bvule(6, 32) : BOOL
34 : and(31, 33) : BOOL
35 : ite(34, 29, 29) : BV:8
36 : ite(28, 29, 35) : BV:8
37 : ite(22, 23, 36) : BV:8
38 : ite(16, 17, 37) : BV:8
39 : ite(10, 11, 38) : BV:8
40 : 2 { 0x2 +1.23e129 } : BV:32
41 : bvadd(40, 5) : BV:32
42 : bvule(2, 41) : BOOL
43 : bvule(41, 8) : BOOL
44 : and(42, 43) : BOOL
45 : bvule(12, 41) : BOOL
46 : bvule(41, 14) : BOOL
47 : and(45, 46) : BOOL
48 : bvule(18, 41) : BOOL
49 : bvule(41, 20) : BOOL
50 : and(48, 49) : BOOL
51 : bvule(24, 41) : BOOL
52 : bvule(41, 26) : BOOL
53 : and(51, 52) : BOOL
54 : bvule(30, 41) : BOOL
55 : bvule(41, 32) : BOOL
56 : and(54, 55) : BOOL
57 : ite(56, 29, 29) : BV:8
58 : ite(53, 29, 57) : BV:8
59 : ite(50, 23, 58) : BV:8
60 : ite(47, 17, 59) : BV:8
61 : ite(44, 11, 60) : BV:8
62 : 1 { 0x1 +1.11e129 } : BV:32
63 : bvadd(62, 5) : BV:32
64 : bvule(2, 63) : BOOL
65 : bvule(63, 8) : BOOL
66 : and(64, 65) : BOOL
67 : bvule(12, 63) : BOOL
68 : bvule(63, 14) : BOOL
69 : and(67, 68) : BOOL
70 : bvule(18, 63) : BOOL
71 : bvule(63, 20) : BOOL
72 : and(70, 71) : BOOL
73 : bvule(24, 63) : BOOL
74 : bvule(63, 26) : BOOL
75 : and(73, 74) : BOOL
76 : bvule(30, 63) : BOOL
77 : bvule(63, 32) : BOOL
78 : and(76, 77) : BOOL
79 : ite(78, 29, 29) : BV:8
80 : ite(75, 29, 79) : BV:8
81 : ite(72, 23, 80) : BV:8
82 : ite(69, 17, 81) : BV:8
83 : ite(66, 11, 82) : BV:8
84 : bvule(2, 5) : BOOL
85 : bvule(5, 8) : BOOL
86 : and(84, 85) : BOOL
87 : bvule(12, 5) : BOOL
88 : bvule(5, 14) : BOOL
89 : and(87, 88) : BOOL
90 : bvule(18, 5) : BOOL
91 : bvule(5, 20) : BOOL
92 : and(90, 91) : BOOL
93 : bvule(24, 5) : BOOL
94 : bvule(5, 26) : BOOL
95 : and(93, 94) : BOOL
96 : bvule(30, 5) : BOOL
97 : bvule(5, 32) : BOOL
98 : and(96, 97) : BOOL
99 : ite(98, 29, 29) : BV:8
100 : ite(95, 29, 99) : BV:8
101 : ite(92, 23, 100) : BV:8
102 : ite(89, 17, 101) : BV:8
103 : ite(86, 11, 102) : BV:8
104 : bvconcat(39, 61, 83, 103) : BV:32
105 : lambda(1, 104) : FUNCTION[BV:32 -> BV:32]
106 : sym_const(105) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform421 : BV:32
4 : Lambda4123 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4124 : BV:32
7 : 1661468088 { 0x6307fdb8 +1.6243038e71 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1703603503 ] -> 1, [ 1703603504; 1703603507 ] -> 4, [ 1703603508; 3726783627 ] -> 0, [ 3726783628; 3726783631 ] -> 5, [ 3726783632; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda4088 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : 3 { 0x3 +1.35e129 } : BV:32
10 : 4 { 0x4 +1.47e129 } : BV:32
11 : bvmul(10, 1) : BV:32
12 : bvadd(9, 11) : BV:32
13 : bvule(2, 12) : BOOL
14 : 1703603503 { 0x658aed2f +1.8536326e76 } : BV:32
15 : bvule(12, 14) : BOOL
16 : and(13, 15) : BOOL
17 : 1 { 0x1 } : BV:8
18 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
19 : bvule(18, 12) : BOOL
20 : 1703603507 { 0x658aed33 +1.8536374e76 } : BV:32
21 : bvule(12, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 4 { 0x4 } : BV:8
24 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
25 : bvule(24, 12) : BOOL
26 : 3726783631 { 0xde22348f -568183665 -1.26722896e61 } : BV:32
27 : bvule(12, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 5 { 0x5 } : BV:8
30 : 1703603508 { 0x658aed34 +1.8536386e76 } : BV:32
31 : bvule(30, 12) : BOOL
32 : 3726783627 { 0xde22348b -568183669 -1.26722848e61 } : BV:32
33 : bvule(12, 32) : BOOL
34 : and(31, 33) : BOOL
35 : 0 { 0x0 } : BV:8
36 : 3726783632 { 0xde223490 -568183664 -1.26722908e61 } : BV:32
37 : bvule(36, 12) : BOOL
38 : bvule(12, 4) : BOOL
39 : and(37, 38) : BOOL
40 : ite(39, 35, 35) : BV:8
41 : ite(34, 35, 40) : BV:8
42 : ite(28, 29, 41) : BV:8
43 : ite(22, 23, 42) : BV:8
44 : ite(16, 17, 43) : BV:8
45 : 2 { 0x2 +1.23e129 } : BV:32
46 : bvadd(45, 11) : BV:32
47 : bvule(2, 46) : BOOL
48 : bvule(46, 14) : BOOL
49 : and(47, 48) : BOOL
50 : bvule(18, 46) : BOOL
51 : bvule(46, 20) : BOOL
52 : and(50, 51) : BOOL
53 : bvule(24, 46) : BOOL
54 : bvule(46, 26) : BOOL
55 : and(53, 54) : BOOL
56 : bvule(30, 46) : BOOL
57 : bvule(46, 32) : BOOL
58 : and(56, 57) : BOOL
59 : bvule(36, 46) : BOOL
60 : bvule(46, 4) : BOOL
61 : and(59, 60) : BOOL
62 : ite(61, 35, 35) : BV:8
63 : ite(58, 35, 62) : BV:8
64 : ite(55, 29, 63) : BV:8
65 : ite(52, 23, 64) : BV:8
66 : ite(49, 17, 65) : BV:8
67 : 1 { 0x1 +1.11e129 } : BV:32
68 : bvadd(67, 11) : BV:32
69 : bvule(2, 68) : BOOL
70 : bvule(68, 14) : BOOL
71 : and(69, 70) : BOOL
72 : bvule(18, 68) : BOOL
73 : bvule(68, 20) : BOOL
74 : and(72, 73) : BOOL
75 : bvule(24, 68) : BOOL
76 : bvule(68, 26) : BOOL
77 : and(75, 76) : BOOL
78 : bvule(30, 68) : BOOL
79 : bvule(68, 32) : BOOL
80 : and(78, 79) : BOOL
81 : bvule(36, 68) : BOOL
82 : bvule(68, 4) : BOOL
83 : and(81, 82) : BOOL
84 : ite(83, 35, 35) : BV:8
85 : ite(80, 35, 84) : BV:8
86 : ite(77, 29, 85) : BV:8
87 : ite(74, 23, 86) : BV:8
88 : ite(71, 17, 87) : BV:8
89 : bvule(2, 11) : BOOL
90 : bvule(11, 14) : BOOL
91 : and(89, 90) : BOOL
92 : bvule(18, 11) : BOOL
93 : bvule(11, 20) : BOOL
94 : and(92, 93) : BOOL
95 : bvule(24, 11) : BOOL
96 : bvule(11, 26) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(30, 11) : BOOL
99 : bvule(11, 32) : BOOL
100 : and(98, 99) : BOOL
101 : bvule(36, 11) : BOOL
102 : bvule(11, 4) : BOOL
103 : and(101, 102) : BOOL
104 : ite(103, 35, 35) : BV:8
105 : ite(100, 35, 104) : BV:8
106 : ite(97, 29, 105) : BV:8
107 : ite(94, 23, 106) : BV:8
108 : ite(91, 17, 107) : BV:8
109 : bvconcat(44, 66, 88, 108) : BV:32
110 : ite(8, 109, 109) : BV:32
111 : lambda(1, 110) : FUNCTION[BV:32 -> BV:32]
112 : sym_const(111) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform420 : BV:32
3 : Lambda4121 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda4122 : BV:32
6 : unit : UNIT
7 : 1136953640 { 0x43c48928 +1.53543567e8 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1703603503 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1703603504; 1703603507 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1703603508; 3726783627 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3726783628; 3726783631 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3726783632; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1703603507 { 0x658aed33 +1.8536374e76 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3726783631 { 0xde22348f -568183665 -1.26722896e61 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3596077930
=counter_example_end
=global nodece 7 num_edges_traversed 0
=global nodece 7 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 8
=global nodece 8 nodece z3v487.ce661.num_edges_traversed0
=global nodece 8 nodece_path
=global nodece 8 nodece_path.graph_edge_composition
(epsilon)
=global nodece 8 nodece_cached_counterexample
=counter_example_begin z3v487.ce661 2496ef90f222981d6b38f320f9f61248
=input.spec-%var-arr-1
1 : Lambda4365 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 15 { 0xf +1.178e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 16 { 0x10 +1.190e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4366 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4368 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 15 { 0xf +1.178e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 16 { 0x10 +1.190e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4369 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 15 ] -> true, [ 16; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda4336 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 15 { 0xf +1.178e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 16 { 0x10 +1.190e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform449 : BV:32
4 : Lambda4372 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4373 : BV:32
7 : 1780718512 { 0x6a239bb0 +1.27818870e85 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 15 ] -> true, [ 16; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2013282660 { 0x78004164 +1.199556e113 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform448 : BV:32
3 : Lambda4370 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda4371 : BV:32
6 : unit : UNIT
7 : 1113285381 { 0x425b6305 +1.71395933e5 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 2013282659 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2013282660; 2013282663 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2013282664; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2013282660 { 0x78004164 +1.199556e113 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2013282663 { 0x78004167 +1.199592e113 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2547458321
=counter_example_end
=global nodece 8 num_edges_traversed 0
=global nodece 8 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 9
=global nodece 9 nodece z3.ce662.num_edges_traversed0
=global nodece 9 nodece_path
=global nodece 9 nodece_path.graph_edge_composition
(epsilon)
=global nodece 9 nodece_cached_counterexample
=counter_example_begin z3.ce662 3277ccc7eb0648fc9a292296cee1a5a
=input.spec-%var-arr-1
1 : Lambda4383 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4384 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4387 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4388 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform453 : BV:32
4 : Lambda4391 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4392 : BV:32
7 : 374790829 { 0x1656daad +1.67854845e173 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda4351 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1 { 0x1 +1.11e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2 { 0x2 +1.23e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2164032760 { 0x80fc84f8 -2130934536 -1.97280788e130 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 215165896 { 0xcd32bc8 +1.64977359e154 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform452 : BV:32
3 : Lambda4389 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda4390 : BV:32
6 : unit : UNIT
7 : 651289781 { 0x26d1e4b5 +1.63979208e206 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 215165895 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 215165896; 215165899 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 215165900; 2164032759 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2164032760; 2164032763 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2164032764; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 215165896 { 0xcd32bc8 +1.64977359e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 215165899 { 0xcd32bcb +1.64977395e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2164032760 { 0x80fc84f8 -2130934536 -1.97280788e130 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2164032763 { 0x80fc84fb -2130934533 -1.97280824e130 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3687942854
=counter_example_end
=global nodece 9 num_edges_traversed 0
=global nodece 9 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 10
=global nodece 10 nodece z3.ce712.num_edges_traversed2
=global nodece 10 nodece_path
=global nodece 10 nodece_path.graph_edge_composition
(epsilon)
=global nodece 10 nodece_cached_counterexample
=counter_example_begin z3.ce712 557c67531196901355fbe8b1d06a67
=input.spec-%var-arr-1
1 : Lambda193 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda194 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda193 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda194 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda172 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda173 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.dst.llvm-%arr
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 318648393 { 0x12fe3049 +1.98584854e166 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1903413019 { 0x7173c71b +1.90451371e99 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
340383979
=counter_example_end
=global nodece 10 num_edges_traversed 2
=global nodece 10 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 11
=global nodece 11 nodece z3v487.ce708.num_edges_traversed2
=global nodece 11 nodece_path
=global nodece 11 nodece_path.graph_edge_composition
(epsilon)
=global nodece 11 nodece_cached_counterexample
=counter_example_begin z3v487.ce708 579d873c92dca7598b766a2cbd3c3f0
=input.spec-%var-arr-1
1 : Lambda207 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda208 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda207 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda208 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda181 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda182 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-%arr
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 211961543 { 0xca246c7 +1.26778495e154 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 67 { 0x43 +1.798e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3721003027 { 0xddca0013 -573964269 -1.57812726e60 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
180861690
=counter_example_end
=global nodece 11 num_edges_traversed 2
=global nodece 11 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 12
=global nodece 12 nodece z3.ce704.num_edges_traversed2
=global nodece 12 nodece_path
=global nodece 12 nodece_path.graph_edge_composition
(epsilon)
=global nodece 12 nodece_cached_counterexample
=counter_example_begin z3.ce704 e13aa4643945b5987267303f0fb9e9b
=input.spec-%var-arr-1
1 : Lambda297 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda298 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda297 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda298 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda276 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda277 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.dst.llvm-%arr
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 961465037 { 0x394ecacd +1.61556398e243 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1067701935 { 0x3fa3d6af +1.27998912e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3670926980
=counter_example_end
=global nodece 12 num_edges_traversed 2
=global nodece 12 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 13
=global nodece 13 nodece z3.ce700.num_edges_traversed2
=global nodece 13 nodece_path
=global nodece 13 nodece_path.graph_edge_composition
(epsilon)
=global nodece 13 nodece_cached_counterexample
=counter_example_begin z3.ce700 172d18b09a76b38960feaf07d78712d
=input.spec-%var-arr-1
1 : Lambda401 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda402 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda401 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda402 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda380 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : ite(3, 2, 128) : BV:32
130 : lambda(1, 129) : FUNCTION[BV:32 -> BV:32]
131 : sym_const(130) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda381 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : lambda(1, 128) : FUNCTION[BV:32 -> BV:32]
130 : sym_const(129) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.dst.llvm-%arr
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1420111171 { 0x54a52d43 +1.29044377e42 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
155419542
=counter_example_end
=global nodece 13 num_edges_traversed 2
=global nodece 13 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 14
=global nodece 14 nodece z3v487.ce692.num_edges_traversed1
=global nodece 14 nodece_path
=global nodece 14 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 14 nodece_cached_counterexample
=counter_example_begin z3v487.ce692 81be669f6bbe1a06ffe4318447474af
=input.spec-%var-arr-1
1 : Lambda4365 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 15 { 0xf +1.178e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 16 { 0x10 +1.190e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4366 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4368 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 15 { 0xf +1.178e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 16 { 0x10 +1.190e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4369 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 15 ] -> true, [ 16; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda4336 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 15 { 0xf +1.178e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 16 { 0x10 +1.190e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform449 : BV:32
4 : Lambda4372 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4373 : BV:32
7 : 1780718512 { 0x6a239bb0 +1.27818870e85 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 15 ] -> true, [ 16; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2013282660 { 0x78004164 +1.199556e113 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform448 : BV:32
3 : Lambda4370 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda4371 : BV:32
6 : unit : UNIT
7 : 1113285381 { 0x425b6305 +1.71395933e5 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 2013282659 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2013282660; 2013282663 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2013282664; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2013282660 { 0x78004164 +1.199556e113 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2013282663 { 0x78004167 +1.199592e113 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2547458321
=counter_example_end
=global nodece 14 num_edges_traversed 1
=global nodece 14 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 15
=global nodece 15 nodece z3.ce688.num_edges_traversed1
=global nodece 15 nodece_path
=global nodece 15 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 15 nodece_cached_counterexample
=counter_example_begin z3.ce688 7a1ae39edfc76986241463b861206f
=input.spec-%var-arr-1
1 : Lambda4383 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4384 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4387 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4388 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform453 : BV:32
4 : Lambda4391 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4392 : BV:32
7 : 374790829 { 0x1656daad +1.67854845e173 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda4351 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1 { 0x1 +1.11e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2 { 0x2 +1.23e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2164032760 { 0x80fc84f8 -2130934536 -1.97280788e130 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 215165896 { 0xcd32bc8 +1.64977359e154 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform452 : BV:32
3 : Lambda4389 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda4390 : BV:32
6 : unit : UNIT
7 : 651289781 { 0x26d1e4b5 +1.63979208e206 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 215165895 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 215165896; 215165899 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 215165900; 2164032759 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2164032760; 2164032763 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2164032764; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 215165896 { 0xcd32bc8 +1.64977359e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 215165899 { 0xcd32bcb +1.64977395e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2164032760 { 0x80fc84f8 -2130934536 -1.97280788e130 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2164032763 { 0x80fc84fb -2130934533 -1.97280824e130 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3687942854
=counter_example_end
=global nodece 15 num_edges_traversed 1
=global nodece 15 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 16
=global nodece 16 nodece z3.ce947.num_edges_traversed1
=global nodece 16 nodece_path
=global nodece 16 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 16 nodece_cached_counterexample
=counter_example_begin z3.ce947 bf3c147c63b4a5d76f23677f2861a85
=input.spec-%var-arr-1
1 : Lambda6014 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda6015 : BV:32
17 : eq(16, 2) : BOOL
18 : bvule(2, 16) : BOOL
19 : bvule(16, 2) : BOOL
20 : and(18, 19) : BOOL
21 : bvule(7, 16) : BOOL
22 : bvule(16, 9) : BOOL
23 : and(21, 22) : BOOL
24 : ite(23, 12, 12) : BOOL
25 : ite(20, 6, 24) : BOOL
26 : and(18, 22) : BOOL
27 : ite(26, 2, 2) : BV:32
28 : ite(25, 2, 27) : BV:32
29 : ite(17, 2, 28) : BV:32
30 : lambda(16, 29) : FUNCTION[BV:32 -> BV:32]
31 : map(15, 30) : MAP[BV:32 -> BV:32]
32 : sym_const(31) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6018 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda6019 : BV:32
17 : bvule(2, 16) : BOOL
18 : bvule(16, 9) : BOOL
19 : and(17, 18) : BOOL
20 : ite(19, 2, 2) : BV:32
21 : lambda(16, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(15, 21) : MAP[BV:32 -> BV:32]
23 : sym_const(22) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform609 : BV:32
4 : Lambda6022 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6023 : BV:32
7 : 726752389 { 0x2b515c85 +1.63563597e215 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda5990 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : bvule(1, 2) : BOOL
6 : and(4, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1 { 0x1 +1.11e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : and(4, 11) : BOOL
17 : ite(16, 2, 2) : BV:32
18 : ite(15, 2, 17) : BV:32
19 : ite(3, 2, 18) : BV:32
20 : lambda(1, 19) : FUNCTION[BV:32 -> BV:32]
21 : sym_const(20) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1207265212 { 0x47f567bc +1.91722822e16 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1007995372 { 0x3c14c9ec +1.16241216e249 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform608 : BV:32
3 : Lambda6020 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda6021 : BV:32
6 : unit : UNIT
7 : 830619005 { 0x31823d7d +1.1750147e228 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1813510832 { 0x6c17fab0 +1.18733787e89 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1007995371 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1007995372; 1007995375 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1007995376; 1207265211 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1207265212; 1207265215 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1207265216; 1813510831 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1813510832; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1007995372 { 0x3c14c9ec +1.16241216e249 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1007995375 { 0x3c14c9ef +1.16241252e249 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1207265212 { 0x47f567bc +1.91722822e16 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1207265215 { 0x47f567bf +1.91722857e16 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1870033691
=counter_example_end
=global nodece 16 num_edges_traversed 1
=global nodece 16 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 17
=global nodece 17 nodece z3v487.ce973.num_edges_traversed1
=global nodece 17 nodece_path
=global nodece 17 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 17 nodece_cached_counterexample
=counter_example_begin z3v487.ce973 2f6d9ff640f94a7bc88d9254204a469
=input.spec-%var-arr-1
1 : Lambda6279 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6280 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 131072 { 0x20000 +1.1562500e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6282 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6283 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda6250 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 3 { 0x3 +1.35e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 4 { 0x4 +1.47e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform641 : BV:32
4 : Lambda6286 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6287 : BV:32
7 : 1663681294 { 0x6329c30e +1.32626509e71 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2868917300 { 0xab003434 -1426049996 -1.159311e215 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform640 : BV:32
3 : Lambda6284 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda6285 : BV:32
6 : unit : UNIT
7 : 1521815919 { 0x5ab5116f +1.41459453e54 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 4288053248 { 0xff968000 -6914048 -1.17578125e128 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 2868917299 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2868917300; 2868917303 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2868917304; 4288053247 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4288053248; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2868917300 { 0xab003434 -1426049996 -1.159311e215 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2868917303 { 0xab003437 -1426049993 -1.159347e215 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3117916090
=counter_example_end
=global nodece 17 num_edges_traversed 1
=global nodece 17 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 18
=global nodece 18 nodece z3.ce974.num_edges_traversed1
=global nodece 18 nodece_path
=global nodece 18 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 18 nodece_cached_counterexample
=counter_example_begin z3.ce974 5fdaf54a93ef81da71ae7a513854ca6d
=input.spec-%var-arr-1
1 : Lambda6297 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8191 { 0x1fff +1.97644e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 8192 { 0x2000 +1.97656e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6298 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6301 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8191 { 0x1fff +1.97644e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 8192 { 0x2000 +1.97656e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6302 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 8191 ] -> true, [ 8192; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform645 : BV:32
4 : Lambda6305 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6306 : BV:32
7 : 852902665 { 0x32d64309 +1.67392075e230 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 8191 ] -> true, [ 8192; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda6265 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 8191 { 0x1fff +1.97644e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 8192 { 0x2000 +1.97656e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1664015024 { 0x632edab0 +1.36604881e71 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3857327648 { 0xe5ea2620 -437639648 -1.82928848e76 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 8192 { 0x2000 +1.97656e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform644 : BV:32
3 : Lambda6303 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda6304 : BV:32
6 : unit : UNIT
7 : 1240028436 { 0x49e95514 +1.82290887e20 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2147483644 { 0x7ffffffc +1.99999952e128 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1664015023 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1664015024; 1664015027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1664015028; 2147483643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483644; 3857327647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3857327648; 3857327651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3857327652; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3857327648 { 0xe5ea2620 -437639648 -1.82928848e76 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3857327651 { 0xe5ea2623 -437639645 -1.82928884e76 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1664015024 { 0x632edab0 +1.36604881e71 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1664015027 { 0x632edab3 +1.36604917e71 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1905141753
=counter_example_end
=global nodece 18 num_edges_traversed 1
=global nodece 18 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 19
=global nodece 19 nodece z3.ce999.num_edges_traversed1
=global nodece 19 nodece_path
=global nodece 19 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 19 nodece_cached_counterexample
=counter_example_begin z3.ce999 54fb291f18cb4662a87f9383f7db13e2
=input.spec-%var-arr-1
1 : Lambda6542 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6543 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6546 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6547 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform673 : BV:32
4 : Lambda6550 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6551 : BV:32
7 : 386664556 { 0x170c086c +1.9400701e175 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda6518 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3257920008 { 0xc22fea08 -1037047288 -1.37432956e5 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2467403048 { 0x93119528 -1827564248 -1.13736438e167 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform672 : BV:32
3 : Lambda6548 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda6549 : BV:32
6 : unit : UNIT
7 : 1947594999 { 0x7415f0f7 +1.17141616e105 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 3318743040 { 0xc5d00000 -976224256 -1.62500000e12 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 2467403047 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2467403048; 2467403051 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2467403052; 3257920007 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3257920008; 3257920011 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3257920012; 3318743039 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3318743040; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2467403048 { 0x93119528 -1827564248 -1.13736438e167 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2467403051 { 0x9311952b -1827564245 -1.13736474e167 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3257920008 { 0xc22fea08 -1037047288 -1.37432956e5 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3257920011 { 0xc22fea0b -1037047285 -1.37432992e5 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1701497763
=counter_example_end
=global nodece 19 num_edges_traversed 1
=global nodece 19 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 20
=global nodece 20 nodece z3.ce1025.num_edges_traversed1
=global nodece 20 nodece_path
=global nodece 20 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 20 nodece_cached_counterexample
=counter_example_begin z3.ce1025 dc7d91e8cc837ed96dcd8b3e65c09428
=input.spec-%var-arr-1
1 : Lambda6806 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda6807 : BV:32
17 : eq(16, 2) : BOOL
18 : bvule(2, 16) : BOOL
19 : bvule(16, 4) : BOOL
20 : and(18, 19) : BOOL
21 : bvule(8, 16) : BOOL
22 : bvule(16, 8) : BOOL
23 : and(21, 22) : BOOL
24 : ite(23, 12, 12) : BOOL
25 : ite(20, 7, 24) : BOOL
26 : and(18, 22) : BOOL
27 : ite(26, 2, 2) : BV:32
28 : ite(25, 2, 27) : BV:32
29 : ite(17, 2, 28) : BV:32
30 : lambda(16, 29) : FUNCTION[BV:32 -> BV:32]
31 : map(15, 30) : MAP[BV:32 -> BV:32]
32 : sym_const(31) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6810 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda6811 : BV:32
17 : bvule(2, 16) : BOOL
18 : bvule(16, 8) : BOOL
19 : and(17, 18) : BOOL
20 : ite(19, 2, 2) : BV:32
21 : lambda(16, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(15, 21) : MAP[BV:32 -> BV:32]
23 : sym_const(22) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform705 : BV:32
4 : Lambda6814 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6815 : BV:32
7 : 590381511 { 0x233081c7 +1.37896049e199 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda6782 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(9, 1) : BOOL
11 : bvule(1, 9) : BOOL
12 : and(10, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(7, 8, 14) : BOOL
16 : and(4, 11) : BOOL
17 : ite(16, 2, 2) : BV:32
18 : ite(15, 2, 17) : BV:32
19 : ite(3, 2, 18) : BV:32
20 : lambda(1, 19) : FUNCTION[BV:32 -> BV:32]
21 : sym_const(20) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 676771016 { 0x2856b4c8 +1.67739200e209 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1297909872 { 0x4d5c8870 +1.72291374e27 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform704 : BV:32
3 : Lambda6812 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda6813 : BV:32
6 : unit : UNIT
7 : 147718256 { 0x8ce0070 +1.60938835e146 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 3221225465 { 0xbffffff9 -1073741831 -1.99999916e0 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 676771015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 676771016; 676771019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 676771020; 1297909871 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1297909872; 1297909875 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1297909876; 3221225464 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3221225465; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1297909872 { 0x4d5c8870 +1.72291374e27 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1297909875 { 0x4d5c8873 +1.72291409e27 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 676771016 { 0x2856b4c8 +1.67739200e209 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 676771019 { 0x2856b4cb +1.67739236e209 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
280859793
=counter_example_end
=global nodece 20 num_edges_traversed 1
=global nodece 20 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 21
=global nodece 21 nodece z3.ce1051.num_edges_traversed1
=global nodece 21 nodece_path
=global nodece 21 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 21 nodece_cached_counterexample
=counter_example_begin z3.ce1051 f6427ceea2117d57eeb16f437e51671d
=input.spec-%var-arr-1
1 : Lambda7070 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7071 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda7074 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7075 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform737 : BV:32
4 : Lambda7078 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7079 : BV:32
7 : 474128480 { 0x1c42a060 +1.52051925e185 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda7046 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1938611492 { 0x738cdd24 +1.10049867e104 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2738688268 { 0xa33d110c -1556279028 -1.47708272e199 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform736 : BV:32
3 : Lambda7076 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda7077 : BV:32
6 : unit : UNIT
7 : 648981814 { 0x26aead36 +1.36466097e206 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2080894464 { 0x7c07ee00 +1.6195068e121 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1938611491 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1938611492; 1938611495 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1938611496; 2080894463 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2080894464; 2738688267 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2738688268; 2738688271 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2738688272; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2738688268 { 0xa33d110c -1556279028 -1.47708272e199 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2738688271 { 0xa33d110f -1556279025 -1.47708308e199 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1938611492 { 0x738cdd24 +1.10049867e104 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1938611495 { 0x738cdd27 +1.10049903e104 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2103296320
=counter_example_end
=global nodece 21 num_edges_traversed 1
=global nodece 21 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 22
=global nodece 22 nodece z3.ce1512.num_edges_traversed0
=global nodece 22 nodece_path
=global nodece 22 nodece_path.graph_edge_composition
(epsilon)
=global nodece 22 nodece_cached_counterexample
=counter_example_begin z3.ce1512 a2c089c65488f91dc1af55932f1dfde
=input.spec-%var-arr-1
1 : Lambda15524 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8191 { 0x1fff +1.97644e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 8192 { 0x2000 +1.97656e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda15525 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4096 { 0x1000 +1.48828e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda15528 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8191 { 0x1fff +1.97644e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 8192 { 0x2000 +1.97656e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda15529 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 8191 ] -> true, [ 8192; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1869 : BV:32
4 : Lambda15532 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15533 : BV:32
7 : 436089372 { 0x19fe321c +1.98590421e180 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 8191 ] -> true, [ 8192; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda15500 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 8191 { 0x1fff +1.97644e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 8192 { 0x2000 +1.97656e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1832307988 { 0x6d36cd14 +1.42813348e91 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 736351732 { 0x2be3d5f4 +1.77996683e216 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 8192 { 0x2000 +1.97656e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform1868 : BV:32
3 : Lambda15530 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda15531 : BV:32
6 : unit : UNIT
7 : 1721945381 { 0x66a2cd25 +1.27188551e78 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 736351731 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 736351732; 736351735 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 736351736; 1832307987 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1832307988; 1832307991 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1832307992; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 736351732 { 0x2be3d5f4 +1.77996683e216 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 736351735 { 0x2be3d5f7 +1.77996718e216 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1832307988 { 0x6d36cd14 +1.42813348e91 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1832307991 { 0x6d36cd17 +1.42813384e91 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3322691793
=counter_example_end
=global nodece 22 num_edges_traversed 0
=global nodece 22 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 23
=global nodece 23 nodece z3v487.ce1513.num_edges_traversed0
=global nodece 23 nodece_path
=global nodece 23 nodece_path.graph_edge_composition
(epsilon)
=global nodece 23 nodece_cached_counterexample
=counter_example_begin z3v487.ce1513 7d5c9635292734be7fec40c340b6fa4a
=input.spec-%var-arr-1
1 : Lambda15544 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda15545 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda15547 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda15548 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda15507 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1873 : BV:32
4 : Lambda15551 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15552 : BV:32
7 : 1751882707 { 0x686b9bd3 +1.84069287e81 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 318767104 { 0x13000000 +1.0e167 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform1872 : BV:32
3 : Lambda15549 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda15550 : BV:32
6 : unit : UNIT
7 : 346854534 { 0x14ac9486 +1.34828257e170 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 318767103 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 318767104; 318767107 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 318767108; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 318767104 { 0x13000000 +1.0e167 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 318767107 { 0x13000003 +1.35e167 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
232967652
=counter_example_end
=global nodece 23 num_edges_traversed 0
=global nodece 23 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 24
=global nodece 24 nodece z3.ce1555.num_edges_traversed3
=global nodece 24 nodece_path
=global nodece 24 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 24 nodece_cached_counterexample
=counter_example_begin z3.ce1555 4ec56b662e191a7f76e74338114f3cf3
=nextpc_const.1
1 : 1152738630 { 0x44b56546 +1.41715312e10 } : BV:32
=input.spec-%var-arr-1
1 : Lambda193 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda194 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda193 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda194 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda172 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda173 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.dst.llvm-%arr
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 123 , m_adder -> 42), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1152738630 , 1000 , 8 ) -> 44611973, () -> 1256379572, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 44611973 { 0x2a8b985 +1.31816160e134 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 318648393 { 0x12fe3049 +1.98584854e166 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1903413019 { 0x7173c71b +1.90451371e99 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 123 , m_adder -> 42), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2543366799
=counter_example_end
=global nodece 24 num_edges_traversed 3
=global nodece 24 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 25
=global nodece 25 nodece z3v487.ce1552.num_edges_traversed3
=global nodece 25 nodece_path
=global nodece 25 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 25 nodece_cached_counterexample
=counter_example_begin z3v487.ce1552 7af9c5f22718aa89106bfecea17129
=nextpc_const.1
1 : 367123356 { 0x15e1db9c +1.76451444e172 } : BV:32
=input.spec-%var-arr-1
1 : Lambda207 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda208 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda207 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda208 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda181 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda182 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-%arr
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 67 , m_adder -> 72), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 367123356 , 1000 , 8 ) -> 1441260588, () -> 1296167743, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1441260588 { 0x55e7e42c +1.81165075e44 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 211961543 { 0xca246c7 +1.26778495e154 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 67 { 0x43 +1.798e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3721003027 { 0xddca0013 -573964269 -1.57812726e60 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 67 , m_adder -> 72), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2976315566
=counter_example_end
=global nodece 25 num_edges_traversed 3
=global nodece 25 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 26
=global nodece 26 nodece z3.ce1549.num_edges_traversed3
=global nodece 26 nodece_path
=global nodece 26 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 26 nodece_cached_counterexample
=counter_example_begin z3.ce1549 e8dc67c56e218812cdc7aed77f6435c
=nextpc_const.1
1 : 1073352277 { 0x3ffa0e55 +1.95356237e0 } : BV:32
=input.spec-%var-arr-1
1 : Lambda297 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda298 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda297 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda298 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda276 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda277 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.dst.llvm-%arr
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 19 , m_adder -> 184), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1073352277 , 1000 , 8 ) -> 1081939524, () -> 880111664, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1081939524 { 0x407d1644 +1.97724199e1 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 961465037 { 0x394ecacd +1.61556398e243 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1067701935 { 0x3fa3d6af +1.27998912e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 19 , m_adder -> 184), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
427727256
=counter_example_end
=global nodece 26 num_edges_traversed 3
=global nodece 26 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 27
=global nodece 27 nodece z3.ce1546.num_edges_traversed3
=global nodece 27 nodece_path
=global nodece 27 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 27 nodece_cached_counterexample
=counter_example_begin z3.ce1546 146a3904787f9b8db60281e4bbf32ef
=nextpc_const.1
1 : 2108327072 { 0x7daa84a0 +1.33217239e124 } : BV:32
=input.spec-%var-arr-1
1 : Lambda401 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda402 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda401 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda402 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda380 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : ite(3, 2, 128) : BV:32
130 : lambda(1, 129) : FUNCTION[BV:32 -> BV:32]
131 : sym_const(130) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda381 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : lambda(1, 128) : FUNCTION[BV:32 -> BV:32]
130 : sym_const(129) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%n
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.dst.llvm-%arr
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 162 , m_adder -> 65), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 2108327072 , 1000 , 8 ) -> 1049355574, () -> 437850325, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform7 : BV:32
4 : Lambda14 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda15 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1049355574 { 0x3e8be536 +1.9293246e254 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1420111171 { 0x54a52d43 +1.29044377e42 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 162 , m_adder -> 65), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1399876490
=counter_example_end
=global nodece 27 num_edges_traversed 3
=global nodece 27 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 28
=global nodece 28 nodece z3v487.ce1543.num_edges_traversed2
=global nodece 28 nodece_path
=global nodece 28 nodece_path.graph_edge_composition
(epsilon)
=global nodece 28 nodece_cached_counterexample
=counter_example_begin z3v487.ce1543 aab6e5b59d23ee6ecddc46a0dc5bea
=nextpc_const.1
1 : 1831795636 { 0x6d2efbb4 +1.36705636e91 } : BV:32
=input.spec-%var-arr-1
1 : Lambda4365 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 15 { 0xf +1.178e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 16 { 0x10 +1.190e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4366 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4368 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 15 { 0xf +1.178e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 16 { 0x10 +1.190e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4369 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 15 ] -> true, [ 16; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda4336 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 15 { 0xf +1.178e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 16 { 0x10 +1.190e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform449 : BV:32
4 : Lambda4372 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4373 : BV:32
7 : 1780718512 { 0x6a239bb0 +1.27818870e85 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 15 ] -> true, [ 16; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2013282660 { 0x78004164 +1.199556e113 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 70 , m_adder -> 120), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1831795636 , 1000 , 8 ) -> 1664408637, () -> 1361929169, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform448 : BV:32
3 : Lambda4370 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda4371 : BV:32
6 : unit : UNIT
7 : 1113285381 { 0x425b6305 +1.71395933e5 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1664408637 { 0x6334dc3d +1.41297113e71 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 2013282659 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2013282660; 2013282663 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2013282664; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2013282660 { 0x78004164 +1.199556e113 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2013282663 { 0x78004167 +1.199592e113 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 70 , m_adder -> 120), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3039550037
=counter_example_end
=global nodece 28 num_edges_traversed 2
=global nodece 28 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 29
=global nodece 29 nodece z3.ce1540.num_edges_traversed2
=global nodece 29 nodece_path
=global nodece 29 nodece_path.graph_edge_composition
(epsilon)
=global nodece 29 nodece_cached_counterexample
=counter_example_begin z3.ce1540 f5a49fdd84c72f2c1c3a6bfe9b8df667
=nextpc_const.1
1 : 978212546 { 0x3a4e56c2 +1.61202263e245 } : BV:32
=input.spec-%var-arr-1
1 : Lambda4383 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4384 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4387 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4388 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform453 : BV:32
4 : Lambda4391 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4392 : BV:32
7 : 374790829 { 0x1656daad +1.67854845e173 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda4351 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1 { 0x1 +1.11e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2 { 0x2 +1.23e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2164032760 { 0x80fc84f8 -2130934536 -1.97280788e130 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 215165896 { 0xcd32bc8 +1.64977359e154 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 250 , m_adder -> 144), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 978212546 , 1000 , 8 ) -> 183914619, () -> 984337257, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform452 : BV:32
3 : Lambda4389 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda4390 : BV:32
6 : unit : UNIT
7 : 651289781 { 0x26d1e4b5 +1.63979208e206 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 183914619 { 0xaf6507b +1.92433106e150 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 215165895 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 215165896; 215165899 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 215165900; 2164032759 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2164032760; 2164032763 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2164032764; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 215165896 { 0xcd32bc8 +1.64977359e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 215165899 { 0xcd32bcb +1.64977395e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2164032760 { 0x80fc84f8 -2130934536 -1.97280788e130 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2164032763 { 0x80fc84fb -2130934533 -1.97280824e130 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 250 , m_adder -> 144), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2452819898
=counter_example_end
=global nodece 29 num_edges_traversed 2
=global nodece 29 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 30
=global nodece 30 nodece z3.ce1537.num_edges_traversed2
=global nodece 30 nodece_path
=global nodece 30 nodece_path.graph_edge_composition
(epsilon)
=global nodece 30 nodece_cached_counterexample
=counter_example_begin z3.ce1537 e987a37738bd5ff98299868937c947
=nextpc_const.1
1 : 1714886266 { 0x6637167a +1.43037343e77 } : BV:32
=input.spec-%var-arr-1
1 : Lambda6014 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda6015 : BV:32
17 : eq(16, 2) : BOOL
18 : bvule(2, 16) : BOOL
19 : bvule(16, 2) : BOOL
20 : and(18, 19) : BOOL
21 : bvule(7, 16) : BOOL
22 : bvule(16, 9) : BOOL
23 : and(21, 22) : BOOL
24 : ite(23, 12, 12) : BOOL
25 : ite(20, 6, 24) : BOOL
26 : and(18, 22) : BOOL
27 : ite(26, 2, 2) : BV:32
28 : ite(25, 2, 27) : BV:32
29 : ite(17, 2, 28) : BV:32
30 : lambda(16, 29) : FUNCTION[BV:32 -> BV:32]
31 : map(15, 30) : MAP[BV:32 -> BV:32]
32 : sym_const(31) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6018 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda6019 : BV:32
17 : bvule(2, 16) : BOOL
18 : bvule(16, 9) : BOOL
19 : and(17, 18) : BOOL
20 : ite(19, 2, 2) : BV:32
21 : lambda(16, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(15, 21) : MAP[BV:32 -> BV:32]
23 : sym_const(22) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform609 : BV:32
4 : Lambda6022 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6023 : BV:32
7 : 726752389 { 0x2b515c85 +1.63563597e215 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda5990 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : bvule(1, 2) : BOOL
6 : and(4, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1 { 0x1 +1.11e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : and(4, 11) : BOOL
17 : ite(16, 2, 2) : BV:32
18 : ite(15, 2, 17) : BV:32
19 : ite(3, 2, 18) : BV:32
20 : lambda(1, 19) : FUNCTION[BV:32 -> BV:32]
21 : sym_const(20) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1207265212 { 0x47f567bc +1.91722822e16 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1007995372 { 0x3c14c9ec +1.16241216e249 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 166 , m_adder -> 184), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1714886266 , 1000 , 8 ) -> 1488923960, () -> 2122892133, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform608 : BV:32
3 : Lambda6020 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda6021 : BV:32
6 : unit : UNIT
7 : 830619005 { 0x31823d7d +1.1750147e228 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1488923960 { 0x58bf2d38 +1.49356746e50 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1007995371 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1007995372; 1007995375 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1007995376; 1207265211 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1207265212; 1207265215 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1207265216; 1813510831 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1813510832; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1007995372 { 0x3c14c9ec +1.16241216e249 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1007995375 { 0x3c14c9ef +1.16241252e249 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1207265212 { 0x47f567bc +1.91722822e16 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1207265215 { 0x47f567bf +1.91722857e16 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 166 , m_adder -> 184), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1438759359
=counter_example_end
=global nodece 30 num_edges_traversed 2
=global nodece 30 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 31
=global nodece 31 nodece z3v487.ce1534.num_edges_traversed2
=global nodece 31 nodece_path
=global nodece 31 nodece_path.graph_edge_composition
(epsilon)
=global nodece 31 nodece_cached_counterexample
=counter_example_begin z3v487.ce1534 e218c821adf078d75c9c36664f396743
=nextpc_const.1
1 : 1968987030 { 0x755c5b96 +1.72154498e107 } : BV:32
=input.spec-%var-arr-1
1 : Lambda6279 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6280 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 131072 { 0x20000 +1.1562500e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6282 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6283 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda6250 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 3 { 0x3 +1.35e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 4 { 0x4 +1.47e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform641 : BV:32
4 : Lambda6286 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6287 : BV:32
7 : 1663681294 { 0x6329c30e +1.32626509e71 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2868917300 { 0xab003434 -1426049996 -1.159311e215 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 229 , m_adder -> 137), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1968987030 , 1000 , 8 ) -> 2106503917, () -> 1904596272, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform640 : BV:32
3 : Lambda6284 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda6285 : BV:32
6 : unit : UNIT
7 : 1521815919 { 0x5ab5116f +1.41459453e54 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2106503917 { 0x7d8eb2ed +1.11483538e124 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 2868917299 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2868917300; 2868917303 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2868917304; 4288053247 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4288053248; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2868917300 { 0xab003434 -1426049996 -1.159311e215 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2868917303 { 0xab003437 -1426049993 -1.159347e215 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 229 , m_adder -> 137), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3529822574
=counter_example_end
=global nodece 31 num_edges_traversed 2
=global nodece 31 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 32
=global nodece 32 nodece z3.ce1531.num_edges_traversed2
=global nodece 32 nodece_path
=global nodece 32 nodece_path.graph_edge_composition
(epsilon)
=global nodece 32 nodece_cached_counterexample
=counter_example_begin z3.ce1531 689e97a586ed540d9c83eb78c52c5b7
=nextpc_const.1
1 : 1421025910 { 0x54b32276 +1.39948916e42 } : BV:32
=input.spec-%var-arr-1
1 : Lambda6297 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8191 { 0x1fff +1.97644e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 8192 { 0x2000 +1.97656e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6298 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6301 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8191 { 0x1fff +1.97644e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 8192 { 0x2000 +1.97656e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6302 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 8191 ] -> true, [ 8192; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform645 : BV:32
4 : Lambda6305 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6306 : BV:32
7 : 852902665 { 0x32d64309 +1.67392075e230 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 8191 ] -> true, [ 8192; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda6265 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 8191 { 0x1fff +1.97644e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 8192 { 0x2000 +1.97656e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1664015024 { 0x632edab0 +1.36604881e71 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3857327648 { 0xe5ea2620 -437639648 -1.82928848e76 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 8192 { 0x2000 +1.97656e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 182 , m_adder -> 160), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1421025910 , 1000 , 8 ) -> 522639394, () -> 895426906, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform644 : BV:32
3 : Lambda6303 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda6304 : BV:32
6 : unit : UNIT
7 : 1240028436 { 0x49e95514 +1.82290887e20 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 522639394 { 0x1f26d822 +1.30347084e191 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1664015023 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1664015024; 1664015027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1664015028; 2147483643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483644; 3857327647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3857327648; 3857327651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3857327652; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3857327648 { 0xe5ea2620 -437639648 -1.82928848e76 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3857327651 { 0xe5ea2623 -437639645 -1.82928884e76 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1664015024 { 0x632edab0 +1.36604881e71 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1664015027 { 0x632edab3 +1.36604917e71 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 182 , m_adder -> 160), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2913692349
=counter_example_end
=global nodece 32 num_edges_traversed 2
=global nodece 32 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 33
=global nodece 33 nodece z3.ce1528.num_edges_traversed2
=global nodece 33 nodece_path
=global nodece 33 nodece_path.graph_edge_composition
(epsilon)
=global nodece 33 nodece_cached_counterexample
=counter_example_begin z3.ce1528 366aeee2c77e13f27cd9b47875cfe
=nextpc_const.1
1 : 963198888 { 0x39693fa8 +1.82225513e243 } : BV:32
=input.spec-%var-arr-1
1 : Lambda6542 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6543 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6546 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6547 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform673 : BV:32
4 : Lambda6550 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6551 : BV:32
7 : 386664556 { 0x170c086c +1.9400701e175 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda6518 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3257920008 { 0xc22fea08 -1037047288 -1.37432956e5 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2467403048 { 0x93119528 -1827564248 -1.13736438e167 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 74 , m_adder -> 29), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 963198888 , 1000 , 8 ) -> 1529615662, () -> 759038358, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform672 : BV:32
3 : Lambda6548 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda6549 : BV:32
6 : unit : UNIT
7 : 1947594999 { 0x7415f0f7 +1.17141616e105 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1529615662 { 0x5b2c152e +1.34439635e55 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 2467403047 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2467403048; 2467403051 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2467403052; 3257920007 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3257920008; 3257920011 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3257920012; 3318743039 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3318743040; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2467403048 { 0x93119528 -1827564248 -1.13736438e167 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2467403051 { 0x9311952b -1827564245 -1.13736474e167 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3257920008 { 0xc22fea08 -1037047288 -1.37432956e5 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3257920011 { 0xc22fea0b -1037047285 -1.37432992e5 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 74 , m_adder -> 29), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1067409863
=counter_example_end
=global nodece 33 num_edges_traversed 2
=global nodece 33 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 34
=global nodece 34 nodece z3.ce1525.num_edges_traversed2
=global nodece 34 nodece_path
=global nodece 34 nodece_path.graph_edge_composition
(epsilon)
=global nodece 34 nodece_cached_counterexample
=counter_example_begin z3.ce1525 bfc2c3683fd9f9b8ad4dab2aba28c94
=nextpc_const.1
1 : 1378548981 { 0x522afcf5 +1.33584463e37 } : BV:32
=input.spec-%var-arr-1
1 : Lambda6806 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda6807 : BV:32
17 : eq(16, 2) : BOOL
18 : bvule(2, 16) : BOOL
19 : bvule(16, 4) : BOOL
20 : and(18, 19) : BOOL
21 : bvule(8, 16) : BOOL
22 : bvule(16, 8) : BOOL
23 : and(21, 22) : BOOL
24 : ite(23, 12, 12) : BOOL
25 : ite(20, 7, 24) : BOOL
26 : and(18, 22) : BOOL
27 : ite(26, 2, 2) : BV:32
28 : ite(25, 2, 27) : BV:32
29 : ite(17, 2, 28) : BV:32
30 : lambda(16, 29) : FUNCTION[BV:32 -> BV:32]
31 : map(15, 30) : MAP[BV:32 -> BV:32]
32 : sym_const(31) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6810 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda6811 : BV:32
17 : bvule(2, 16) : BOOL
18 : bvule(16, 8) : BOOL
19 : and(17, 18) : BOOL
20 : ite(19, 2, 2) : BV:32
21 : lambda(16, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(15, 21) : MAP[BV:32 -> BV:32]
23 : sym_const(22) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform705 : BV:32
4 : Lambda6814 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6815 : BV:32
7 : 590381511 { 0x233081c7 +1.37896049e199 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda6782 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(9, 1) : BOOL
11 : bvule(1, 9) : BOOL
12 : and(10, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(7, 8, 14) : BOOL
16 : and(4, 11) : BOOL
17 : ite(16, 2, 2) : BV:32
18 : ite(15, 2, 17) : BV:32
19 : ite(3, 2, 18) : BV:32
20 : lambda(1, 19) : FUNCTION[BV:32 -> BV:32]
21 : sym_const(20) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 676771016 { 0x2856b4c8 +1.67739200e209 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1297909872 { 0x4d5c8870 +1.72291374e27 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 173 , m_adder -> 81), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1378548981 , 1000 , 8 ) -> 266441022, () -> 1653606083, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform704 : BV:32
3 : Lambda6812 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda6813 : BV:32
6 : unit : UNIT
7 : 147718256 { 0x8ce0070 +1.60938835e146 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 266441022 { 0xfe1913e +1.76224493e160 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 676771015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 676771016; 676771019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 676771020; 1297909871 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1297909872; 1297909875 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1297909876; 3221225464 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3221225465; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1297909872 { 0x4d5c8870 +1.72291374e27 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1297909875 { 0x4d5c8873 +1.72291409e27 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 676771016 { 0x2856b4c8 +1.67739200e209 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 676771019 { 0x2856b4cb +1.67739236e209 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 173 , m_adder -> 81), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
672241109
=counter_example_end
=global nodece 34 num_edges_traversed 2
=global nodece 34 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 35
=global nodece 35 nodece z3.ce1522.num_edges_traversed2
=global nodece 35 nodece_path
=global nodece 35 nodece_path.graph_edge_composition
(epsilon)
=global nodece 35 nodece_cached_counterexample
=counter_example_begin z3.ce1522 f59e9ca6ac173590c7f2d56853438b88
=nextpc_const.1
1 : 348143736 { 0x14c04078 +1.50196743e170 } : BV:32
=input.spec-%var-arr-1
1 : Lambda7070 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7071 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda7074 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7075 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform737 : BV:32
4 : Lambda7078 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7079 : BV:32
7 : 474128480 { 0x1c42a060 +1.52051925e185 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda7046 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1938611492 { 0x738cdd24 +1.10049867e104 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2738688268 { 0xa33d110c -1556279028 -1.47708272e199 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 194 , m_adder -> 222), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 348143736 , 1000 , 8 ) -> 947958781, () -> 501589596, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform736 : BV:32
3 : Lambda7076 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda7077 : BV:32
6 : unit : UNIT
7 : 648981814 { 0x26aead36 +1.36466097e206 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 947958781 { 0x3880b3fd +1.549280e242 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1938611491 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1938611492; 1938611495 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1938611496; 2080894463 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2080894464; 2738688267 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2738688268; 2738688271 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2738688272; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2738688268 { 0xa33d110c -1556279028 -1.47708272e199 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2738688271 { 0xa33d110f -1556279025 -1.47708308e199 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1938611492 { 0x738cdd24 +1.10049867e104 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1938611495 { 0x738cdd27 +1.10049903e104 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 194 , m_adder -> 222), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2124831892
=counter_example_end
=global nodece 35 num_edges_traversed 2
=global nodece 35 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 36
=global nodece 36 nodece z3v487.ce1804.num_edges_traversed1
=global nodece 36 nodece_path
=global nodece 36 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 36 nodece_cached_counterexample
=counter_example_begin z3v487.ce1804 bdb3eb91caa3e87c5378f487d75feaa
=nextpc_const.1
1 : 13220665 { 0xc9bb39 +1.57602608e130 } : BV:32
=input.spec-%var-arr-1
1 : Lambda16869 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda16870 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda16872 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda16873 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda16840 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform2005 : BV:32
4 : Lambda16876 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda16877 : BV:32
7 : 1432208032 { 0x555dc2a0 +1.73250198e43 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 128 { 0x80 +1.1525e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 52 , m_adder -> 7), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 13220665 , 1000 , 8 ) -> 1199676058, () -> 1748565898, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform2004 : BV:32
3 : Lambda16874 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda16875 : BV:32
6 : unit : UNIT
7 : 2042346735 { 0x79bbbcef +1.46670329e116 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1199676058 { 0x47819a9a +1.1253056e16 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 127 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 128; 131 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 132; 2147483641 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483642; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 128 { 0x80 +1.1525e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 131 { 0x83 +1.1561e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 52 , m_adder -> 7), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1818940883
=counter_example_end
=global nodece 36 num_edges_traversed 1
=global nodece 36 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 37
=global nodece 37 nodece z3.ce1828.num_edges_traversed1
=global nodece 37 nodece_path
=global nodece 37 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 37 nodece_cached_counterexample
=counter_example_begin z3.ce1828 c79f40544768d76f4148f25b52a1a332
=nextpc_const.1
1 : 670991477 { 0x27fe8475 +1.98841726e208 } : BV:32
=input.spec-%var-arr-1
1 : Lambda17132 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda17133 : BV:32
17 : eq(16, 2) : BOOL
18 : bvule(2, 16) : BOOL
19 : bvule(16, 2) : BOOL
20 : and(18, 19) : BOOL
21 : bvule(7, 16) : BOOL
22 : bvule(16, 9) : BOOL
23 : and(21, 22) : BOOL
24 : ite(23, 12, 12) : BOOL
25 : ite(20, 6, 24) : BOOL
26 : and(18, 22) : BOOL
27 : ite(26, 2, 2) : BV:32
28 : ite(25, 2, 27) : BV:32
29 : ite(17, 2, 28) : BV:32
30 : lambda(16, 29) : FUNCTION[BV:32 -> BV:32]
31 : map(15, 30) : MAP[BV:32 -> BV:32]
32 : sym_const(31) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda17136 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda17137 : BV:32
17 : bvule(2, 16) : BOOL
18 : bvule(16, 9) : BOOL
19 : and(17, 18) : BOOL
20 : ite(19, 2, 2) : BV:32
21 : lambda(16, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(15, 21) : MAP[BV:32 -> BV:32]
23 : sym_const(22) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform2037 : BV:32
4 : Lambda17140 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda17141 : BV:32
7 : 573732464 { 0x22327670 +1.39423942e197 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda17108 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : bvule(1, 2) : BOOL
6 : and(4, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1 { 0x1 +1.11e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : and(4, 11) : BOOL
17 : ite(16, 2, 2) : BV:32
18 : ite(15, 2, 17) : BV:32
19 : ite(3, 2, 18) : BV:32
20 : lambda(1, 19) : FUNCTION[BV:32 -> BV:32]
21 : sym_const(20) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 121932844 { 0x7448c2c +1.53552770e143 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3093756324 { 0xb866f9a4 -1201210972 -1.80449342e241 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 136 , m_adder -> 54), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 670991477 , 1000 , 8 ) -> 1727686483, () -> 2010448588, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform2036 : BV:32
3 : Lambda17138 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda17139 : BV:32
6 : unit : UNIT
7 : 737784561 { 0x2bf9b2f1 +1.95077335e216 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1727686483 { 0x66fa6753 +1.95627820e78 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 121932843 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 121932844; 121932847 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 121932848; 1185939448 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1185939449; 3093756323 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3093756324; 3093756327 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3093756328; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3093756324 { 0xb866f9a4 -1201210972 -1.80449342e241 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3093756327 { 0xb866f9a7 -1201210969 -1.80449378e241 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 121932844 { 0x7448c2c +1.53552770e143 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 121932847 { 0x7448c2f +1.53552806e143 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 136 , m_adder -> 54), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3418726991
=counter_example_end
=global nodece 37 num_edges_traversed 1
=global nodece 37 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 38
=global nodece 38 nodece z3v487.ce2234.num_edges_traversed0
=global nodece 38 nodece_path
=global nodece 38 nodece_path.graph_edge_composition
(epsilon)
=global nodece 38 nodece_cached_counterexample
=counter_example_begin z3v487.ce2234 f327bf937b1498dd5d83d3d872eb272
=input.spec-%var-arr-1
1 : Lambda26910 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 524288 { 0x80000 +1.6250000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda26911 : BV:32
18 : eq(17, 2) : BOOL
19 : 1502396483 { 0x598cc043 +1.9961736e52 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : 1502396480 { 0x598cc040 +1.9961700e52 } : BV:32
24 : eq(22, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1502396481 { 0x598cc041 +1.9961712e52 } : BV:32
27 : eq(22, 26) : BOOL
28 : 1502396482 { 0x598cc042 +1.9961724e52 } : BV:32
29 : eq(22, 28) : BOOL
30 : eq(22, 19) : BOOL
31 : 5 { 0x5 } : BV:8
32 : ite(30, 25, 31) : BV:8
33 : ite(29, 25, 32) : BV:8
34 : ite(27, 25, 33) : BV:8
35 : ite(24, 25, 34) : BV:8
36 : bvadd(28, 21) : BV:32
37 : eq(36, 23) : BOOL
38 : eq(36, 26) : BOOL
39 : eq(36, 28) : BOOL
40 : eq(36, 19) : BOOL
41 : ite(40, 25, 31) : BV:8
42 : ite(39, 25, 41) : BV:8
43 : ite(38, 25, 42) : BV:8
44 : ite(37, 25, 43) : BV:8
45 : bvadd(26, 21) : BV:32
46 : eq(45, 23) : BOOL
47 : eq(45, 26) : BOOL
48 : eq(45, 28) : BOOL
49 : eq(45, 19) : BOOL
50 : ite(49, 25, 31) : BV:8
51 : ite(48, 25, 50) : BV:8
52 : ite(47, 25, 51) : BV:8
53 : ite(46, 25, 52) : BV:8
54 : bvadd(23, 21) : BV:32
55 : eq(54, 23) : BOOL
56 : eq(54, 26) : BOOL
57 : eq(54, 28) : BOOL
58 : eq(54, 19) : BOOL
59 : ite(58, 25, 31) : BV:8
60 : ite(57, 25, 59) : BV:8
61 : ite(56, 25, 60) : BV:8
62 : ite(55, 25, 61) : BV:8
63 : bvconcat(35, 44, 53, 62) : BV:32
64 : ite(18, 2, 63) : BV:32
65 : lambda(17, 64) : FUNCTION[BV:32 -> BV:32]
66 : map(16, 65) : MAP[BV:32 -> BV:32]
67 : sym_const(66) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1502396480 { 0x598cc040 +1.9961700e52 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda26913 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 524288 { 0x80000 +1.6250000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda26914 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 1502396483 { 0x598cc043 +1.9961736e52 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : 1502396480 { 0x598cc040 +1.9961700e52 } : BV:32
32 : eq(30, 31) : BOOL
33 : 0 { 0x0 } : BV:8
34 : 1502396481 { 0x598cc041 +1.9961712e52 } : BV:32
35 : eq(30, 34) : BOOL
36 : 1502396482 { 0x598cc042 +1.9961724e52 } : BV:32
37 : eq(30, 36) : BOOL
38 : eq(30, 27) : BOOL
39 : 5 { 0x5 } : BV:8
40 : ite(38, 33, 39) : BV:8
41 : ite(37, 33, 40) : BV:8
42 : ite(35, 33, 41) : BV:8
43 : ite(32, 33, 42) : BV:8
44 : bvadd(36, 29) : BV:32
45 : eq(44, 31) : BOOL
46 : eq(44, 34) : BOOL
47 : eq(44, 36) : BOOL
48 : eq(44, 27) : BOOL
49 : ite(48, 33, 39) : BV:8
50 : ite(47, 33, 49) : BV:8
51 : ite(46, 33, 50) : BV:8
52 : ite(45, 33, 51) : BV:8
53 : bvadd(34, 29) : BV:32
54 : eq(53, 31) : BOOL
55 : eq(53, 34) : BOOL
56 : eq(53, 36) : BOOL
57 : eq(53, 27) : BOOL
58 : ite(57, 33, 39) : BV:8
59 : ite(56, 33, 58) : BV:8
60 : ite(55, 33, 59) : BV:8
61 : ite(54, 33, 60) : BV:8
62 : bvadd(31, 29) : BV:32
63 : eq(62, 31) : BOOL
64 : eq(62, 34) : BOOL
65 : eq(62, 36) : BOOL
66 : eq(62, 27) : BOOL
67 : ite(66, 33, 39) : BV:8
68 : ite(65, 33, 67) : BV:8
69 : ite(64, 33, 68) : BV:8
70 : ite(63, 33, 69) : BV:8
71 : bvconcat(43, 52, 61, 70) : BV:32
72 : ite(18, 2, 71) : BV:32
73 : ite(26, 71, 72) : BV:32
74 : ite(18, 2, 73) : BV:32
75 : lambda(17, 74) : FUNCTION[BV:32 -> BV:32]
76 : map(16, 75) : MAP[BV:32 -> BV:32]
77 : sym_const(76) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 524287 ] -> true, [ 524288; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda26895 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 524288 { 0x80000 +1.6250000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 1502396483 { 0x598cc043 +1.9961736e52 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : 1502396480 { 0x598cc040 +1.9961700e52 } : BV:32
22 : eq(20, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 1502396481 { 0x598cc041 +1.9961712e52 } : BV:32
25 : eq(20, 24) : BOOL
26 : 1502396482 { 0x598cc042 +1.9961724e52 } : BV:32
27 : eq(20, 26) : BOOL
28 : eq(20, 17) : BOOL
29 : 5 { 0x5 } : BV:8
30 : ite(28, 23, 29) : BV:8
31 : ite(27, 23, 30) : BV:8
32 : ite(25, 23, 31) : BV:8
33 : ite(22, 23, 32) : BV:8
34 : bvadd(26, 19) : BV:32
35 : eq(34, 21) : BOOL
36 : eq(34, 24) : BOOL
37 : eq(34, 26) : BOOL
38 : eq(34, 17) : BOOL
39 : ite(38, 23, 29) : BV:8
40 : ite(37, 23, 39) : BV:8
41 : ite(36, 23, 40) : BV:8
42 : ite(35, 23, 41) : BV:8
43 : bvadd(24, 19) : BV:32
44 : eq(43, 21) : BOOL
45 : eq(43, 24) : BOOL
46 : eq(43, 26) : BOOL
47 : eq(43, 17) : BOOL
48 : ite(47, 23, 29) : BV:8
49 : ite(46, 23, 48) : BV:8
50 : ite(45, 23, 49) : BV:8
51 : ite(44, 23, 50) : BV:8
52 : bvadd(21, 19) : BV:32
53 : eq(52, 21) : BOOL
54 : eq(52, 24) : BOOL
55 : eq(52, 26) : BOOL
56 : eq(52, 17) : BOOL
57 : ite(56, 23, 29) : BV:8
58 : ite(55, 23, 57) : BV:8
59 : ite(54, 23, 58) : BV:8
60 : ite(53, 23, 59) : BV:8
61 : bvconcat(33, 42, 51, 60) : BV:32
62 : ite(3, 2, 61) : BV:32
63 : ite(16, 61, 62) : BV:32
64 : ite(3, 2, 63) : BV:32
65 : lambda(1, 64) : FUNCTION[BV:32 -> BV:32]
66 : sym_const(65) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3305 : BV:32
4 : Lambda26917 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda26918 : BV:32
7 : 941944884 { 0x3824f034 +1.28858041e241 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 524287 ] -> true, [ 524288; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda26897 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 1502396483 { 0x598cc043 +1.9961736e52 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : 1502396480 { 0x598cc040 +1.9961700e52 } : BV:32
9 : eq(7, 8) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1502396481 { 0x598cc041 +1.9961712e52 } : BV:32
12 : eq(7, 11) : BOOL
13 : 1502396482 { 0x598cc042 +1.9961724e52 } : BV:32
14 : eq(7, 13) : BOOL
15 : eq(7, 4) : BOOL
16 : 5 { 0x5 } : BV:8
17 : ite(15, 10, 16) : BV:8
18 : ite(14, 10, 17) : BV:8
19 : ite(12, 10, 18) : BV:8
20 : ite(9, 10, 19) : BV:8
21 : bvadd(13, 6) : BV:32
22 : eq(21, 8) : BOOL
23 : eq(21, 11) : BOOL
24 : eq(21, 13) : BOOL
25 : eq(21, 4) : BOOL
26 : ite(25, 10, 16) : BV:8
27 : ite(24, 10, 26) : BV:8
28 : ite(23, 10, 27) : BV:8
29 : ite(22, 10, 28) : BV:8
30 : bvadd(11, 6) : BV:32
31 : eq(30, 8) : BOOL
32 : eq(30, 11) : BOOL
33 : eq(30, 13) : BOOL
34 : eq(30, 4) : BOOL
35 : ite(34, 10, 16) : BV:8
36 : ite(33, 10, 35) : BV:8
37 : ite(32, 10, 36) : BV:8
38 : ite(31, 10, 37) : BV:8
39 : bvadd(8, 6) : BV:32
40 : eq(39, 8) : BOOL
41 : eq(39, 11) : BOOL
42 : eq(39, 13) : BOOL
43 : eq(39, 4) : BOOL
44 : ite(43, 10, 16) : BV:8
45 : ite(42, 10, 44) : BV:8
46 : ite(41, 10, 45) : BV:8
47 : ite(40, 10, 46) : BV:8
48 : bvconcat(20, 29, 38, 47) : BV:32
49 : ite(3, 2, 48) : BV:32
50 : lambda(1, 49) : FUNCTION[BV:32 -> BV:32]
51 : sym_const(50) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform3304 : BV:32
3 : Lambda26915 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda26916 : BV:32
6 : unit : UNIT
7 : 585775038 { 0x22ea37be +1.82982611e198 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1073741828; 1502396479 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1502396480; 1502396483 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1502396484; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1502396479 ] -> 5, [ 1502396480; 1502396483 ] -> 0, [ 1502396484; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1073741827 { 0x40000003 +1.35e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3168259634
=counter_example_end
=global nodece 38 num_edges_traversed 0
=global nodece 38 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 39
=global nodece 39 nodece z3v487.ce2305.num_edges_traversed1
=global nodece 39 nodece_path
=global nodece 39 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 39 nodece_cached_counterexample
=counter_example_begin z3v487.ce2305 3bd0c2a028f0c4c92369dcc2f4351840
=input.spec-%var-arr-1
1 : Lambda27062 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4194303 { 0x3fffff +1.49999988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27063 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1908513724 { 0x71c19bbc +1.51256513e100 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27065 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4194303 { 0x3fffff +1.49999988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27066 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4194303 ] -> true, [ 4194304; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27044 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 4194303 { 0x3fffff +1.49999988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3321 : BV:32
4 : Lambda27069 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27070 : BV:32
7 : 1294342530 { 0x4d261982 +1.29765343e27 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform3322 : BV:32
3 : Lambda27071 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda27072 : BV:32
6 : unit : UNIT
7 : 1501428774 { 0x597dfc26 +1.98425745e51 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sym_const(12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4194303 ] -> true, [ 4194304; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3324 : BV:32
5 : Lambda27075 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27076 : BV:32
8 : 1501428774 { 0x597dfc26 +1.98425745e51 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1083179007 ] -> 0, [ 1083179008; 1083179008 ] -> 0, [ 1083179009; 1083179009 ] -> 0, [ 1083179010; 1083179010 ] -> 0, [ 1083179011; 1083179011 ] -> 0, [ 1083179012; 1083179012 ] -> 0, [ 1083179013; 1083179013 ] -> 0, [ 1083179014; 1083179014 ] -> 0, [ 1083179015; 1083179015 ] -> 0, [ 1083179016; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3326 : BV:32
5 : Lambda27079 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27080 : BV:32
8 : 1501428774 { 0x597dfc26 +1.98425745e51 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1459627796 { 0x57002714 +1.119256e47 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147577952 { 0x80017060 -2147389344 -1.1124191e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3328 : BV:32
5 : Lambda27083 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27084 : BV:32
8 : 1501428774 { 0x597dfc26 +1.98425745e51 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 815258123 { 0x3097da0b +1.18634164e226 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1083179008 { 0x40900000 +1.12500000e2 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1846023104 { 0x6e0813c0 +1.6310272e93 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 356534730 { 0x154049ca +1.50225186e171 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1083179007 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1083179008; 1083179015 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1083179016; 1459627795 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1459627796; 1459627799 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1459627800; 1908513723 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1908513724; 2147577951 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147577952; 2147577955 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147577956; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1846023104 { 0x6e0813c0 +1.6310272e93 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 878505521 { 0x345cee31 +1.72601902e233 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1083179008 { 0x40900000 +1.12500000e2 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1637097973 { 0x619421f5 +1.15728628e68 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 1908513724 { 0x71c19bbc +1.51256513e100 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 1083179007 ] -> 0, [ 1083179008; 1083179015 ] -> 201, [ 1083179016; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 878505521 { 0x345cee31 +1.72601902e233 } : BV:32
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 1083179007 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1083179008; 1083179015 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1083179016; 1459627795 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1459627796; 1459627799 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1459627800; 1908513723 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1908513724; 2147577951 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147577952; 2147577955 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147577956; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 356534730 { 0x154049ca +1.50225186e171 } : COUNT
=input.dst.llvm-%call.Lfor.body%2%d
1 : 1083179008 { 0x40900000 +1.12500000e2 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 1083179012 { 0x40900004 +1.12500047e2 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 1908513724 { 0x71c19bbc +1.51256513e100 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 1083179008 { 0x40900000 +1.12500000e2 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 1908513724 { 0x71c19bbc +1.51256513e100 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 1083179008 { 0x40900000 +1.12500000e2 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1083179008 { 0x40900000 +1.12500000e2 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 1083179012 { 0x40900004 +1.12500047e2 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 1083179008 { 0x40900000 +1.12500000e2 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147577952 { 0x80017060 -2147389344 -1.1124191e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147577955 { 0x80017063 -2147389341 -1.1124227e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1459627796 { 0x57002714 +1.119256e47 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1459627799 { 0x57002717 +1.119292e47 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
269035824
=counter_example_end
=global nodece 39 num_edges_traversed 1
=global nodece 39 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 40
=global nodece 40 nodece z3v487.ce2336.num_edges_traversed2
=global nodece 40 nodece_path
=global nodece 40 nodece_path.graph_edge_composition
(epsilon)
=global nodece 40 nodece_cached_counterexample
=counter_example_begin z3v487.ce2336 458777fe525722dc753c28606dd31bf
=input.spec-%var-arr-1
1 : Lambda27062 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4194303 { 0x3fffff +1.49999988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27063 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1908513724 { 0x71c19bbc +1.51256513e100 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27065 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4194303 { 0x3fffff +1.49999988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27066 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4194303 ] -> true, [ 4194304; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27044 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 4194303 { 0x3fffff +1.49999988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3321 : BV:32
4 : Lambda27069 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27070 : BV:32
7 : 1294342530 { 0x4d261982 +1.29765343e27 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4194303 ] -> true, [ 4194304; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1083179007 ] -> 0, [ 1083179008; 1083179008 ] -> 0, [ 1083179009; 1083179009 ] -> 0, [ 1083179010; 1083179010 ] -> 0, [ 1083179011; 1083179011 ] -> 0, [ 1083179012; 1083179012 ] -> 0, [ 1083179013; 1083179013 ] -> 0, [ 1083179014; 1083179014 ] -> 0, [ 1083179015; 1083179015 ] -> 0, [ 1083179016; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1459627796 { 0x57002714 +1.119256e47 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147577952 { 0x80017060 -2147389344 -1.1124191e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3328 : BV:32
5 : Lambda27083 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27084 : BV:32
8 : 1501428774 { 0x597dfc26 +1.98425745e51 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 815258123 { 0x3097da0b +1.18634164e226 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 356534730 { 0x154049ca +1.50225186e171 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1083179007 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1083179008; 1083179015 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1083179016; 1459627795 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1459627796; 1459627799 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1459627800; 1908513723 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1908513724; 2147577951 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147577952; 2147577955 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147577956; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1846023104 { 0x6e0813c0 +1.6310272e93 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 878505521 { 0x345cee31 +1.72601902e233 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1083179008 { 0x40900000 +1.12500000e2 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1637097973 { 0x619421f5 +1.15728628e68 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147577952 { 0x80017060 -2147389344 -1.1124191e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147577955 { 0x80017063 -2147389341 -1.1124227e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1459627796 { 0x57002714 +1.119256e47 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1459627799 { 0x57002717 +1.119292e47 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
269035824
=counter_example_end
=global nodece 40 num_edges_traversed 2
=global nodece 40 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 41
=global nodece 41 nodece z3v487.ce2340.num_edges_traversed3
=global nodece 41 nodece_path
=global nodece 41 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 41 nodece_cached_counterexample
=counter_example_begin z3v487.ce2340 a265e7945b84a1f41fbea1d408167
=nextpc_const.1
1 : 423301165 { 0x193b102d +1.46143114e179 } : BV:32
=input.spec-%var-arr-1
1 : Lambda27062 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4194303 { 0x3fffff +1.49999988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27063 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1908513724 { 0x71c19bbc +1.51256513e100 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27065 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4194303 { 0x3fffff +1.49999988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27066 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4194303 ] -> true, [ 4194304; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27044 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 4194303 { 0x3fffff +1.49999988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3321 : BV:32
4 : Lambda27069 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27070 : BV:32
7 : 1294342530 { 0x4d261982 +1.29765343e27 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4194303 ] -> true, [ 4194304; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1083179007 ] -> 0, [ 1083179008; 1083179008 ] -> 0, [ 1083179009; 1083179009 ] -> 0, [ 1083179010; 1083179010 ] -> 0, [ 1083179011; 1083179011 ] -> 0, [ 1083179012; 1083179012 ] -> 0, [ 1083179013; 1083179013 ] -> 0, [ 1083179014; 1083179014 ] -> 0, [ 1083179015; 1083179015 ] -> 0, [ 1083179016; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1459627796 { 0x57002714 +1.119256e47 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147577952 { 0x80017060 -2147389344 -1.1124191e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 34 , m_adder -> 231), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 423301165 , 1000 , 8 ) -> 1257741413, () -> 930957182, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3328 : BV:32
5 : Lambda27083 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27084 : BV:32
8 : 1501428774 { 0x597dfc26 +1.98425745e51 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 815258123 { 0x3097da0b +1.18634164e226 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1257741413 { 0x4af79c65 +1.93446028e22 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 356534730 { 0x154049ca +1.50225186e171 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1083179007 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1083179008; 1083179015 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1083179016; 1459627795 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1459627796; 1459627799 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1459627800; 1908513723 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1908513724; 2147577951 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147577952; 2147577955 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147577956; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1846023104 { 0x6e0813c0 +1.6310272e93 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1083179007 ] -> 0, [ 1083179008; 1083179008 ] -> 0, [ 1083179009; 1083179009 ] -> 0, [ 1083179010; 1083179010 ] -> 0, [ 1083179011; 1083179011 ] -> 0, [ 1083179012; 1083179012 ] -> 0, [ 1083179013; 1083179013 ] -> 0, [ 1083179014; 1083179014 ] -> 0, [ 1083179015; 1083179015 ] -> 0, [ 1083179016; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 878505521 { 0x345cee31 +1.72601902e233 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1083179008 { 0x40900000 +1.12500000e2 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1637097973 { 0x619421f5 +1.15728628e68 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147577952 { 0x80017060 -2147389344 -1.1124191e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147577955 { 0x80017063 -2147389341 -1.1124227e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1459627796 { 0x57002714 +1.119256e47 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1459627799 { 0x57002717 +1.119292e47 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 34 , m_adder -> 231), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2054198660
=counter_example_end
=global nodece 41 num_edges_traversed 3
=global nodece 41 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 42
=global nodece 42 nodece z3v487.ce2358.num_edges_traversed1
=global nodece 42 nodece_path
=global nodece 42 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 42 nodece_cached_counterexample
=counter_example_begin z3v487.ce2358 dbae135d29b068d3209dc55fd0939bd0
=input.spec-%var-arr-1
1 : Lambda27208 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27209 : BV:32
18 : eq(17, 2) : BOOL
19 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
24 : eq(22, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
27 : eq(22, 26) : BOOL
28 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
29 : eq(22, 28) : BOOL
30 : eq(22, 19) : BOOL
31 : 5 { 0x5 } : BV:8
32 : ite(30, 25, 31) : BV:8
33 : ite(29, 25, 32) : BV:8
34 : ite(27, 25, 33) : BV:8
35 : ite(24, 25, 34) : BV:8
36 : bvadd(28, 21) : BV:32
37 : eq(36, 23) : BOOL
38 : eq(36, 26) : BOOL
39 : eq(36, 28) : BOOL
40 : eq(36, 19) : BOOL
41 : ite(40, 25, 31) : BV:8
42 : ite(39, 25, 41) : BV:8
43 : ite(38, 25, 42) : BV:8
44 : ite(37, 25, 43) : BV:8
45 : bvadd(26, 21) : BV:32
46 : eq(45, 23) : BOOL
47 : eq(45, 26) : BOOL
48 : eq(45, 28) : BOOL
49 : eq(45, 19) : BOOL
50 : ite(49, 25, 31) : BV:8
51 : ite(48, 25, 50) : BV:8
52 : ite(47, 25, 51) : BV:8
53 : ite(46, 25, 52) : BV:8
54 : bvadd(23, 21) : BV:32
55 : eq(54, 23) : BOOL
56 : eq(54, 26) : BOOL
57 : eq(54, 28) : BOOL
58 : eq(54, 19) : BOOL
59 : ite(58, 25, 31) : BV:8
60 : ite(57, 25, 59) : BV:8
61 : ite(56, 25, 60) : BV:8
62 : ite(55, 25, 61) : BV:8
63 : bvconcat(35, 44, 53, 62) : BV:32
64 : ite(18, 2, 63) : BV:32
65 : lambda(17, 64) : FUNCTION[BV:32 -> BV:32]
66 : map(16, 65) : MAP[BV:32 -> BV:32]
67 : sym_const(66) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27211 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27212 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
32 : eq(30, 31) : BOOL
33 : 0 { 0x0 } : BV:8
34 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
35 : eq(30, 34) : BOOL
36 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
37 : eq(30, 36) : BOOL
38 : eq(30, 27) : BOOL
39 : 5 { 0x5 } : BV:8
40 : ite(38, 33, 39) : BV:8
41 : ite(37, 33, 40) : BV:8
42 : ite(35, 33, 41) : BV:8
43 : ite(32, 33, 42) : BV:8
44 : bvadd(36, 29) : BV:32
45 : eq(44, 31) : BOOL
46 : eq(44, 34) : BOOL
47 : eq(44, 36) : BOOL
48 : eq(44, 27) : BOOL
49 : ite(48, 33, 39) : BV:8
50 : ite(47, 33, 49) : BV:8
51 : ite(46, 33, 50) : BV:8
52 : ite(45, 33, 51) : BV:8
53 : bvadd(34, 29) : BV:32
54 : eq(53, 31) : BOOL
55 : eq(53, 34) : BOOL
56 : eq(53, 36) : BOOL
57 : eq(53, 27) : BOOL
58 : ite(57, 33, 39) : BV:8
59 : ite(56, 33, 58) : BV:8
60 : ite(55, 33, 59) : BV:8
61 : ite(54, 33, 60) : BV:8
62 : bvadd(31, 29) : BV:32
63 : eq(62, 31) : BOOL
64 : eq(62, 34) : BOOL
65 : eq(62, 36) : BOOL
66 : eq(62, 27) : BOOL
67 : ite(66, 33, 39) : BV:8
68 : ite(65, 33, 67) : BV:8
69 : ite(64, 33, 68) : BV:8
70 : ite(63, 33, 69) : BV:8
71 : bvconcat(43, 52, 61, 70) : BV:32
72 : ite(18, 2, 71) : BV:32
73 : ite(26, 71, 72) : BV:32
74 : ite(18, 2, 73) : BV:32
75 : lambda(17, 74) : FUNCTION[BV:32 -> BV:32]
76 : map(16, 75) : MAP[BV:32 -> BV:32]
77 : sym_const(76) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27193 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
22 : eq(20, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
25 : eq(20, 24) : BOOL
26 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
27 : eq(20, 26) : BOOL
28 : eq(20, 17) : BOOL
29 : 5 { 0x5 } : BV:8
30 : ite(28, 23, 29) : BV:8
31 : ite(27, 23, 30) : BV:8
32 : ite(25, 23, 31) : BV:8
33 : ite(22, 23, 32) : BV:8
34 : bvadd(26, 19) : BV:32
35 : eq(34, 21) : BOOL
36 : eq(34, 24) : BOOL
37 : eq(34, 26) : BOOL
38 : eq(34, 17) : BOOL
39 : ite(38, 23, 29) : BV:8
40 : ite(37, 23, 39) : BV:8
41 : ite(36, 23, 40) : BV:8
42 : ite(35, 23, 41) : BV:8
43 : bvadd(24, 19) : BV:32
44 : eq(43, 21) : BOOL
45 : eq(43, 24) : BOOL
46 : eq(43, 26) : BOOL
47 : eq(43, 17) : BOOL
48 : ite(47, 23, 29) : BV:8
49 : ite(46, 23, 48) : BV:8
50 : ite(45, 23, 49) : BV:8
51 : ite(44, 23, 50) : BV:8
52 : bvadd(21, 19) : BV:32
53 : eq(52, 21) : BOOL
54 : eq(52, 24) : BOOL
55 : eq(52, 26) : BOOL
56 : eq(52, 17) : BOOL
57 : ite(56, 23, 29) : BV:8
58 : ite(55, 23, 57) : BV:8
59 : ite(54, 23, 58) : BV:8
60 : ite(53, 23, 59) : BV:8
61 : bvconcat(33, 42, 51, 60) : BV:32
62 : ite(3, 2, 61) : BV:32
63 : ite(16, 61, 62) : BV:32
64 : ite(3, 2, 63) : BV:32
65 : lambda(1, 64) : FUNCTION[BV:32 -> BV:32]
66 : sym_const(65) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3344 : BV:32
4 : Lambda27215 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27216 : BV:32
7 : 206804960 { 0xc5397e0 +1.65307235e153 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform3345 : BV:32
3 : Lambda27217 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda27218 : BV:32
6 : unit : UNIT
7 : 1024418844 { 0x3d0f641c +1.12024259e251 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sym_const(12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3347 : BV:32
5 : Lambda27221 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27222 : BV:32
8 : 1024418844 { 0x3d0f641c +1.12024259e251 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 262143 ] -> 5, [ 262144; 262144 ] -> 0, [ 262145; 262145 ] -> 0, [ 262146; 262146 ] -> 0, [ 262147; 262147 ] -> 0, [ 262148; 262148 ] -> 0, [ 262149; 262149 ] -> 0, [ 262150; 262150 ] -> 0, [ 262151; 262151 ] -> 0, [ 262152; 151086423 ] -> 5, [ 151086424; 151086427 ] -> 0, [ 151086428; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda27195 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
9 : eq(7, 8) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
12 : eq(7, 11) : BOOL
13 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
14 : eq(7, 13) : BOOL
15 : eq(7, 4) : BOOL
16 : 5 { 0x5 } : BV:8
17 : ite(15, 10, 16) : BV:8
18 : ite(14, 10, 17) : BV:8
19 : ite(12, 10, 18) : BV:8
20 : ite(9, 10, 19) : BV:8
21 : bvadd(13, 6) : BV:32
22 : eq(21, 8) : BOOL
23 : eq(21, 11) : BOOL
24 : eq(21, 13) : BOOL
25 : eq(21, 4) : BOOL
26 : ite(25, 10, 16) : BV:8
27 : ite(24, 10, 26) : BV:8
28 : ite(23, 10, 27) : BV:8
29 : ite(22, 10, 28) : BV:8
30 : bvadd(11, 6) : BV:32
31 : eq(30, 8) : BOOL
32 : eq(30, 11) : BOOL
33 : eq(30, 13) : BOOL
34 : eq(30, 4) : BOOL
35 : ite(34, 10, 16) : BV:8
36 : ite(33, 10, 35) : BV:8
37 : ite(32, 10, 36) : BV:8
38 : ite(31, 10, 37) : BV:8
39 : bvadd(8, 6) : BV:32
40 : eq(39, 8) : BOOL
41 : eq(39, 11) : BOOL
42 : eq(39, 13) : BOOL
43 : eq(39, 4) : BOOL
44 : ite(43, 10, 16) : BV:8
45 : ite(42, 10, 44) : BV:8
46 : ite(41, 10, 45) : BV:8
47 : ite(40, 10, 46) : BV:8
48 : bvconcat(20, 29, 38, 47) : BV:32
49 : ite(3, 2, 48) : BV:32
50 : lambda(1, 49) : FUNCTION[BV:32 -> BV:32]
51 : sym_const(50) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3349 : BV:32
5 : Lambda27225 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27226 : BV:32
8 : 1024418844 { 0x3d0f641c +1.12024259e251 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1074268356 { 0x400808c4 +1.6276750e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 524408 { 0x80078 +1.6251430e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3351 : BV:32
5 : Lambda27229 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27230 : BV:32
8 : 1024418844 { 0x3d0f641c +1.12024259e251 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1267708389 { 0x4b8fb1e5 +1.12261641e24 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 938352589 { 0x37ee1fcd +1.86034548e240 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1597681358 { 0x5f3aaece +1.45845961e63 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 262143 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 262144; 262151 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 262152; 524407 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524408; 524411 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524412; 151086423 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 151086424; 151086427 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 151086428; 1074268355 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1074268356; 1074268359 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1074268360; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 938352589 { 0x37ee1fcd +1.86034548e240 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 151086423 ] -> 5, [ 151086424; 151086427 ] -> 0, [ 151086428; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1615418225 { 0x60495371 +1.57285892e65 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 528039360 { 0x1f793dc0 +1.94719696e191 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 262143 ] -> 5, [ 262144; 262151 ] -> 205, [ 262152; 151086423 ] -> 5, [ 151086424; 151086427 ] -> 0, [ 151086428; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1615418225 { 0x60495371 +1.57285892e65 } : BV:32
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 262143 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 262144; 262151 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 262152; 524407 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524408; 524411 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524412; 151086423 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 151086424; 151086427 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 151086428; 1074268355 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1074268356; 1074268359 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1074268360; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 1597681358 { 0x5f3aaece +1.45845961e63 } : COUNT
=input.dst.llvm-%call.Lfor.body%2%d
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 262148 { 0x40004 +1.3125047e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 262148 { 0x40004 +1.3125047e129 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 524408 { 0x80078 +1.6251430e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 524411 { 0x8007b +1.6251466e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1074268356 { 0x400808c4 +1.6276750e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1074268359 { 0x400808c7 +1.6276786e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3484526175
=counter_example_end
=global nodece 42 num_edges_traversed 1
=global nodece 42 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 43
=global nodece 43 nodece z3v487.ce2389.num_edges_traversed2
=global nodece 43 nodece_path
=global nodece 43 nodece_path.graph_edge_composition
(epsilon)
=global nodece 43 nodece_cached_counterexample
=counter_example_begin z3v487.ce2389 81abb7c68ac2c08088abc25ae7b39d4e
=input.spec-%var-arr-1
1 : Lambda27208 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27209 : BV:32
18 : eq(17, 2) : BOOL
19 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
24 : eq(22, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
27 : eq(22, 26) : BOOL
28 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
29 : eq(22, 28) : BOOL
30 : eq(22, 19) : BOOL
31 : 5 { 0x5 } : BV:8
32 : ite(30, 25, 31) : BV:8
33 : ite(29, 25, 32) : BV:8
34 : ite(27, 25, 33) : BV:8
35 : ite(24, 25, 34) : BV:8
36 : bvadd(28, 21) : BV:32
37 : eq(36, 23) : BOOL
38 : eq(36, 26) : BOOL
39 : eq(36, 28) : BOOL
40 : eq(36, 19) : BOOL
41 : ite(40, 25, 31) : BV:8
42 : ite(39, 25, 41) : BV:8
43 : ite(38, 25, 42) : BV:8
44 : ite(37, 25, 43) : BV:8
45 : bvadd(26, 21) : BV:32
46 : eq(45, 23) : BOOL
47 : eq(45, 26) : BOOL
48 : eq(45, 28) : BOOL
49 : eq(45, 19) : BOOL
50 : ite(49, 25, 31) : BV:8
51 : ite(48, 25, 50) : BV:8
52 : ite(47, 25, 51) : BV:8
53 : ite(46, 25, 52) : BV:8
54 : bvadd(23, 21) : BV:32
55 : eq(54, 23) : BOOL
56 : eq(54, 26) : BOOL
57 : eq(54, 28) : BOOL
58 : eq(54, 19) : BOOL
59 : ite(58, 25, 31) : BV:8
60 : ite(57, 25, 59) : BV:8
61 : ite(56, 25, 60) : BV:8
62 : ite(55, 25, 61) : BV:8
63 : bvconcat(35, 44, 53, 62) : BV:32
64 : ite(18, 2, 63) : BV:32
65 : lambda(17, 64) : FUNCTION[BV:32 -> BV:32]
66 : map(16, 65) : MAP[BV:32 -> BV:32]
67 : sym_const(66) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27211 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27212 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
32 : eq(30, 31) : BOOL
33 : 0 { 0x0 } : BV:8
34 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
35 : eq(30, 34) : BOOL
36 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
37 : eq(30, 36) : BOOL
38 : eq(30, 27) : BOOL
39 : 5 { 0x5 } : BV:8
40 : ite(38, 33, 39) : BV:8
41 : ite(37, 33, 40) : BV:8
42 : ite(35, 33, 41) : BV:8
43 : ite(32, 33, 42) : BV:8
44 : bvadd(36, 29) : BV:32
45 : eq(44, 31) : BOOL
46 : eq(44, 34) : BOOL
47 : eq(44, 36) : BOOL
48 : eq(44, 27) : BOOL
49 : ite(48, 33, 39) : BV:8
50 : ite(47, 33, 49) : BV:8
51 : ite(46, 33, 50) : BV:8
52 : ite(45, 33, 51) : BV:8
53 : bvadd(34, 29) : BV:32
54 : eq(53, 31) : BOOL
55 : eq(53, 34) : BOOL
56 : eq(53, 36) : BOOL
57 : eq(53, 27) : BOOL
58 : ite(57, 33, 39) : BV:8
59 : ite(56, 33, 58) : BV:8
60 : ite(55, 33, 59) : BV:8
61 : ite(54, 33, 60) : BV:8
62 : bvadd(31, 29) : BV:32
63 : eq(62, 31) : BOOL
64 : eq(62, 34) : BOOL
65 : eq(62, 36) : BOOL
66 : eq(62, 27) : BOOL
67 : ite(66, 33, 39) : BV:8
68 : ite(65, 33, 67) : BV:8
69 : ite(64, 33, 68) : BV:8
70 : ite(63, 33, 69) : BV:8
71 : bvconcat(43, 52, 61, 70) : BV:32
72 : ite(18, 2, 71) : BV:32
73 : ite(26, 71, 72) : BV:32
74 : ite(18, 2, 73) : BV:32
75 : lambda(17, 74) : FUNCTION[BV:32 -> BV:32]
76 : map(16, 75) : MAP[BV:32 -> BV:32]
77 : sym_const(76) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27193 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
22 : eq(20, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
25 : eq(20, 24) : BOOL
26 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
27 : eq(20, 26) : BOOL
28 : eq(20, 17) : BOOL
29 : 5 { 0x5 } : BV:8
30 : ite(28, 23, 29) : BV:8
31 : ite(27, 23, 30) : BV:8
32 : ite(25, 23, 31) : BV:8
33 : ite(22, 23, 32) : BV:8
34 : bvadd(26, 19) : BV:32
35 : eq(34, 21) : BOOL
36 : eq(34, 24) : BOOL
37 : eq(34, 26) : BOOL
38 : eq(34, 17) : BOOL
39 : ite(38, 23, 29) : BV:8
40 : ite(37, 23, 39) : BV:8
41 : ite(36, 23, 40) : BV:8
42 : ite(35, 23, 41) : BV:8
43 : bvadd(24, 19) : BV:32
44 : eq(43, 21) : BOOL
45 : eq(43, 24) : BOOL
46 : eq(43, 26) : BOOL
47 : eq(43, 17) : BOOL
48 : ite(47, 23, 29) : BV:8
49 : ite(46, 23, 48) : BV:8
50 : ite(45, 23, 49) : BV:8
51 : ite(44, 23, 50) : BV:8
52 : bvadd(21, 19) : BV:32
53 : eq(52, 21) : BOOL
54 : eq(52, 24) : BOOL
55 : eq(52, 26) : BOOL
56 : eq(52, 17) : BOOL
57 : ite(56, 23, 29) : BV:8
58 : ite(55, 23, 57) : BV:8
59 : ite(54, 23, 58) : BV:8
60 : ite(53, 23, 59) : BV:8
61 : bvconcat(33, 42, 51, 60) : BV:32
62 : ite(3, 2, 61) : BV:32
63 : ite(16, 61, 62) : BV:32
64 : ite(3, 2, 63) : BV:32
65 : lambda(1, 64) : FUNCTION[BV:32 -> BV:32]
66 : sym_const(65) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3344 : BV:32
4 : Lambda27215 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27216 : BV:32
7 : 206804960 { 0xc5397e0 +1.65307235e153 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 262143 ] -> 5, [ 262144; 262144 ] -> 0, [ 262145; 262145 ] -> 0, [ 262146; 262146 ] -> 0, [ 262147; 262147 ] -> 0, [ 262148; 262148 ] -> 0, [ 262149; 262149 ] -> 0, [ 262150; 262150 ] -> 0, [ 262151; 262151 ] -> 0, [ 262152; 151086423 ] -> 5, [ 151086424; 151086427 ] -> 0, [ 151086428; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda27195 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
9 : eq(7, 8) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
12 : eq(7, 11) : BOOL
13 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
14 : eq(7, 13) : BOOL
15 : eq(7, 4) : BOOL
16 : 5 { 0x5 } : BV:8
17 : ite(15, 10, 16) : BV:8
18 : ite(14, 10, 17) : BV:8
19 : ite(12, 10, 18) : BV:8
20 : ite(9, 10, 19) : BV:8
21 : bvadd(13, 6) : BV:32
22 : eq(21, 8) : BOOL
23 : eq(21, 11) : BOOL
24 : eq(21, 13) : BOOL
25 : eq(21, 4) : BOOL
26 : ite(25, 10, 16) : BV:8
27 : ite(24, 10, 26) : BV:8
28 : ite(23, 10, 27) : BV:8
29 : ite(22, 10, 28) : BV:8
30 : bvadd(11, 6) : BV:32
31 : eq(30, 8) : BOOL
32 : eq(30, 11) : BOOL
33 : eq(30, 13) : BOOL
34 : eq(30, 4) : BOOL
35 : ite(34, 10, 16) : BV:8
36 : ite(33, 10, 35) : BV:8
37 : ite(32, 10, 36) : BV:8
38 : ite(31, 10, 37) : BV:8
39 : bvadd(8, 6) : BV:32
40 : eq(39, 8) : BOOL
41 : eq(39, 11) : BOOL
42 : eq(39, 13) : BOOL
43 : eq(39, 4) : BOOL
44 : ite(43, 10, 16) : BV:8
45 : ite(42, 10, 44) : BV:8
46 : ite(41, 10, 45) : BV:8
47 : ite(40, 10, 46) : BV:8
48 : bvconcat(20, 29, 38, 47) : BV:32
49 : ite(3, 2, 48) : BV:32
50 : lambda(1, 49) : FUNCTION[BV:32 -> BV:32]
51 : sym_const(50) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1074268356 { 0x400808c4 +1.6276750e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 524408 { 0x80078 +1.6251430e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3351 : BV:32
5 : Lambda27229 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27230 : BV:32
8 : 1024418844 { 0x3d0f641c +1.12024259e251 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1267708389 { 0x4b8fb1e5 +1.12261641e24 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1597681358 { 0x5f3aaece +1.45845961e63 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 262143 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 262144; 262151 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 262152; 524407 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524408; 524411 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524412; 151086423 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 151086424; 151086427 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 151086428; 1074268355 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1074268356; 1074268359 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1074268360; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 938352589 { 0x37ee1fcd +1.86034548e240 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1615418225 { 0x60495371 +1.57285892e65 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 528039360 { 0x1f793dc0 +1.94719696e191 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 524408 { 0x80078 +1.6251430e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 524411 { 0x8007b +1.6251466e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1074268356 { 0x400808c4 +1.6276750e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1074268359 { 0x400808c7 +1.6276786e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3484526175
=counter_example_end
=global nodece 43 num_edges_traversed 2
=global nodece 43 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 44
=global nodece 44 nodece z3v487.ce2393.num_edges_traversed3
=global nodece 44 nodece_path
=global nodece 44 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 44 nodece_cached_counterexample
=counter_example_begin z3v487.ce2393 f0acb64f52fbbde85da813677db9247
=nextpc_const.1
1 : 1022341679 { 0x3cefb22f +1.87262523e250 } : BV:32
=input.spec-%var-arr-1
1 : Lambda27208 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27209 : BV:32
18 : eq(17, 2) : BOOL
19 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
24 : eq(22, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
27 : eq(22, 26) : BOOL
28 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
29 : eq(22, 28) : BOOL
30 : eq(22, 19) : BOOL
31 : 5 { 0x5 } : BV:8
32 : ite(30, 25, 31) : BV:8
33 : ite(29, 25, 32) : BV:8
34 : ite(27, 25, 33) : BV:8
35 : ite(24, 25, 34) : BV:8
36 : bvadd(28, 21) : BV:32
37 : eq(36, 23) : BOOL
38 : eq(36, 26) : BOOL
39 : eq(36, 28) : BOOL
40 : eq(36, 19) : BOOL
41 : ite(40, 25, 31) : BV:8
42 : ite(39, 25, 41) : BV:8
43 : ite(38, 25, 42) : BV:8
44 : ite(37, 25, 43) : BV:8
45 : bvadd(26, 21) : BV:32
46 : eq(45, 23) : BOOL
47 : eq(45, 26) : BOOL
48 : eq(45, 28) : BOOL
49 : eq(45, 19) : BOOL
50 : ite(49, 25, 31) : BV:8
51 : ite(48, 25, 50) : BV:8
52 : ite(47, 25, 51) : BV:8
53 : ite(46, 25, 52) : BV:8
54 : bvadd(23, 21) : BV:32
55 : eq(54, 23) : BOOL
56 : eq(54, 26) : BOOL
57 : eq(54, 28) : BOOL
58 : eq(54, 19) : BOOL
59 : ite(58, 25, 31) : BV:8
60 : ite(57, 25, 59) : BV:8
61 : ite(56, 25, 60) : BV:8
62 : ite(55, 25, 61) : BV:8
63 : bvconcat(35, 44, 53, 62) : BV:32
64 : ite(18, 2, 63) : BV:32
65 : lambda(17, 64) : FUNCTION[BV:32 -> BV:32]
66 : map(16, 65) : MAP[BV:32 -> BV:32]
67 : sym_const(66) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27211 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27212 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
32 : eq(30, 31) : BOOL
33 : 0 { 0x0 } : BV:8
34 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
35 : eq(30, 34) : BOOL
36 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
37 : eq(30, 36) : BOOL
38 : eq(30, 27) : BOOL
39 : 5 { 0x5 } : BV:8
40 : ite(38, 33, 39) : BV:8
41 : ite(37, 33, 40) : BV:8
42 : ite(35, 33, 41) : BV:8
43 : ite(32, 33, 42) : BV:8
44 : bvadd(36, 29) : BV:32
45 : eq(44, 31) : BOOL
46 : eq(44, 34) : BOOL
47 : eq(44, 36) : BOOL
48 : eq(44, 27) : BOOL
49 : ite(48, 33, 39) : BV:8
50 : ite(47, 33, 49) : BV:8
51 : ite(46, 33, 50) : BV:8
52 : ite(45, 33, 51) : BV:8
53 : bvadd(34, 29) : BV:32
54 : eq(53, 31) : BOOL
55 : eq(53, 34) : BOOL
56 : eq(53, 36) : BOOL
57 : eq(53, 27) : BOOL
58 : ite(57, 33, 39) : BV:8
59 : ite(56, 33, 58) : BV:8
60 : ite(55, 33, 59) : BV:8
61 : ite(54, 33, 60) : BV:8
62 : bvadd(31, 29) : BV:32
63 : eq(62, 31) : BOOL
64 : eq(62, 34) : BOOL
65 : eq(62, 36) : BOOL
66 : eq(62, 27) : BOOL
67 : ite(66, 33, 39) : BV:8
68 : ite(65, 33, 67) : BV:8
69 : ite(64, 33, 68) : BV:8
70 : ite(63, 33, 69) : BV:8
71 : bvconcat(43, 52, 61, 70) : BV:32
72 : ite(18, 2, 71) : BV:32
73 : ite(26, 71, 72) : BV:32
74 : ite(18, 2, 73) : BV:32
75 : lambda(17, 74) : FUNCTION[BV:32 -> BV:32]
76 : map(16, 75) : MAP[BV:32 -> BV:32]
77 : sym_const(76) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27193 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
22 : eq(20, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
25 : eq(20, 24) : BOOL
26 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
27 : eq(20, 26) : BOOL
28 : eq(20, 17) : BOOL
29 : 5 { 0x5 } : BV:8
30 : ite(28, 23, 29) : BV:8
31 : ite(27, 23, 30) : BV:8
32 : ite(25, 23, 31) : BV:8
33 : ite(22, 23, 32) : BV:8
34 : bvadd(26, 19) : BV:32
35 : eq(34, 21) : BOOL
36 : eq(34, 24) : BOOL
37 : eq(34, 26) : BOOL
38 : eq(34, 17) : BOOL
39 : ite(38, 23, 29) : BV:8
40 : ite(37, 23, 39) : BV:8
41 : ite(36, 23, 40) : BV:8
42 : ite(35, 23, 41) : BV:8
43 : bvadd(24, 19) : BV:32
44 : eq(43, 21) : BOOL
45 : eq(43, 24) : BOOL
46 : eq(43, 26) : BOOL
47 : eq(43, 17) : BOOL
48 : ite(47, 23, 29) : BV:8
49 : ite(46, 23, 48) : BV:8
50 : ite(45, 23, 49) : BV:8
51 : ite(44, 23, 50) : BV:8
52 : bvadd(21, 19) : BV:32
53 : eq(52, 21) : BOOL
54 : eq(52, 24) : BOOL
55 : eq(52, 26) : BOOL
56 : eq(52, 17) : BOOL
57 : ite(56, 23, 29) : BV:8
58 : ite(55, 23, 57) : BV:8
59 : ite(54, 23, 58) : BV:8
60 : ite(53, 23, 59) : BV:8
61 : bvconcat(33, 42, 51, 60) : BV:32
62 : ite(3, 2, 61) : BV:32
63 : ite(16, 61, 62) : BV:32
64 : ite(3, 2, 63) : BV:32
65 : lambda(1, 64) : FUNCTION[BV:32 -> BV:32]
66 : sym_const(65) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3344 : BV:32
4 : Lambda27215 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27216 : BV:32
7 : 206804960 { 0xc5397e0 +1.65307235e153 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 262143 ] -> 5, [ 262144; 262144 ] -> 0, [ 262145; 262145 ] -> 0, [ 262146; 262146 ] -> 0, [ 262147; 262147 ] -> 0, [ 262148; 262148 ] -> 0, [ 262149; 262149 ] -> 0, [ 262150; 262150 ] -> 0, [ 262151; 262151 ] -> 0, [ 262152; 151086423 ] -> 5, [ 151086424; 151086427 ] -> 0, [ 151086428; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : Lambda27195 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 151086427 { 0x901655b +1.1090562e147 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : 151086424 { 0x9016558 +1.1090526e147 } : BV:32
9 : eq(7, 8) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 151086425 { 0x9016559 +1.1090538e147 } : BV:32
12 : eq(7, 11) : BOOL
13 : 151086426 { 0x901655a +1.1090550e147 } : BV:32
14 : eq(7, 13) : BOOL
15 : eq(7, 4) : BOOL
16 : 5 { 0x5 } : BV:8
17 : ite(15, 10, 16) : BV:8
18 : ite(14, 10, 17) : BV:8
19 : ite(12, 10, 18) : BV:8
20 : ite(9, 10, 19) : BV:8
21 : bvadd(13, 6) : BV:32
22 : eq(21, 8) : BOOL
23 : eq(21, 11) : BOOL
24 : eq(21, 13) : BOOL
25 : eq(21, 4) : BOOL
26 : ite(25, 10, 16) : BV:8
27 : ite(24, 10, 26) : BV:8
28 : ite(23, 10, 27) : BV:8
29 : ite(22, 10, 28) : BV:8
30 : bvadd(11, 6) : BV:32
31 : eq(30, 8) : BOOL
32 : eq(30, 11) : BOOL
33 : eq(30, 13) : BOOL
34 : eq(30, 4) : BOOL
35 : ite(34, 10, 16) : BV:8
36 : ite(33, 10, 35) : BV:8
37 : ite(32, 10, 36) : BV:8
38 : ite(31, 10, 37) : BV:8
39 : bvadd(8, 6) : BV:32
40 : eq(39, 8) : BOOL
41 : eq(39, 11) : BOOL
42 : eq(39, 13) : BOOL
43 : eq(39, 4) : BOOL
44 : ite(43, 10, 16) : BV:8
45 : ite(42, 10, 44) : BV:8
46 : ite(41, 10, 45) : BV:8
47 : ite(40, 10, 46) : BV:8
48 : bvconcat(20, 29, 38, 47) : BV:32
49 : ite(3, 2, 48) : BV:32
50 : lambda(1, 49) : FUNCTION[BV:32 -> BV:32]
51 : sym_const(50) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1074268356 { 0x400808c4 +1.6276750e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 524408 { 0x80078 +1.6251430e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 124 , m_adder -> 54), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1022341679 , 1000 , 8 ) -> 636809097, () -> 409219285, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3351 : BV:32
5 : Lambda27229 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27230 : BV:32
8 : 1024418844 { 0x3d0f641c +1.12024259e251 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1267708389 { 0x4b8fb1e5 +1.12261641e24 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 636809097 { 0x25f4ef89 +1.91356003e204 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1597681358 { 0x5f3aaece +1.45845961e63 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 262143 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 262144; 262151 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 262152; 524407 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524408; 524411 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524412; 151086423 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 151086424; 151086427 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 151086428; 1074268355 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1074268356; 1074268359 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1074268360; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 938352589 { 0x37ee1fcd +1.86034548e240 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 262143 ] -> 5, [ 262144; 262144 ] -> 0, [ 262145; 262145 ] -> 0, [ 262146; 262146 ] -> 0, [ 262147; 262147 ] -> 0, [ 262148; 262148 ] -> 0, [ 262149; 262149 ] -> 0, [ 262150; 262150 ] -> 0, [ 262151; 262151 ] -> 0, [ 262152; 151086423 ] -> 5, [ 151086424; 151086427 ] -> 0, [ 151086428; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1615418225 { 0x60495371 +1.57285892e65 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 528039360 { 0x1f793dc0 +1.94719696e191 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 524408 { 0x80078 +1.6251430e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 524411 { 0x8007b +1.6251466e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1074268356 { 0x400808c4 +1.6276750e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1074268359 { 0x400808c7 +1.6276786e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 124 , m_adder -> 54), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2920162499
=counter_example_end
=global nodece 44 num_edges_traversed 3
=global nodece 44 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 45
=global nodece 45 nodece z3v487.ce2412.num_edges_traversed1
=global nodece 45 nodece_path
=global nodece 45 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 45 nodece_cached_counterexample
=counter_example_begin z3v487.ce2412 f4d43eec8e22a18ee51bbd7fc5164e24
=input.spec-%var-arr-1
1 : Lambda27366 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27367 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1593837056 { 0x5f000600 +1.18310e63 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27369 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27370 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27348 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3367 : BV:32
4 : Lambda27373 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27374 : BV:32
7 : 72526653 { 0x452ab3d +1.64585077e137 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform3368 : BV:32
3 : Lambda27375 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda27376 : BV:32
6 : unit : UNIT
7 : 1784625431 { 0x6a5f3917 +1.74392974e85 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sym_const(12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3370 : BV:32
5 : Lambda27379 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27380 : BV:32
8 : 1784625431 { 0x6a5f3917 +1.74392974e85 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 402661375 ] -> 0, [ 402661376; 402661376 ] -> 0, [ 402661377; 402661377 ] -> 0, [ 402661378; 402661378 ] -> 0, [ 402661379; 402661379 ] -> 0, [ 402661380; 402661380 ] -> 0, [ 402661381; 402661381 ] -> 0, [ 402661382; 402661382 ] -> 0, [ 402661383; 402661383 ] -> 0, [ 402661384; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3372 : BV:32
5 : Lambda27383 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27384 : BV:32
8 : 1784625431 { 0x6a5f3917 +1.74392974e85 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 973078528 { 0x3a000000 +1.0e245 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 839996 { 0xcd13c +1.10013532e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3374 : BV:32
5 : Lambda27387 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27388 : BV:32
8 : 1784625431 { 0x6a5f3917 +1.74392974e85 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1790976005 { 0x6ac02005 +1.50097715e86 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 402661376 { 0x18002000 +1.97656e177 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 215641599 { 0xcda6dff +1.70648181e154 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1411264000 { 0x541e2e00 +1.23577880e41 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 839995 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 839996; 839999 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 840000; 402661375 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 402661376; 402661383 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 402661384; 973078527 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 973078528; 973078531 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 973078532; 1593837055 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1593837056; 4294967295 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 215641599 { 0xcda6dff +1.70648181e154 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1476462026 { 0x580105ca +1.798916e49 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 402661376 { 0x18002000 +1.97656e177 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 42219108 { 0x2843664 +1.3290987e134 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 1593837056 { 0x5f000600 +1.18310e63 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 402661375 ] -> 0, [ 402661376; 402661383 ] -> 255, [ 402661384; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1476462026 { 0x580105ca +1.798916e49 } : BV:32
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 839995 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 839996; 839999 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 840000; 402661375 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 402661376; 402661383 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 402661384; 973078527 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 973078528; 973078531 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 973078532; 1593837055 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1593837056; 4294967295 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 1411264000 { 0x541e2e00 +1.23577880e41 } : COUNT
=input.dst.llvm-%call.Lfor.body%2%d
1 : 402661376 { 0x18002000 +1.97656e177 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 402661380 { 0x18002004 +1.97703e177 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 1593837056 { 0x5f000600 +1.18310e63 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 402661376 { 0x18002000 +1.97656e177 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 1593837056 { 0x5f000600 +1.18310e63 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 402661376 { 0x18002000 +1.97656e177 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 402661376 { 0x18002000 +1.97656e177 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 402661380 { 0x18002004 +1.97703e177 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 402661376 { 0x18002000 +1.97656e177 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 839996 { 0xcd13c +1.10013532e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 839999 { 0xcd13f +1.10013568e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 973078528 { 0x3a000000 +1.0e245 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 973078531 { 0x3a000003 +1.35e245 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1532898312
=counter_example_end
=global nodece 45 num_edges_traversed 1
=global nodece 45 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 46
=global nodece 46 nodece z3v487.ce2443.num_edges_traversed2
=global nodece 46 nodece_path
=global nodece 46 nodece_path.graph_edge_composition
(epsilon)
=global nodece 46 nodece_cached_counterexample
=counter_example_begin z3v487.ce2443 f07734f04747d87efd3fb341bb3c80a7
=input.spec-%var-arr-1
1 : Lambda27366 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27367 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1593837056 { 0x5f000600 +1.18310e63 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27369 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27370 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27348 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3367 : BV:32
4 : Lambda27373 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27374 : BV:32
7 : 72526653 { 0x452ab3d +1.64585077e137 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 402661375 ] -> 0, [ 402661376; 402661376 ] -> 0, [ 402661377; 402661377 ] -> 0, [ 402661378; 402661378 ] -> 0, [ 402661379; 402661379 ] -> 0, [ 402661380; 402661380 ] -> 0, [ 402661381; 402661381 ] -> 0, [ 402661382; 402661382 ] -> 0, [ 402661383; 402661383 ] -> 0, [ 402661384; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 973078528 { 0x3a000000 +1.0e245 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 839996 { 0xcd13c +1.10013532e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3374 : BV:32
5 : Lambda27387 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27388 : BV:32
8 : 1784625431 { 0x6a5f3917 +1.74392974e85 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1790976005 { 0x6ac02005 +1.50097715e86 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1411264000 { 0x541e2e00 +1.23577880e41 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 839995 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 839996; 839999 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 840000; 402661375 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 402661376; 402661383 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 402661384; 973078527 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 973078528; 973078531 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 973078532; 1593837055 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1593837056; 4294967295 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 215641599 { 0xcda6dff +1.70648181e154 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1476462026 { 0x580105ca +1.798916e49 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 402661376 { 0x18002000 +1.97656e177 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 42219108 { 0x2843664 +1.3290987e134 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 839996 { 0xcd13c +1.10013532e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 839999 { 0xcd13f +1.10013568e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 973078528 { 0x3a000000 +1.0e245 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 973078531 { 0x3a000003 +1.35e245 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1532898312
=counter_example_end
=global nodece 46 num_edges_traversed 2
=global nodece 46 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 47
=global nodece 47 nodece z3v487.ce2447.num_edges_traversed3
=global nodece 47 nodece_path
=global nodece 47 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 47 nodece_cached_counterexample
=counter_example_begin z3v487.ce2447 b0ff344dacc6f0b2244a1ec4d736c484
=nextpc_const.1
1 : 1798578391 { 0x6b3420d7 +1.40725219e87 } : BV:32
=input.spec-%var-arr-1
1 : Lambda27366 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27367 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1593837056 { 0x5f000600 +1.18310e63 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27369 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27370 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27348 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3367 : BV:32
4 : Lambda27373 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27374 : BV:32
7 : 72526653 { 0x452ab3d +1.64585077e137 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 402661375 ] -> 0, [ 402661376; 402661376 ] -> 0, [ 402661377; 402661377 ] -> 0, [ 402661378; 402661378 ] -> 0, [ 402661379; 402661379 ] -> 0, [ 402661380; 402661380 ] -> 0, [ 402661381; 402661381 ] -> 0, [ 402661382; 402661382 ] -> 0, [ 402661383; 402661383 ] -> 0, [ 402661384; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 973078528 { 0x3a000000 +1.0e245 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 839996 { 0xcd13c +1.10013532e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 102 , m_adder -> 138), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1798578391 , 1000 , 8 ) -> 422485367, () -> 187154722, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3374 : BV:32
5 : Lambda27387 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27388 : BV:32
8 : 1784625431 { 0x6a5f3917 +1.74392974e85 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1790976005 { 0x6ac02005 +1.50097715e86 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 422485367 { 0x192e9d77 +1.36418044e179 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1411264000 { 0x541e2e00 +1.23577880e41 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 839995 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 839996; 839999 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 840000; 402661375 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 402661376; 402661383 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 402661384; 973078527 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 973078528; 973078531 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 973078532; 1593837055 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1593837056; 4294967295 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 215641599 { 0xcda6dff +1.70648181e154 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 402661375 ] -> 0, [ 402661376; 402661376 ] -> 0, [ 402661377; 402661377 ] -> 0, [ 402661378; 402661378 ] -> 0, [ 402661379; 402661379 ] -> 0, [ 402661380; 402661380 ] -> 0, [ 402661381; 402661381 ] -> 0, [ 402661382; 402661382 ] -> 0, [ 402661383; 402661383 ] -> 0, [ 402661384; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1476462026 { 0x580105ca +1.798916e49 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 402661376 { 0x18002000 +1.97656e177 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 42219108 { 0x2843664 +1.3290987e134 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 839996 { 0xcd13c +1.10013532e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 839999 { 0xcd13f +1.10013568e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 973078528 { 0x3a000000 +1.0e245 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 973078531 { 0x3a000003 +1.35e245 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 102 , m_adder -> 138), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1700770524
=counter_example_end
=global nodece 47 num_edges_traversed 3
=global nodece 47 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 48
=global nodece 48 nodece z3v487.ce2466.num_edges_traversed1
=global nodece 48 nodece_path
=global nodece 48 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 48 nodece_cached_counterexample
=counter_example_begin z3v487.ce2466 1c7a1de88e3bab7dc7ca46c133376f58
=input.spec-%var-arr-1
1 : Lambda27524 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27525 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3523383680 { 0xd2029180 -771583616 -1.2006530e37 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27527 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27528 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1073741823 ] -> true, [ 1073741824; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27506 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3390 : BV:32
4 : Lambda27531 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27532 : BV:32
7 : 1113203273 { 0x425a2249 +1.70417129e5 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform3391 : BV:32
3 : Lambda27533 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda27534 : BV:32
6 : unit : UNIT
7 : 885298953 { 0x34c49709 +1.53585922e234 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sym_const(12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1073741823 ] -> true, [ 1073741824; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3393 : BV:32
5 : Lambda27537 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27538 : BV:32
8 : 885298953 { 0x34c49709 +1.53585922e234 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 2147483639 ] -> 0, [ 2147483640; 2147483640 ] -> 0, [ 2147483641; 2147483641 ] -> 0, [ 2147483642; 2147483642 ] -> 0, [ 2147483643; 2147483643 ] -> 0, [ 2147483644; 2147483644 ] -> 0, [ 2147483645; 2147483645 ] -> 0, [ 2147483646; 2147483646 ] -> 0, [ 2147483647; 2147483647 ] -> 0, [ 2147483648; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3395 : BV:32
5 : Lambda27541 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27542 : BV:32
8 : 885298953 { 0x34c49709 +1.53585922e234 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3397 : BV:32
5 : Lambda27545 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27546 : BV:32
8 : 885298953 { 0x34c49709 +1.53585922e234 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1308448936 { 0x4dfd58a8 +1.97926807e28 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2147483640 { 0x7ffffff8 +1.99999904e128 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 125943422 { 0x781be7e +1.1362586e144 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 827541063 { 0x31534647 +1.65058219e227 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 524287 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524288; 524291 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524292; 536870911 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 536870912; 536870915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 536870916; 2147483647 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483648; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 125943422 { 0x781be7e +1.1362586e144 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 72425886 { 0x451219e +1.63383841e137 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 2147483640 { 0x7ffffff8 +1.99999904e128 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1477274039 { 0x580d69b7 +1.10478866e49 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 3523383680 { 0xd2029180 -771583616 -1.2006530e37 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 2147483639 ] -> 0, [ 2147483640; 2147483647 ] -> 70, [ 2147483648; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 72425886 { 0x451219e +1.63383841e137 } : BV:32
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 524287 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524288; 524291 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524292; 536870911 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 536870912; 536870915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 536870916; 2147483647 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483648; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 827541063 { 0x31534647 +1.65058219e227 } : COUNT
=input.dst.llvm-%call.Lfor.body%2%d
1 : 2147483640 { 0x7ffffff8 +1.99999904e128 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 2147483644 { 0x7ffffffc +1.99999952e128 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 3523383680 { 0xd2029180 -771583616 -1.2006530e37 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 2147483640 { 0x7ffffff8 +1.99999904e128 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 3523383680 { 0xd2029180 -771583616 -1.2006530e37 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 2147483640 { 0x7ffffff8 +1.99999904e128 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 2147483640 { 0x7ffffff8 +1.99999904e128 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 2147483644 { 0x7ffffffc +1.99999952e128 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 2147483640 { 0x7ffffff8 +1.99999904e128 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 524291 { 0x80003 +1.6250035e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 536870915 { 0x20000003 +1.35e193 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2576251481
=counter_example_end
=global nodece 48 num_edges_traversed 1
=global nodece 48 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 49
=global nodece 49 nodece z3v487.ce2497.num_edges_traversed2
=global nodece 49 nodece_path
=global nodece 49 nodece_path.graph_edge_composition
(epsilon)
=global nodece 49 nodece_cached_counterexample
=counter_example_begin z3v487.ce2497 9a5add1d859dc7c928b3fbfb1da1f9
=input.spec-%var-arr-1
1 : Lambda27524 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27525 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3523383680 { 0xd2029180 -771583616 -1.2006530e37 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27527 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27528 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1073741823 ] -> true, [ 1073741824; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27506 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3390 : BV:32
4 : Lambda27531 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27532 : BV:32
7 : 1113203273 { 0x425a2249 +1.70417129e5 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1073741823 ] -> true, [ 1073741824; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 2147483639 ] -> 0, [ 2147483640; 2147483640 ] -> 0, [ 2147483641; 2147483641 ] -> 0, [ 2147483642; 2147483642 ] -> 0, [ 2147483643; 2147483643 ] -> 0, [ 2147483644; 2147483644 ] -> 0, [ 2147483645; 2147483645 ] -> 0, [ 2147483646; 2147483646 ] -> 0, [ 2147483647; 2147483647 ] -> 0, [ 2147483648; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3397 : BV:32
5 : Lambda27545 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27546 : BV:32
8 : 885298953 { 0x34c49709 +1.53585922e234 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1308448936 { 0x4dfd58a8 +1.97926807e28 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 827541063 { 0x31534647 +1.65058219e227 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 524287 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524288; 524291 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524292; 536870911 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 536870912; 536870915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 536870916; 2147483647 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483648; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 125943422 { 0x781be7e +1.1362586e144 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 72425886 { 0x451219e +1.63383841e137 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 2147483640 { 0x7ffffff8 +1.99999904e128 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1477274039 { 0x580d69b7 +1.10478866e49 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 524291 { 0x80003 +1.6250035e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 536870915 { 0x20000003 +1.35e193 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2576251481
=counter_example_end
=global nodece 49 num_edges_traversed 2
=global nodece 49 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 50
=global nodece 50 nodece z3v487.ce2501.num_edges_traversed3
=global nodece 50 nodece_path
=global nodece 50 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 50 nodece_cached_counterexample
=counter_example_begin z3v487.ce2501 aa9d744df52f1e53d9da40842fcb259e
=nextpc_const.1
1 : 1283251215 { 0x4c7cdc0f +1.97546565e25 } : BV:32
=input.spec-%var-arr-1
1 : Lambda27524 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27525 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3523383680 { 0xd2029180 -771583616 -1.2006530e37 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27527 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27528 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1073741823 ] -> true, [ 1073741824; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27506 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3390 : BV:32
4 : Lambda27531 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27532 : BV:32
7 : 1113203273 { 0x425a2249 +1.70417129e5 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1073741823 ] -> true, [ 1073741824; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 2147483639 ] -> 0, [ 2147483640; 2147483640 ] -> 0, [ 2147483641; 2147483641 ] -> 0, [ 2147483642; 2147483642 ] -> 0, [ 2147483643; 2147483643 ] -> 0, [ 2147483644; 2147483644 ] -> 0, [ 2147483645; 2147483645 ] -> 0, [ 2147483646; 2147483646 ] -> 0, [ 2147483647; 2147483647 ] -> 0, [ 2147483648; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 119 , m_adder -> 22), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1283251215 , 1000 , 8 ) -> 2038816070, () -> 1364240956, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3397 : BV:32
5 : Lambda27545 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27546 : BV:32
8 : 885298953 { 0x34c49709 +1.53585922e234 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1308448936 { 0x4dfd58a8 +1.97926807e28 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2038816070 { 0x7985dd46 +1.4581522e116 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 827541063 { 0x31534647 +1.65058219e227 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 524287 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524288; 524291 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524292; 536870911 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 536870912; 536870915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 536870916; 2147483647 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483648; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 125943422 { 0x781be7e +1.1362586e144 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 2147483639 ] -> 0, [ 2147483640; 2147483640 ] -> 0, [ 2147483641; 2147483641 ] -> 0, [ 2147483642; 2147483642 ] -> 0, [ 2147483643; 2147483643 ] -> 0, [ 2147483644; 2147483644 ] -> 0, [ 2147483645; 2147483645 ] -> 0, [ 2147483646; 2147483646 ] -> 0, [ 2147483647; 2147483647 ] -> 0, [ 2147483648; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 72425886 { 0x451219e +1.63383841e137 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 2147483640 { 0x7ffffff8 +1.99999904e128 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1477274039 { 0x580d69b7 +1.10478866e49 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 524291 { 0x80003 +1.6250035e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 536870915 { 0x20000003 +1.35e193 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 119 , m_adder -> 22), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
4282169117
=counter_example_end
=global nodece 50 num_edges_traversed 3
=global nodece 50 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 51
=global nodece 51 nodece z3v487.ce2519.num_edges_traversed1
=global nodece 51 nodece_path
=global nodece 51 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 51 nodece_cached_counterexample
=counter_example_begin z3v487.ce2519 576a1c4c83fc9373e712966c9b16142
=input.spec-%var-arr-1
1 : Lambda27682 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27683 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1096093776 { 0x41551050 +1.66456031e3 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27685 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27686 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27664 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3413 : BV:32
4 : Lambda27689 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27690 : BV:32
7 : 1660750090 { 0x62fd090a +1.97683835e70 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : Indxform3414 : BV:32
3 : Lambda27691 : BV:32
4 : lambda(3, 3) : FUNCTION[BV:32 -> BV:32]
5 : Lambda27692 : BV:32
6 : unit : UNIT
7 : 311000773 { 0x12897ec5 +1.7418119e166 } : BV:32
8 : prod(7, 2) : PROD[BV:32,BV:32]
9 : sum(1, 6, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(5, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 2, 4, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sym_const(12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3416 : BV:32
5 : Lambda27695 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27696 : BV:32
8 : 311000773 { 0x12897ec5 +1.7418119e166 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1644167171 ] -> 0, [ 1644167172; 1644167172 ] -> 0, [ 1644167173; 1644167173 ] -> 0, [ 1644167174; 1644167174 ] -> 0, [ 1644167175; 1644167175 ] -> 0, [ 1644167176; 1644167176 ] -> 0, [ 1644167177; 1644167177 ] -> 0, [ 1644167178; 1644167178 ] -> 0, [ 1644167179; 1644167179 ] -> 0, [ 1644167180; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3418 : BV:32
5 : Lambda27699 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27700 : BV:32
8 : 311000773 { 0x12897ec5 +1.7418119e166 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 105876036 { 0x64f8a44 +1.62140703e141 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3420 : BV:32
5 : Lambda27703 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27704 : BV:32
8 : 311000773 { 0x12897ec5 +1.7418119e166 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1133705482 { 0x4392f90a +1.14822506e8 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1644167172 { 0x62000004 +1.47e69 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1474774824 { 0x57e74728 +1.80685901e48 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1722391591 { 0x66a99c27 +1.32507789e78 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 7 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 8; 11 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 12; 105876035 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 105876036; 105876039 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 105876040; 1096093775 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1096093776; 1644167171 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1644167172; 1644167179 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1644167180; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1474774824 { 0x57e74728 +1.80685901e48 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 185790490 { 0xb12f01a +1.14795231e151 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1644167172 { 0x62000004 +1.47e69 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 789173024 { 0x2f09d320 +1.7675552e223 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 1096093776 { 0x41551050 +1.66456031e3 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 1644167171 ] -> 0, [ 1644167172; 1644167179 ] -> 38, [ 1644167180; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 185790490 { 0xb12f01a +1.14795231e151 } : BV:32
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 7 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 8; 11 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 12; 105876035 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 105876036; 105876039 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 105876040; 1096093775 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1096093776; 1644167171 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1644167172; 1644167179 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1644167180; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 1722391591 { 0x66a99c27 +1.32507789e78 } : COUNT
=input.dst.llvm-%call.Lfor.body%2%d
1 : 1644167172 { 0x62000004 +1.47e69 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 1644167176 { 0x62000008 +1.95e69 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 1096093776 { 0x41551050 +1.66456031e3 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 1644167172 { 0x62000004 +1.47e69 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 1096093776 { 0x41551050 +1.66456031e3 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 1644167172 { 0x62000004 +1.47e69 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1644167172 { 0x62000004 +1.47e69 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 1644167176 { 0x62000008 +1.95e69 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 1644167172 { 0x62000004 +1.47e69 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 105876036 { 0x64f8a44 +1.62140703e141 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 105876039 { 0x64f8a47 +1.62140738e141 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 11 { 0xb +1.131e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1126044858
=counter_example_end
=global nodece 51 num_edges_traversed 1
=global nodece 51 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 52
=global nodece 52 nodece z3v487.ce2550.num_edges_traversed2
=global nodece 52 nodece_path
=global nodece 52 nodece_path.graph_edge_composition
(epsilon)
=global nodece 52 nodece_cached_counterexample
=counter_example_begin z3v487.ce2550 dba6e9a83d23f970fdf0968138ea4656
=input.spec-%var-arr-1
1 : Lambda27682 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27683 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1096093776 { 0x41551050 +1.66456031e3 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27685 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27686 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27664 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3413 : BV:32
4 : Lambda27689 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27690 : BV:32
7 : 1660750090 { 0x62fd090a +1.97683835e70 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1644167171 ] -> 0, [ 1644167172; 1644167172 ] -> 0, [ 1644167173; 1644167173 ] -> 0, [ 1644167174; 1644167174 ] -> 0, [ 1644167175; 1644167175 ] -> 0, [ 1644167176; 1644167176 ] -> 0, [ 1644167177; 1644167177 ] -> 0, [ 1644167178; 1644167178 ] -> 0, [ 1644167179; 1644167179 ] -> 0, [ 1644167180; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 105876036 { 0x64f8a44 +1.62140703e141 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3420 : BV:32
5 : Lambda27703 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27704 : BV:32
8 : 311000773 { 0x12897ec5 +1.7418119e166 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1133705482 { 0x4392f90a +1.14822506e8 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1722391591 { 0x66a99c27 +1.32507789e78 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 7 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 8; 11 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 12; 105876035 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 105876036; 105876039 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 105876040; 1096093775 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1096093776; 1644167171 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1644167172; 1644167179 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1644167180; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1474774824 { 0x57e74728 +1.80685901e48 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 185790490 { 0xb12f01a +1.14795231e151 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1644167172 { 0x62000004 +1.47e69 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 789173024 { 0x2f09d320 +1.7675552e223 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 105876036 { 0x64f8a44 +1.62140703e141 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 105876039 { 0x64f8a47 +1.62140738e141 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 11 { 0xb +1.131e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1126044858
=counter_example_end
=global nodece 52 num_edges_traversed 2
=global nodece 52 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 53
=global nodece 53 nodece z3v487.ce2554.num_edges_traversed3
=global nodece 53 nodece_path
=global nodece 53 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 53 nodece_cached_counterexample
=counter_example_begin z3v487.ce2554 14bdb49d763be25e9e33d35c182fdbf7
=nextpc_const.1
1 : 2142599507 { 0x7fb57953 +1.41776502e128 } : BV:32
=input.spec-%var-arr-1
1 : Lambda27682 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27683 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1096093776 { 0x41551050 +1.66456031e3 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27685 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27686 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27664 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3413 : BV:32
4 : Lambda27689 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27690 : BV:32
7 : 1660750090 { 0x62fd090a +1.97683835e70 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : sym_const(13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1644167171 ] -> 0, [ 1644167172; 1644167172 ] -> 0, [ 1644167173; 1644167173 ] -> 0, [ 1644167174; 1644167174 ] -> 0, [ 1644167175; 1644167175 ] -> 0, [ 1644167176; 1644167176 ] -> 0, [ 1644167177; 1644167177 ] -> 0, [ 1644167178; 1644167178 ] -> 0, [ 1644167179; 1644167179 ] -> 0, [ 1644167180; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 105876036 { 0x64f8a44 +1.62140703e141 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 72 , m_adder -> 88), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 2142599507 , 1000 , 8 ) -> 1996964283, () -> 1960881112, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3420 : BV:32
5 : Lambda27703 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27704 : BV:32
8 : 311000773 { 0x12897ec5 +1.7418119e166 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1133705482 { 0x4392f90a +1.14822506e8 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1996964283 { 0x770741bb +1.5669343e111 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1722391591 { 0x66a99c27 +1.32507789e78 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 7 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 8; 11 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 12; 105876035 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 105876036; 105876039 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 105876040; 1096093775 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1096093776; 1644167171 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1644167172; 1644167179 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1644167180; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1474774824 { 0x57e74728 +1.80685901e48 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1644167171 ] -> 0, [ 1644167172; 1644167172 ] -> 0, [ 1644167173; 1644167173 ] -> 0, [ 1644167174; 1644167174 ] -> 0, [ 1644167175; 1644167175 ] -> 0, [ 1644167176; 1644167176 ] -> 0, [ 1644167177; 1644167177 ] -> 0, [ 1644167178; 1644167178 ] -> 0, [ 1644167179; 1644167179 ] -> 0, [ 1644167180; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 185790490 { 0xb12f01a +1.14795231e151 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1644167172 { 0x62000004 +1.47e69 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 789173024 { 0x2f09d320 +1.7675552e223 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 105876036 { 0x64f8a44 +1.62140703e141 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 105876039 { 0x64f8a47 +1.62140738e141 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 11 { 0xb +1.131e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 72 , m_adder -> 88), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
250279534
=counter_example_end
=global nodece 53 num_edges_traversed 3
=global nodece 53 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 54
=global nodece 54 nodece z3v487.ce2576.num_edges_traversed1
=global nodece 54 nodece_path
=global nodece 54 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 54 nodece_cached_counterexample
=counter_example_begin z3v487.ce2576 89d879b4c797b336553e564cfd1eb
=input.spec-%var-arr-1
1 : Lambda27940 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27941 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1429441536 { 0x55338c00 +1.40270996e43 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27943 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27944 : BV:32
18 : 1 { 0x1 +1.11e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27924 : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3448 : BV:32
4 : Lambda27947 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27948 : BV:32
7 : 1893894484 { 0x70e28954 +1.76981592e98 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
3 : unit : UNIT
4 : Indxform3449 : BV:32
5 : Lambda27949 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda27950 : BV:32
8 : 335298171 { 0x13fc3e7b +1.97065675e168 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(1, 3, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(1, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(1, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(2, 3, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(1, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3451 : BV:32
6 : Lambda27953 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda27954 : BV:32
9 : 335298171 { 0x13fc3e7b +1.97065675e168 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 64, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3453 : BV:32
6 : Lambda27957 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda27958 : BV:32
9 : 335298171 { 0x13fc3e7b +1.97065675e168 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483652 { 0x80000004 -2147483644 -1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3455 : BV:32
6 : Lambda27961 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda27962 : BV:32
9 : 335298171 { 0x13fc3e7b +1.97065675e168 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1874432330 { 0x6fb9914a +1.44974637e96 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 10936128 { 0xa6df40 +1.30368804e130 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1307314157 { 0x4dec07ed +1.84399187e28 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1429441539 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1429441540; 1429441543 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1429441544; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147483652; 2147483655 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483656; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 10936128 { 0xa6df40 +1.30368804e130 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 694497845 { 0x29653235 +1.79059469e211 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 2061178662 { 0x7adb1726 +1.71164393e118 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 1429441536 { 0x55338c00 +1.40270996e43 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 3 ] -> 0, [ 4; 11 ] -> 236, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 694497845 { 0x29653235 +1.79059469e211 } : BV:32
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1429441539 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1429441540; 1429441543 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1429441544; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147483652; 2147483655 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483656; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 1307314157 { 0x4dec07ed +1.84399187e28 } : COUNT
=input.dst.llvm-%call.Lfor.body%2%d
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 1429441540 { 0x55338c04 +1.40271043e43 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 1429441540 { 0x55338c04 +1.40271043e43 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483652 { 0x80000004 -2147483644 -1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483655 { 0x80000007 -2147483641 -1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2983692669
=counter_example_end
=global nodece 54 num_edges_traversed 1
=global nodece 54 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 55
=global nodece 55 nodece z3v487.ce2607.num_edges_traversed2
=global nodece 55 nodece_path
=global nodece 55 nodece_path.graph_edge_composition
(epsilon)
=global nodece 55 nodece_cached_counterexample
=counter_example_begin z3v487.ce2607 f3315151154b35cb3da927e0fc97d0bc
=input.spec-%var-arr-1
1 : Lambda27940 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27941 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1429441536 { 0x55338c00 +1.40270996e43 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27943 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27944 : BV:32
18 : 1 { 0x1 +1.11e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27924 : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3448 : BV:32
4 : Lambda27947 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27948 : BV:32
7 : 1893894484 { 0x70e28954 +1.76981592e98 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 64, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483652 { 0x80000004 -2147483644 -1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3455 : BV:32
6 : Lambda27961 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda27962 : BV:32
9 : 335298171 { 0x13fc3e7b +1.97065675e168 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1874432330 { 0x6fb9914a +1.44974637e96 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1307314157 { 0x4dec07ed +1.84399187e28 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1429441539 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1429441540; 1429441543 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1429441544; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147483652; 2147483655 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483656; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 10936128 { 0xa6df40 +1.30368804e130 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 694497845 { 0x29653235 +1.79059469e211 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 2061178662 { 0x7adb1726 +1.71164393e118 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483652 { 0x80000004 -2147483644 -1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483655 { 0x80000007 -2147483641 -1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2983692669
=counter_example_end
=global nodece 55 num_edges_traversed 2
=global nodece 55 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 56
=global nodece 56 nodece z3v487.ce2611.num_edges_traversed3
=global nodece 56 nodece_path
=global nodece 56 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 56 nodece_cached_counterexample
=counter_example_begin z3v487.ce2611 7792581e1e7d43ae284dba3c74c4e99
=nextpc_const.1
1 : 91507561 { 0x5744b69 +1.90855133e139 } : BV:32
=input.spec-%var-arr-1
1 : Lambda27940 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27941 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1429441536 { 0x55338c00 +1.40270996e43 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda27943 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda27944 : BV:32
18 : 1 { 0x1 +1.11e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda27924 : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3448 : BV:32
4 : Lambda27947 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda27948 : BV:32
7 : 1893894484 { 0x70e28954 +1.76981592e98 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 64, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483652 { 0x80000004 -2147483644 -1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 115 , m_adder -> 73), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 91507561 , 1000 , 8 ) -> 621644646, () -> 806545588, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3455 : BV:32
6 : Lambda27961 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda27962 : BV:32
9 : 335298171 { 0x13fc3e7b +1.97065675e168 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1874432330 { 0x6fb9914a +1.44974637e96 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 621644646 { 0x250d8b66 +1.10581660e203 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1307314157 { 0x4dec07ed +1.84399187e28 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1429441539 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1429441540; 1429441543 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1429441544; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147483652; 2147483655 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483656; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 10936128 { 0xa6df40 +1.30368804e130 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 64, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 694497845 { 0x29653235 +1.79059469e211 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 2061178662 { 0x7adb1726 +1.71164393e118 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483652 { 0x80000004 -2147483644 -1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483655 { 0x80000007 -2147483641 -1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 115 , m_adder -> 73), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1835524097
=counter_example_end
=global nodece 56 num_edges_traversed 3
=global nodece 56 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 57
=global nodece 57 nodece z3v487.ce2634.num_edges_traversed1
=global nodece 57 nodece_path
=global nodece 57 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 57 nodece_cached_counterexample
=counter_example_begin z3v487.ce2634 a7de446626eea91bb33effb4bf0fb5f
=input.spec-%var-arr-1
1 : Lambda28213 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28214 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1879048176 { 0x6ffffff0 +1.99999809e96 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28216 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28217 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28197 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3487 : BV:32
4 : Lambda28220 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28221 : BV:32
7 : 614731091 { 0x24a40d53 +1.28165662e202 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
3 : unit : UNIT
4 : Indxform3488 : BV:32
5 : Lambda28222 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda28223 : BV:32
8 : 128158359 { 0x7a38a97 +1.27766692e144 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(1, 3, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(1, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(1, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(2, 3, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(1, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3490 : BV:32
6 : Lambda28226 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28227 : BV:32
9 : 128158359 { 0x7a38a97 +1.27766692e144 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1073741823 ] -> 0, [ 1073741824; 1073741824 ] -> 0, [ 1073741825; 1073741825 ] -> 0, [ 1073741826; 1073741826 ] -> 0, [ 1073741827; 1073741827 ] -> 0, [ 1073741828; 1073741828 ] -> 0, [ 1073741829; 1073741829 ] -> 8, [ 1073741830; 1073741830 ] -> 0, [ 1073741831; 1073741831 ] -> 0, [ 1073741832; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3492 : BV:32
6 : Lambda28230 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28231 : BV:32
9 : 128158359 { 0x7a38a97 +1.27766692e144 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 536870920 { 0x20000008 +1.95e193 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3494 : BV:32
6 : Lambda28234 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28235 : BV:32
9 : 128158359 { 0x7a38a97 +1.27766692e144 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 156339903 { 0x9518ebf +1.63716876e147 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 860880692 { 0x334fff34 +1.62497568e231 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 289070162 { 0x113adc52 +1.45984864e163 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 536870911 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 536870912; 536870915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 536870916; 536870919 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 536870920; 536870923 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 536870924; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741831 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073741832; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 860880692 { 0x334fff34 +1.62497568e231 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1924443866 { 0x72b4aeda +1.41158604e102 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1467360378 { 0x5776247a +1.92298817e47 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 1879048176 { 0x6ffffff0 +1.99999809e96 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 1073741823 ] -> 0, [ 1073741824; 1073741831 ] -> 81, [ 1073741832; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1924443866 { 0x72b4aeda +1.41158604e102 } : BV:32
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 3 { 0x3 +1.35e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 2048 { 0x800 +1.24414e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 536870911 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 536870912; 536870915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 536870916; 536870919 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 536870920; 536870923 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 536870924; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741831 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073741832; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 289070162 { 0x113adc52 +1.45984864e163 } : COUNT
=input.dst.llvm-%call.Lfor.body%2%d
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 1073741828 { 0x40000004 +1.47e1 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 1879048188 { 0x6ffffffc +1.99999952e96 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 1879048188 { 0x6ffffffc +1.99999952e96 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 1073741828 { 0x40000004 +1.47e1 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 536870915 { 0x20000003 +1.35e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 536870920 { 0x20000008 +1.95e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 536870923 { 0x2000000b +1.131e193 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3620743515
=counter_example_end
=global nodece 57 num_edges_traversed 1
=global nodece 57 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 58
=global nodece 58 nodece z3v487.ce2665.num_edges_traversed2
=global nodece 58 nodece_path
=global nodece 58 nodece_path.graph_edge_composition
(epsilon)
=global nodece 58 nodece_cached_counterexample
=counter_example_begin z3v487.ce2665 7bdfb2fd994cfb16fe14579b6412a4e4
=input.spec-%var-arr-1
1 : Lambda28213 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28214 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1879048176 { 0x6ffffff0 +1.99999809e96 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28216 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28217 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28197 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3487 : BV:32
4 : Lambda28220 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28221 : BV:32
7 : 614731091 { 0x24a40d53 +1.28165662e202 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1073741823 ] -> 0, [ 1073741824; 1073741824 ] -> 0, [ 1073741825; 1073741825 ] -> 0, [ 1073741826; 1073741826 ] -> 0, [ 1073741827; 1073741827 ] -> 0, [ 1073741828; 1073741828 ] -> 0, [ 1073741829; 1073741829 ] -> 8, [ 1073741830; 1073741830 ] -> 0, [ 1073741831; 1073741831 ] -> 0, [ 1073741832; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 536870920 { 0x20000008 +1.95e193 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3494 : BV:32
6 : Lambda28234 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28235 : BV:32
9 : 128158359 { 0x7a38a97 +1.27766692e144 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 156339903 { 0x9518ebf +1.63716876e147 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 289070162 { 0x113adc52 +1.45984864e163 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 536870911 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 536870912; 536870915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 536870916; 536870919 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 536870920; 536870923 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 536870924; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741831 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073741832; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 860880692 { 0x334fff34 +1.62497568e231 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1924443866 { 0x72b4aeda +1.41158604e102 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1467360378 { 0x5776247a +1.92298817e47 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 536870915 { 0x20000003 +1.35e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 536870920 { 0x20000008 +1.95e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 536870923 { 0x2000000b +1.131e193 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3620743515
=counter_example_end
=global nodece 58 num_edges_traversed 2
=global nodece 58 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 59
=global nodece 59 nodece z3v487.ce2669.num_edges_traversed3
=global nodece 59 nodece_path
=global nodece 59 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 59 nodece_cached_counterexample
=counter_example_begin z3v487.ce2669 ab6ff3128cb8caba7e239cc189c64a6e
=nextpc_const.1
1 : 2044382463 { 0x79daccff +1.70938098e116 } : BV:32
=input.spec-%var-arr-1
1 : Lambda28213 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28214 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1879048176 { 0x6ffffff0 +1.99999809e96 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28216 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28217 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28197 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3487 : BV:32
4 : Lambda28220 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28221 : BV:32
7 : 614731091 { 0x24a40d53 +1.28165662e202 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1073741823 ] -> 0, [ 1073741824; 1073741824 ] -> 0, [ 1073741825; 1073741825 ] -> 0, [ 1073741826; 1073741826 ] -> 0, [ 1073741827; 1073741827 ] -> 0, [ 1073741828; 1073741828 ] -> 0, [ 1073741829; 1073741829 ] -> 8, [ 1073741830; 1073741830 ] -> 0, [ 1073741831; 1073741831 ] -> 0, [ 1073741832; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 536870920 { 0x20000008 +1.95e193 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 235 , m_adder -> 2), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 2044382463 , 1000 , 8 ) -> 1152671553, () -> 547939797, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3494 : BV:32
6 : Lambda28234 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28235 : BV:32
9 : 128158359 { 0x7a38a97 +1.27766692e144 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 156339903 { 0x9518ebf +1.63716876e147 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1152671553 { 0x44b45f41 +1.40915691e10 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 289070162 { 0x113adc52 +1.45984864e163 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 536870911 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 536870912; 536870915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 536870916; 536870919 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 536870920; 536870923 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 536870924; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741831 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073741832; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 860880692 { 0x334fff34 +1.62497568e231 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1073741823 ] -> 0, [ 1073741824; 1073741824 ] -> 0, [ 1073741825; 1073741825 ] -> 0, [ 1073741826; 1073741826 ] -> 0, [ 1073741827; 1073741827 ] -> 0, [ 1073741828; 1073741828 ] -> 0, [ 1073741829; 1073741829 ] -> 8, [ 1073741830; 1073741830 ] -> 0, [ 1073741831; 1073741831 ] -> 0, [ 1073741832; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1924443866 { 0x72b4aeda +1.41158604e102 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1467360378 { 0x5776247a +1.92298817e47 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 536870915 { 0x20000003 +1.35e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 536870920 { 0x20000008 +1.95e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 536870923 { 0x2000000b +1.131e193 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 235 , m_adder -> 2), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3231501311
=counter_example_end
=global nodece 59 num_edges_traversed 3
=global nodece 59 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 60
=global nodece 60 nodece z3v487.ce2691.num_edges_traversed1
=global nodece 60 nodece_path
=global nodece 60 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 60 nodece_cached_counterexample
=counter_example_begin z3v487.ce2691 51fe8fa9fa19e3d1f60a4755d86f0e5
=input.spec-%var-arr-1
1 : Lambda28459 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28460 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1073741812 { 0x3ffffff4 +1.99999856e0 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28462 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28463 : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28443 : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3522 : BV:32
4 : Lambda28466 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28467 : BV:32
7 : 284576080 { 0x10f64950 +1.92411231e162 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
3 : unit : UNIT
4 : Indxform3523 : BV:32
5 : Lambda28468 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda28469 : BV:32
8 : 1970393374 { 0x7571d11e +1.88919425e107 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(1, 3, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(1, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(1, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(2, 3, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(1, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3525 : BV:32
6 : Lambda28472 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28473 : BV:32
9 : 1970393374 { 0x7571d11e +1.88919425e107 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4227731323 ] -> 0, [ 4227731324; 4227731324 ] -> 0, [ 4227731325; 4227731325 ] -> 0, [ 4227731326; 4227731326 ] -> 0, [ 4227731327; 4227731327 ] -> 0, [ 4227731328; 4227731328 ] -> 16, [ 4227731329; 4227731329 ] -> 0, [ 4227731330; 4227731330 ] -> 0, [ 4227731331; 4227731331 ] -> 0, [ 4227731332; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3527 : BV:32
6 : Lambda28476 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28477 : BV:32
9 : 1970393374 { 0x7571d11e +1.88919425e107 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3529 : BV:32
6 : Lambda28480 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28481 : BV:32
9 : 1970393374 { 0x7571d11e +1.88919425e107 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 462106276 { 0x1b8b2ea4 +1.8736085e184 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 4227731324 { 0xfbfe0f7c -67235972 -1.98484754e120 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 898120610 { 0x35883ba2 +1.6431984e236 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 14755217 { 0xe12591 +1.75895893e130 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1082724351 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1082724352; 1082724355 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1082724356; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4227731323 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4227731324; 4227731331 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4227731332; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 898120610 { 0x35883ba2 +1.6431984e236 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1691374669 { 0x64d0544d +1.62757265e74 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4227731324 { 0xfbfe0f7c -67235972 -1.98484754e120 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 269680496 { 0x1012ff70 +1.14842033e161 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 1073741812 { 0x3ffffff4 +1.99999856e0 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 4227731323 ] -> 0, [ 4227731324; 4227731331 ] -> 144, [ 4227731332; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1691374669 { 0x64d0544d +1.62757265e74 } : BV:32
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 1082724351 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1082724352; 1082724355 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1082724356; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4227731323 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4227731324; 4227731331 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4227731332; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 14755217 { 0xe12591 +1.75895893e130 } : COUNT
=input.dst.llvm-%call.Lfor.body%2%d
1 : 4227731324 { 0xfbfe0f7c -67235972 -1.98484754e120 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 4227731328 { 0xfbfe0f80 -67235968 -1.98484802e120 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 1073741828 { 0x40000004 +1.47e1 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 4227731324 { 0xfbfe0f7c -67235972 -1.98484754e120 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 1073741828 { 0x40000004 +1.47e1 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 4227731324 { 0xfbfe0f7c -67235972 -1.98484754e120 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 4227731324 { 0xfbfe0f7c -67235972 -1.98484754e120 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 4227731328 { 0xfbfe0f80 -67235968 -1.98484802e120 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 4227731324 { 0xfbfe0f7c -67235972 -1.98484754e120 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1082724355 { 0x40891003 +1.7080113e2 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1838004491
=counter_example_end
=global nodece 60 num_edges_traversed 1
=global nodece 60 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 61
=global nodece 61 nodece z3v487.ce2722.num_edges_traversed2
=global nodece 61 nodece_path
=global nodece 61 nodece_path.graph_edge_composition
(epsilon)
=global nodece 61 nodece_cached_counterexample
=counter_example_begin z3v487.ce2722 cc8059d0715b3c36601e8ad4b27d232
=input.spec-%var-arr-1
1 : Lambda28459 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28460 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1073741812 { 0x3ffffff4 +1.99999856e0 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28462 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28463 : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28443 : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3522 : BV:32
4 : Lambda28466 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28467 : BV:32
7 : 284576080 { 0x10f64950 +1.92411231e162 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4227731323 ] -> 0, [ 4227731324; 4227731324 ] -> 0, [ 4227731325; 4227731325 ] -> 0, [ 4227731326; 4227731326 ] -> 0, [ 4227731327; 4227731327 ] -> 0, [ 4227731328; 4227731328 ] -> 16, [ 4227731329; 4227731329 ] -> 0, [ 4227731330; 4227731330 ] -> 0, [ 4227731331; 4227731331 ] -> 0, [ 4227731332; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3529 : BV:32
6 : Lambda28480 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28481 : BV:32
9 : 1970393374 { 0x7571d11e +1.88919425e107 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 462106276 { 0x1b8b2ea4 +1.8736085e184 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 14755217 { 0xe12591 +1.75895893e130 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1082724351 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1082724352; 1082724355 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1082724356; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4227731323 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4227731324; 4227731331 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4227731332; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 898120610 { 0x35883ba2 +1.6431984e236 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1691374669 { 0x64d0544d +1.62757265e74 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4227731324 { 0xfbfe0f7c -67235972 -1.98484754e120 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 269680496 { 0x1012ff70 +1.14842033e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1082724355 { 0x40891003 +1.7080113e2 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1838004491
=counter_example_end
=global nodece 61 num_edges_traversed 2
=global nodece 61 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 62
=global nodece 62 nodece z3v487.ce2726.num_edges_traversed3
=global nodece 62 nodece_path
=global nodece 62 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 62 nodece_cached_counterexample
=counter_example_begin z3v487.ce2726 bbe819dd7ffc421f75fa33e44e759292
=nextpc_const.1
1 : 1404898939 { 0x53bd0e7b +1.47700440e40 } : BV:32
=input.spec-%var-arr-1
1 : Lambda28459 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28460 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1073741812 { 0x3ffffff4 +1.99999856e0 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28462 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28463 : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28443 : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3522 : BV:32
4 : Lambda28466 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28467 : BV:32
7 : 284576080 { 0x10f64950 +1.92411231e162 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4227731323 ] -> 0, [ 4227731324; 4227731324 ] -> 0, [ 4227731325; 4227731325 ] -> 0, [ 4227731326; 4227731326 ] -> 0, [ 4227731327; 4227731327 ] -> 0, [ 4227731328; 4227731328 ] -> 16, [ 4227731329; 4227731329 ] -> 0, [ 4227731330; 4227731330 ] -> 0, [ 4227731331; 4227731331 ] -> 0, [ 4227731332; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 180 , m_adder -> 108), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1404898939 , 1000 , 8 ) -> 2059878344, () -> 688262655, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3529 : BV:32
6 : Lambda28480 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28481 : BV:32
9 : 1970393374 { 0x7571d11e +1.88919425e107 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 462106276 { 0x1b8b2ea4 +1.8736085e184 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2059878344 { 0x7ac73fc8 +1.55663394e118 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 14755217 { 0xe12591 +1.75895893e130 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1082724351 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1082724352; 1082724355 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1082724356; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4227731323 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4227731324; 4227731331 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4227731332; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 898120610 { 0x35883ba2 +1.6431984e236 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4227731323 ] -> 0, [ 4227731324; 4227731324 ] -> 0, [ 4227731325; 4227731325 ] -> 0, [ 4227731326; 4227731326 ] -> 0, [ 4227731327; 4227731327 ] -> 0, [ 4227731328; 4227731328 ] -> 16, [ 4227731329; 4227731329 ] -> 0, [ 4227731330; 4227731330 ] -> 0, [ 4227731331; 4227731331 ] -> 0, [ 4227731332; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1691374669 { 0x64d0544d +1.62757265e74 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4227731324 { 0xfbfe0f7c -67235972 -1.98484754e120 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 269680496 { 0x1012ff70 +1.14842033e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1082724355 { 0x40891003 +1.7080113e2 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 180 , m_adder -> 108), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
277082287
=counter_example_end
=global nodece 62 num_edges_traversed 3
=global nodece 62 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 63
=global nodece 63 nodece z3v487.ce2745.num_edges_traversed4
=global nodece 63 nodece_path
=global nodece 63 nodece_path.graph_edge_composition
(epsilon)
=global nodece 63 nodece_cached_counterexample
=counter_example_begin z3v487.ce2745 243e452eda668e19f6356906723a1ae
=nextpc_const.1
1 : 1404898939 { 0x53bd0e7b +1.47700440e40 } : BV:32
=input.spec-%var-arr-1
1 : Lambda28459 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28460 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1073741812 { 0x3ffffff4 +1.99999856e0 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28462 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28463 : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28443 : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3522 : BV:32
4 : Lambda28466 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28467 : BV:32
7 : 284576080 { 0x10f64950 +1.92411231e162 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 2059878343 ] -> 0, [ 2059878344; 2059878344 ] -> 0, [ 2059878345; 2059878345 ] -> 0, [ 2059878346; 2059878346 ] -> 0, [ 2059878347; 2059878347 ] -> 0, [ 2059878348; 2059878348 ] -> 124, [ 2059878349; 2059878349 ] -> 15, [ 2059878350; 2059878350 ] -> 254, [ 2059878351; 2059878351 ] -> 251, [ 2059878352; 4227731327 ] -> 0, [ 4227731328; 4227731328 ] -> 16, [ 4227731329; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 6 { 0x6 +1.71e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 180 , m_adder -> 108), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1404898939 , 1000 , 8 ) -> 2059878344, () -> 688262655, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3536 : BV:32
6 : Lambda28494 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28495 : BV:32
9 : 1970393374 { 0x7571d11e +1.88919425e107 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 462106277 { 0x1b8b2ea5 +1.8736097e184 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 14755218 { 0xe12592 +1.75895905e130 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1082724351 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1082724352; 1082724355 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1082724356; 2059878343 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2059878344; 2059878351 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2059878352; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4227731323 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4227731324; 4227731331 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4227731332; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 898120610 { 0x35883ba2 +1.6431984e236 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1691374669 { 0x64d0544d +1.62757265e74 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 6 { 0x6 +1.71e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 2059878344 { 0x7ac73fc8 +1.55663394e118 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 269680497 { 0x1012ff71 +1.14842045e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1082724355 { 0x40891003 +1.7080113e2 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 180 , m_adder -> 108), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
277082287
=counter_example_end
=global nodece 63 num_edges_traversed 4
=global nodece 63 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 64
=global nodece 64 nodece z3v487.ce2761.num_edges_traversed5
=global nodece 64 nodece_path
=global nodece 64 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 64 nodece_cached_counterexample
=counter_example_begin z3v487.ce2761 a7f4df8fd8fc9fc9b458c736cd33884d
=nextpc_const.1
1 : 1404898939 { 0x53bd0e7b +1.47700440e40 } : BV:32
=input.spec-%var-arr-1
1 : Lambda28459 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28460 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1073741812 { 0x3ffffff4 +1.99999856e0 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28462 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28463 : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28443 : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3522 : BV:32
4 : Lambda28466 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28467 : BV:32
7 : 284576080 { 0x10f64950 +1.92411231e162 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 2059878343 ] -> 0, [ 2059878344; 2059878344 ] -> 0, [ 2059878345; 2059878345 ] -> 0, [ 2059878346; 2059878346 ] -> 0, [ 2059878347; 2059878347 ] -> 0, [ 2059878348; 2059878348 ] -> 124, [ 2059878349; 2059878349 ] -> 15, [ 2059878350; 2059878350 ] -> 254, [ 2059878351; 2059878351 ] -> 251, [ 2059878352; 4227731327 ] -> 0, [ 4227731328; 4227731328 ] -> 16, [ 4227731329; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 6 { 0x6 +1.71e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 180 , m_adder -> 108), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1404898939 , 1000 , 8 ) -> 2059878344, () -> 688262655, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3536 : BV:32
6 : Lambda28494 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28495 : BV:32
9 : 1970393374 { 0x7571d11e +1.88919425e107 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 462106277 { 0x1b8b2ea5 +1.8736097e184 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 14755218 { 0xe12592 +1.75895905e130 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1082724351 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1082724352; 1082724355 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1082724356; 2059878343 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2059878344; 2059878351 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2059878352; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4227731323 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4227731324; 4227731331 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4227731332; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 898120610 { 0x35883ba2 +1.6431984e236 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1691374669 { 0x64d0544d +1.62757265e74 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 6 { 0x6 +1.71e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 2059878344 { 0x7ac73fc8 +1.55663394e118 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 269680497 { 0x1012ff71 +1.14842045e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1082724355 { 0x40891003 +1.7080113e2 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 180 , m_adder -> 108), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
277082287
=counter_example_end
=global nodece 64 num_edges_traversed 5
=global nodece 64 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 65
=global nodece 65 nodece z3v487.ce2771.num_edges_traversed6
=global nodece 65 nodece_path
=global nodece 65 nodece_path.graph_edge_composition
(epsilon)
=global nodece 65 nodece_cached_counterexample
=counter_example_begin z3v487.ce2771 c35193405c29443187a6ebac2bca32
=nextpc_const.1
1 : 1404898939 { 0x53bd0e7b +1.47700440e40 } : BV:32
=input.spec-%var-arr-1
1 : Lambda28459 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28460 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1073741812 { 0x3ffffff4 +1.99999856e0 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28462 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28463 : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28443 : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3522 : BV:32
4 : Lambda28466 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28467 : BV:32
7 : 284576080 { 0x10f64950 +1.92411231e162 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 2059878343 ] -> 0, [ 2059878344; 2059878344 ] -> 0, [ 2059878345; 2059878345 ] -> 0, [ 2059878346; 2059878346 ] -> 0, [ 2059878347; 2059878347 ] -> 0, [ 2059878348; 2059878348 ] -> 124, [ 2059878349; 2059878349 ] -> 15, [ 2059878350; 2059878350 ] -> 254, [ 2059878351; 2059878351 ] -> 251, [ 2059878352; 4227731327 ] -> 0, [ 4227731328; 4227731328 ] -> 16, [ 4227731329; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 6 { 0x6 +1.71e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 180 , m_adder -> 108), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1404898939 , 1000 , 8 ) -> 2059878344, () -> 688262655, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform3536 : BV:32
6 : Lambda28494 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28495 : BV:32
9 : 1970393374 { 0x7571d11e +1.88919425e107 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 462106277 { 0x1b8b2ea5 +1.8736097e184 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2059878344 { 0x7ac73fc8 +1.55663394e118 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 14755218 { 0xe12592 +1.75895905e130 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1082724351 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1082724352; 1082724355 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1082724356; 2059878343 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2059878344; 2059878351 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2059878352; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4227731323 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4227731324; 4227731331 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4227731332; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 898120610 { 0x35883ba2 +1.6431984e236 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 2059878343 ] -> 0, [ 2059878344; 2059878344 ] -> 0, [ 2059878345; 2059878345 ] -> 0, [ 2059878346; 2059878346 ] -> 0, [ 2059878347; 2059878347 ] -> 0, [ 2059878348; 2059878348 ] -> 124, [ 2059878349; 2059878349 ] -> 15, [ 2059878350; 2059878350 ] -> 254, [ 2059878351; 2059878351 ] -> 251, [ 2059878352; 4227731327 ] -> 0, [ 4227731328; 4227731328 ] -> 16, [ 4227731329; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1691374669 { 0x64d0544d +1.62757265e74 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 6 { 0x6 +1.71e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 2059878344 { 0x7ac73fc8 +1.55663394e118 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 269680497 { 0x1012ff71 +1.14842045e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1082724352 { 0x40891000 +1.7080078e2 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1082724355 { 0x40891003 +1.7080113e2 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 180 , m_adder -> 108), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
277082287
=counter_example_end
=global nodece 65 num_edges_traversed 6
=global nodece 65 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 66
=global nodece 66 nodece z3v487.ce2781.num_edges_traversed1
=global nodece 66 nodece_path
=global nodece 66 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 66 nodece_cached_counterexample
=counter_example_begin z3v487.ce2781 2693f62642f74289684aba8957a11a9
=input.spec-%var-arr-1
1 : Lambda28692 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28693 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 816120192 { 0x30a50180 +1.28910827e226 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28695 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28696 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28676 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 11 { 0xb +1.131e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 12 { 0xc +1.143e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3560 : BV:32
4 : Lambda28699 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28700 : BV:32
7 : 674018382 { 0x282cb44e +1.34925246e209 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 32768 { 0x8000 +1.390625e129 } : BV:32
3 : unit : UNIT
4 : Indxform3561 : BV:32
5 : Lambda28701 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda28702 : BV:32
8 : 1960319801 { 0x74d81b39 +1.68833076e106 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(1, 3, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(1, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(1, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(2, 3, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(1, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 32768 { 0x8000 +1.390625e129 } : BV:32
5 : Indxform3563 : BV:32
6 : Lambda28705 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28706 : BV:32
9 : 1960319801 { 0x74d81b39 +1.68833076e106 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 268435455 ] -> 0, [ 268435456; 268435456 ] -> 0, [ 268435457; 268435457 ] -> 0, [ 268435458; 268435458 ] -> 0, [ 268435459; 268435459 ] -> 0, [ 268435460; 268435460 ] -> 0, [ 268435461; 268435461 ] -> 0, [ 268435462; 268435462 ] -> 0, [ 268435463; 268435463 ] -> 128, [ 268435464; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 32768 { 0x8000 +1.390625e129 } : BV:32
5 : Indxform3565 : BV:32
6 : Lambda28709 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28710 : BV:32
9 : 1960319801 { 0x74d81b39 +1.68833076e106 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 32768 { 0x8000 +1.390625e129 } : BV:32
5 : Indxform3567 : BV:32
6 : Lambda28713 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28714 : BV:32
9 : 1960319801 { 0x74d81b39 +1.68833076e106 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 580794013 { 0x229e369d +1.23604166e198 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 268435456 { 0x10000000 +1.0e161 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 430713639 { 0x19ac2b27 +1.34506690e180 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 749343612 { 0x2caa137c +1.32871961e218 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 268435455 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435456; 268435463 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268435464; 816120219 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 816120220; 816120223 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 816120224; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 430713639 { 0x19ac2b27 +1.34506690e180 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1189103141 { 0x46e04625 +1.75214064e14 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 268435456 { 0x10000000 +1.0e161 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1338289596 { 0x4fc4adbc +1.53655195e32 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 816120192 { 0x30a50180 +1.28910827e226 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 268435455 ] -> 0, [ 268435456; 268435463 ] -> 123, [ 268435464; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1189103141 { 0x46e04625 +1.75214064e14 } : BV:32
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 268435455 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435456; 268435463 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268435464; 816120219 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 816120220; 816120223 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 816120224; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 749343612 { 0x2caa137c +1.32871961e218 } : COUNT
=input.dst.llvm-%call.Lfor.body%2%d
1 : 268435456 { 0x10000000 +1.0e161 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 28 { 0x1c +1.333e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 268435460 { 0x10000004 +1.47e161 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 816120220 { 0x30a5019c +1.28911161e226 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 268435456 { 0x10000000 +1.0e161 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 28 { 0x1c +1.333e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 816120220 { 0x30a5019c +1.28911161e226 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 268435456 { 0x10000000 +1.0e161 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 268435456 { 0x10000000 +1.0e161 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 268435460 { 0x10000004 +1.47e161 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 268435456 { 0x10000000 +1.0e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2817587545
=counter_example_end
=global nodece 66 num_edges_traversed 1
=global nodece 66 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 67
=global nodece 67 nodece z3v487.ce2812.num_edges_traversed2
=global nodece 67 nodece_path
=global nodece 67 nodece_path.graph_edge_composition
(epsilon)
=global nodece 67 nodece_cached_counterexample
=counter_example_begin z3v487.ce2812 1c9346d923b5bd2b25cb7fc984ae9e
=input.spec-%var-arr-1
1 : Lambda28692 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28693 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 816120192 { 0x30a50180 +1.28910827e226 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28695 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28696 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28676 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 11 { 0xb +1.131e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 12 { 0xc +1.143e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3560 : BV:32
4 : Lambda28699 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28700 : BV:32
7 : 674018382 { 0x282cb44e +1.34925246e209 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 268435455 ] -> 0, [ 268435456; 268435456 ] -> 0, [ 268435457; 268435457 ] -> 0, [ 268435458; 268435458 ] -> 0, [ 268435459; 268435459 ] -> 0, [ 268435460; 268435460 ] -> 0, [ 268435461; 268435461 ] -> 0, [ 268435462; 268435462 ] -> 0, [ 268435463; 268435463 ] -> 128, [ 268435464; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 32768 { 0x8000 +1.390625e129 } : BV:32
5 : Indxform3567 : BV:32
6 : Lambda28713 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28714 : BV:32
9 : 1960319801 { 0x74d81b39 +1.68833076e106 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 580794013 { 0x229e369d +1.23604166e198 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 749343612 { 0x2caa137c +1.32871961e218 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 268435455 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435456; 268435463 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268435464; 816120219 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 816120220; 816120223 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 816120224; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 430713639 { 0x19ac2b27 +1.34506690e180 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1189103141 { 0x46e04625 +1.75214064e14 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 268435456 { 0x10000000 +1.0e161 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1338289596 { 0x4fc4adbc +1.53655195e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2817587545
=counter_example_end
=global nodece 67 num_edges_traversed 2
=global nodece 67 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 68
=global nodece 68 nodece z3v487.ce2816.num_edges_traversed3
=global nodece 68 nodece_path
=global nodece 68 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 68 nodece_cached_counterexample
=counter_example_begin z3v487.ce2816 631c11401a187e1f6773207098977b8d
=nextpc_const.1
1 : 378540022 { 0x16900ff6 +1.12548708e174 } : BV:32
=input.spec-%var-arr-1
1 : Lambda28692 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28693 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 816120192 { 0x30a50180 +1.28910827e226 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28695 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28696 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28676 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 11 { 0xb +1.131e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 12 { 0xc +1.143e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3560 : BV:32
4 : Lambda28699 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28700 : BV:32
7 : 674018382 { 0x282cb44e +1.34925246e209 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 268435455 ] -> 0, [ 268435456; 268435456 ] -> 0, [ 268435457; 268435457 ] -> 0, [ 268435458; 268435458 ] -> 0, [ 268435459; 268435459 ] -> 0, [ 268435460; 268435460 ] -> 0, [ 268435461; 268435461 ] -> 0, [ 268435462; 268435462 ] -> 0, [ 268435463; 268435463 ] -> 128, [ 268435464; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 142 , m_adder -> 132), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 378540022 , 1000 , 8 ) -> 1957607768, () -> 1245429935, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 32768 { 0x8000 +1.390625e129 } : BV:32
5 : Indxform3567 : BV:32
6 : Lambda28713 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28714 : BV:32
9 : 1960319801 { 0x74d81b39 +1.68833076e106 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 580794013 { 0x229e369d +1.23604166e198 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1957607768 { 0x74aeb958 +1.36503124e106 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 749343612 { 0x2caa137c +1.32871961e218 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 268435455 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435456; 268435463 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268435464; 816120219 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 816120220; 816120223 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 816120224; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 430713639 { 0x19ac2b27 +1.34506690e180 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 268435455 ] -> 0, [ 268435456; 268435456 ] -> 0, [ 268435457; 268435457 ] -> 0, [ 268435458; 268435458 ] -> 0, [ 268435459; 268435459 ] -> 0, [ 268435460; 268435460 ] -> 0, [ 268435461; 268435461 ] -> 0, [ 268435462; 268435462 ] -> 0, [ 268435463; 268435463 ] -> 128, [ 268435464; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1189103141 { 0x46e04625 +1.75214064e14 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 268435456 { 0x10000000 +1.0e161 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1338289596 { 0x4fc4adbc +1.53655195e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 142 , m_adder -> 132), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1221346845
=counter_example_end
=global nodece 68 num_edges_traversed 3
=global nodece 68 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 69
=global nodece 69 nodece z3v487.ce2835.num_edges_traversed4
=global nodece 69 nodece_path
=global nodece 69 nodece_path.graph_edge_composition
(epsilon)
=global nodece 69 nodece_cached_counterexample
=counter_example_begin z3v487.ce2835 5cf6637de6647e7689a5bdcbdf2da4
=nextpc_const.1
1 : 378540022 { 0x16900ff6 +1.12548708e174 } : BV:32
=input.spec-%var-arr-1
1 : Lambda28692 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28693 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 816120192 { 0x30a50180 +1.28910827e226 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28695 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28696 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28676 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 11 { 0xb +1.131e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 12 { 0xc +1.143e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3560 : BV:32
4 : Lambda28699 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28700 : BV:32
7 : 674018382 { 0x282cb44e +1.34925246e209 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 268435462 ] -> 0, [ 268435463; 268435463 ] -> 128, [ 268435464; 1957607767 ] -> 0, [ 1957607768; 1957607768 ] -> 0, [ 1957607769; 1957607769 ] -> 0, [ 1957607770; 1957607770 ] -> 0, [ 1957607771; 1957607771 ] -> 0, [ 1957607772; 1957607772 ] -> 0, [ 1957607773; 1957607773 ] -> 0, [ 1957607774; 1957607774 ] -> 0, [ 1957607775; 1957607775 ] -> 16, [ 1957607776; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 142 , m_adder -> 132), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 378540022 , 1000 , 8 ) -> 1957607768, () -> 1245429935, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 32768 { 0x8000 +1.390625e129 } : BV:32
5 : Indxform3574 : BV:32
6 : Lambda28727 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28728 : BV:32
9 : 1960319801 { 0x74d81b39 +1.68833076e106 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 580794014 { 0x229e369e +1.23604178e198 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 749343613 { 0x2caa137d +1.32871973e218 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 268435455 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435456; 268435463 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268435464; 816120219 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 816120220; 816120223 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 816120224; 1957607767 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1957607768; 1957607775 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1957607776; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 430713639 { 0x19ac2b27 +1.34506690e180 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1189103141 { 0x46e04625 +1.75214064e14 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1957607768 { 0x74aeb958 +1.36503124e106 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1338289597 { 0x4fc4adbd +1.53655207e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 142 , m_adder -> 132), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1221346845
=counter_example_end
=global nodece 69 num_edges_traversed 4
=global nodece 69 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 70
=global nodece 70 nodece z3v487.ce2851.num_edges_traversed5
=global nodece 70 nodece_path
=global nodece 70 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 70 nodece_cached_counterexample
=counter_example_begin z3v487.ce2851 e62af86a3a3adc4becc8461299628ae6
=nextpc_const.1
1 : 378540022 { 0x16900ff6 +1.12548708e174 } : BV:32
=input.spec-%var-arr-1
1 : Lambda28692 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28693 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 816120192 { 0x30a50180 +1.28910827e226 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28695 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28696 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28676 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 11 { 0xb +1.131e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 12 { 0xc +1.143e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3560 : BV:32
4 : Lambda28699 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28700 : BV:32
7 : 674018382 { 0x282cb44e +1.34925246e209 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 268435462 ] -> 0, [ 268435463; 268435463 ] -> 128, [ 268435464; 1957607767 ] -> 0, [ 1957607768; 1957607768 ] -> 0, [ 1957607769; 1957607769 ] -> 0, [ 1957607770; 1957607770 ] -> 0, [ 1957607771; 1957607771 ] -> 0, [ 1957607772; 1957607772 ] -> 0, [ 1957607773; 1957607773 ] -> 0, [ 1957607774; 1957607774 ] -> 0, [ 1957607775; 1957607775 ] -> 16, [ 1957607776; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 142 , m_adder -> 132), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 378540022 , 1000 , 8 ) -> 1957607768, () -> 1245429935, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 32768 { 0x8000 +1.390625e129 } : BV:32
5 : Indxform3574 : BV:32
6 : Lambda28727 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28728 : BV:32
9 : 1960319801 { 0x74d81b39 +1.68833076e106 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 580794014 { 0x229e369e +1.23604178e198 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 749343613 { 0x2caa137d +1.32871973e218 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 268435455 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435456; 268435463 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268435464; 816120219 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 816120220; 816120223 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 816120224; 1957607767 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1957607768; 1957607775 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1957607776; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 430713639 { 0x19ac2b27 +1.34506690e180 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1189103141 { 0x46e04625 +1.75214064e14 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1957607768 { 0x74aeb958 +1.36503124e106 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1338289597 { 0x4fc4adbd +1.53655207e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 142 , m_adder -> 132), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1221346845
=counter_example_end
=global nodece 70 num_edges_traversed 5
=global nodece 70 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 71
=global nodece 71 nodece z3v487.ce2861.num_edges_traversed6
=global nodece 71 nodece_path
=global nodece 71 nodece_path.graph_edge_composition
(epsilon)
=global nodece 71 nodece_cached_counterexample
=counter_example_begin z3v487.ce2861 1a7fe65b7c839abd450ef8be8d036ee
=nextpc_const.1
1 : 378540022 { 0x16900ff6 +1.12548708e174 } : BV:32
=input.spec-%var-arr-1
1 : Lambda28692 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28693 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 816120192 { 0x30a50180 +1.28910827e226 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28695 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 11 { 0xb +1.131e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 12 { 0xc +1.143e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28696 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28676 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 11 { 0xb +1.131e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 12 { 0xc +1.143e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3560 : BV:32
4 : Lambda28699 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28700 : BV:32
7 : 674018382 { 0x282cb44e +1.34925246e209 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 11 ] -> true, [ 12; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 268435462 ] -> 0, [ 268435463; 268435463 ] -> 128, [ 268435464; 1957607767 ] -> 0, [ 1957607768; 1957607768 ] -> 0, [ 1957607769; 1957607769 ] -> 0, [ 1957607770; 1957607770 ] -> 0, [ 1957607771; 1957607771 ] -> 0, [ 1957607772; 1957607772 ] -> 0, [ 1957607773; 1957607773 ] -> 0, [ 1957607774; 1957607774 ] -> 0, [ 1957607775; 1957607775 ] -> 16, [ 1957607776; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 142 , m_adder -> 132), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 378540022 , 1000 , 8 ) -> 1957607768, () -> 1245429935, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 32768 { 0x8000 +1.390625e129 } : BV:32
5 : Indxform3574 : BV:32
6 : Lambda28727 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28728 : BV:32
9 : 1960319801 { 0x74d81b39 +1.68833076e106 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 580794014 { 0x229e369e +1.23604178e198 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1957607768 { 0x74aeb958 +1.36503124e106 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 749343613 { 0x2caa137d +1.32871973e218 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 268435455 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435456; 268435463 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268435464; 816120219 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 816120220; 816120223 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 816120224; 1957607767 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1957607768; 1957607775 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1957607776; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 430713639 { 0x19ac2b27 +1.34506690e180 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 268435462 ] -> 0, [ 268435463; 268435463 ] -> 128, [ 268435464; 1957607767 ] -> 0, [ 1957607768; 1957607768 ] -> 0, [ 1957607769; 1957607769 ] -> 0, [ 1957607770; 1957607770 ] -> 0, [ 1957607771; 1957607771 ] -> 0, [ 1957607772; 1957607772 ] -> 0, [ 1957607773; 1957607773 ] -> 0, [ 1957607774; 1957607774 ] -> 0, [ 1957607775; 1957607775 ] -> 16, [ 1957607776; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1189103141 { 0x46e04625 +1.75214064e14 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1957607768 { 0x74aeb958 +1.36503124e106 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1338289597 { 0x4fc4adbd +1.53655207e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 142 , m_adder -> 132), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1221346845
=counter_example_end
=global nodece 71 num_edges_traversed 6
=global nodece 71 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 72
=global nodece 72 nodece z3v487.ce2871.num_edges_traversed1
=global nodece 72 nodece_path
=global nodece 72 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 72 nodece_cached_counterexample
=counter_example_begin z3v487.ce2871 f77aca68d11bf88dc965f7b811262263
=input.spec-%var-arr-1
1 : Lambda28925 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28926 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 825181252 { 0x312f4444 +1.36927080e227 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28928 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28929 : BV:32
18 : 8 { 0x8 +1.95e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28909 : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3598 : BV:32
4 : Lambda28932 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28933 : BV:32
7 : 1270914409 { 0x4bc09d69 +1.50480377e24 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 2 { 0x2 +1.23e129 } : BV:32
3 : unit : UNIT
4 : Indxform3599 : BV:32
5 : Lambda28934 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda28935 : BV:32
8 : 152746573 { 0x91aba4d +1.20881044e147 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(1, 3, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(1, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(1, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(2, 3, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(1, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2 { 0x2 +1.23e129 } : BV:32
5 : Indxform3601 : BV:32
6 : Lambda28938 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28939 : BV:32
9 : 152746573 { 0x91aba4d +1.20881044e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 55215503 ] -> 0, [ 55215504; 55215504 ] -> 0, [ 55215505; 55215505 ] -> 0, [ 55215506; 55215506 ] -> 0, [ 55215507; 55215507 ] -> 0, [ 55215508; 55215508 ] -> 0, [ 55215509; 55215509 ] -> 0, [ 55215510; 55215510 ] -> 0, [ 55215511; 55215511 ] -> 4, [ 55215512; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2 { 0x2 +1.23e129 } : BV:32
5 : Indxform3603 : BV:32
6 : Lambda28942 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28943 : BV:32
9 : 152746573 { 0x91aba4d +1.20881044e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 46318868 { 0x2c2c514 +1.52163934e134 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2 { 0x2 +1.23e129 } : BV:32
5 : Indxform3605 : BV:32
6 : Lambda28946 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28947 : BV:32
9 : 152746573 { 0x91aba4d +1.20881044e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 481891059 { 0x1cb912f3 +1.44589078e186 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 55215504 { 0x34a8590 +1.58220100e135 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1830219325 { 0x6d16ee3d +1.17914545e91 } : BV:32
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 316558196 { 0x12de4b74 +1.73667764e166 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 46318867 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 46318868; 46318871 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 46318872; 55215503 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 55215504; 55215511 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 55215512; 825181283 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 825181284; 825181287 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 825181288; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1830219325 { 0x6d16ee3d +1.17914545e91 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 961943475 { 0x395617b3 +1.67259824e243 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 55215504 { 0x34a8590 +1.58220100e135 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1955988510 { 0x7496041e +1.17200064e106 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 825181252 { 0x312f4444 +1.36927080e227 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 55215503 ] -> 0, [ 55215504; 55215511 ] -> 115, [ 55215512; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 961943475 { 0x395617b3 +1.67259824e243 } : BV:32
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 67108864 { 0x4000000 +1.0e137 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 46318867 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 46318868; 46318871 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 46318872; 55215503 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 55215504; 55215511 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 55215512; 825181283 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 825181284; 825181287 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 825181288; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 316558196 { 0x12de4b74 +1.73667764e166 } : COUNT
=input.dst.llvm-%call.Lfor.body%2%d
1 : 55215504 { 0x34a8590 +1.58220100e135 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 55215508 { 0x34a8594 +1.58220148e135 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 825181284 { 0x312f4464 +1.36927461e227 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 55215504 { 0x34a8590 +1.58220100e135 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 825181284 { 0x312f4464 +1.36927461e227 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 55215504 { 0x34a8590 +1.58220100e135 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 55215504 { 0x34a8590 +1.58220100e135 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 55215508 { 0x34a8594 +1.58220148e135 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 55215504 { 0x34a8590 +1.58220100e135 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 46318868 { 0x2c2c514 +1.52163934e134 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 46318871 { 0x2c2c517 +1.52163970e134 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3600121475
=counter_example_end
=global nodece 72 num_edges_traversed 1
=global nodece 72 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 73
=global nodece 73 nodece z3v487.ce2902.num_edges_traversed2
=global nodece 73 nodece_path
=global nodece 73 nodece_path.graph_edge_composition
(epsilon)
=global nodece 73 nodece_cached_counterexample
=counter_example_begin z3v487.ce2902 de218826865ebfa8be15551dfb8b
=input.spec-%var-arr-1
1 : Lambda28925 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28926 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 825181252 { 0x312f4444 +1.36927080e227 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28928 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28929 : BV:32
18 : 8 { 0x8 +1.95e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28909 : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3598 : BV:32
4 : Lambda28932 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28933 : BV:32
7 : 1270914409 { 0x4bc09d69 +1.50480377e24 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 55215503 ] -> 0, [ 55215504; 55215504 ] -> 0, [ 55215505; 55215505 ] -> 0, [ 55215506; 55215506 ] -> 0, [ 55215507; 55215507 ] -> 0, [ 55215508; 55215508 ] -> 0, [ 55215509; 55215509 ] -> 0, [ 55215510; 55215510 ] -> 0, [ 55215511; 55215511 ] -> 4, [ 55215512; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 46318868 { 0x2c2c514 +1.52163934e134 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2 { 0x2 +1.23e129 } : BV:32
5 : Indxform3605 : BV:32
6 : Lambda28946 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28947 : BV:32
9 : 152746573 { 0x91aba4d +1.20881044e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 481891059 { 0x1cb912f3 +1.44589078e186 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 316558196 { 0x12de4b74 +1.73667764e166 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 46318867 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 46318868; 46318871 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 46318872; 55215503 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 55215504; 55215511 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 55215512; 825181283 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 825181284; 825181287 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 825181288; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1830219325 { 0x6d16ee3d +1.17914545e91 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 961943475 { 0x395617b3 +1.67259824e243 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 55215504 { 0x34a8590 +1.58220100e135 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1955988510 { 0x7496041e +1.17200064e106 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 46318868 { 0x2c2c514 +1.52163934e134 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 46318871 { 0x2c2c517 +1.52163970e134 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3600121475
=counter_example_end
=global nodece 73 num_edges_traversed 2
=global nodece 73 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 74
=global nodece 74 nodece z3v487.ce2906.num_edges_traversed3
=global nodece 74 nodece_path
=global nodece 74 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 74 nodece_cached_counterexample
=counter_example_begin z3v487.ce2906 d24e1448366f3b48c065bdcefeb8485
=nextpc_const.1
1 : 1749595541 { 0x6848b595 +1.56804144e81 } : BV:32
=input.spec-%var-arr-1
1 : Lambda28925 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28926 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 825181252 { 0x312f4444 +1.36927080e227 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda28928 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda28929 : BV:32
18 : 8 { 0x8 +1.95e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda28909 : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3598 : BV:32
4 : Lambda28932 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda28933 : BV:32
7 : 1270914409 { 0x4bc09d69 +1.50480377e24 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 55215503 ] -> 0, [ 55215504; 55215504 ] -> 0, [ 55215505; 55215505 ] -> 0, [ 55215506; 55215506 ] -> 0, [ 55215507; 55215507 ] -> 0, [ 55215508; 55215508 ] -> 0, [ 55215509; 55215509 ] -> 0, [ 55215510; 55215510 ] -> 0, [ 55215511; 55215511 ] -> 4, [ 55215512; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 46318868 { 0x2c2c514 +1.52163934e134 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 244 , m_adder -> 42), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1749595541 , 1000 , 8 ) -> 94560105, () -> 1261122936, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2 { 0x2 +1.23e129 } : BV:32
5 : Indxform3605 : BV:32
6 : Lambda28946 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda28947 : BV:32
9 : 152746573 { 0x91aba4d +1.20881044e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 481891059 { 0x1cb912f3 +1.44589078e186 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 94560105 { 0x5a2df69 +1.27244293e140 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 316558196 { 0x12de4b74 +1.73667764e166 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 46318867 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 46318868; 46318871 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 46318872; 55215503 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 55215504; 55215511 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 55215512; 825181283 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 825181284; 825181287 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 825181288; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1830219325 { 0x6d16ee3d +1.17914545e91 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 55215503 ] -> 0, [ 55215504; 55215504 ] -> 0, [ 55215505; 55215505 ] -> 0, [ 55215506; 55215506 ] -> 0, [ 55215507; 55215507 ] -> 0, [ 55215508; 55215508 ] -> 0, [ 55215509; 55215509 ] -> 0, [ 55215510; 55215510 ] -> 0, [ 55215511; 55215511 ] -> 4, [ 55215512; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 961943475 { 0x395617b3 +1.67259824e243 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 55215504 { 0x34a8590 +1.58220100e135 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1955988510 { 0x7496041e +1.17200064e106 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 46318868 { 0x2c2c514 +1.52163934e134 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 46318871 { 0x2c2c517 +1.52163970e134 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 244 , m_adder -> 42), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1525319335
=counter_example_end
=global nodece 74 num_edges_traversed 3
=global nodece 74 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 75
=global nodece 75 nodece z3v487.ce2938.num_edges_traversed1
=global nodece 75 nodece_path
=global nodece 75 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 75 nodece_cached_counterexample
=counter_example_begin z3v487.ce2938 24a0873bc3fc18e25c4cb96ad9bba3d
=input.spec-%var-arr-1
1 : Lambda29621 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 285938761 { 0x110b1449 +1.8655655e163 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 285938762 { 0x110b144a +1.8655667e163 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda29622 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda29624 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 285938761 { 0x110b1449 +1.8655655e163 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 285938762 { 0x110b144a +1.8655667e163 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda29625 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 285938761 ] -> true, [ 285938762; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda29592 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 285938761 { 0x110b1449 +1.8655655e163 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 285938762 { 0x110b144a +1.8655667e163 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3677 : BV:32
4 : Lambda29628 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda29629 : BV:32
7 : 2078131908 { 0x7bddc6c4 +1.73262834e120 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 285938761 ] -> true, [ 285938762; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1509961344 { 0x5a002e80 +1.141906e53 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 285938762 { 0x110b144a +1.8655667e163 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 71535141 { 0x4438a25 +1.52765333e137 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 16777216 { 0x1000000 +1.0e131 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3676 : BV:32
5 : Lambda29626 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda29627 : BV:32
8 : 699225617 { 0x29ad5611 +1.35418903e212 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2147483641 { 0x7ffffff9 +1.99999916e128 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 1509961343 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1509961344; 1509961347 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1509961348; 2147483640 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483641; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 71535141 { 0x4438a25 +1.52765333e137 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1509961344 { 0x5a002e80 +1.141906e53 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1509961347 { 0x5a002e83 +1.141942e53 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 16777216 { 0x1000000 +1.0e131 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1094348620
=counter_example_end
=global nodece 75 num_edges_traversed 1
=global nodece 75 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 76
=global nodece 76 nodece z3v487.ce2952.num_edges_traversed2
=global nodece 76 nodece_path
=global nodece 76 nodece_path.graph_edge_composition
(epsilon)
=global nodece 76 nodece_cached_counterexample
=counter_example_begin z3v487.ce2952 6a63258546a630b9ff8f1e89cd9c
=nextpc_const.1
1 : 1227325228 { 0x49277f2c +1.30856847e19 } : BV:32
=input.spec-%var-arr-1
1 : Lambda29621 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 285938761 { 0x110b1449 +1.8655655e163 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 285938762 { 0x110b144a +1.8655667e163 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda29622 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda29624 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 285938761 { 0x110b1449 +1.8655655e163 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 285938762 { 0x110b144a +1.8655667e163 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda29625 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 285938761 ] -> true, [ 285938762; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda29592 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 285938761 { 0x110b1449 +1.8655655e163 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 285938762 { 0x110b144a +1.8655667e163 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform3677 : BV:32
4 : Lambda29628 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda29629 : BV:32
7 : 2078131908 { 0x7bddc6c4 +1.73262834e120 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 285938761 ] -> true, [ 285938762; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1509961344 { 0x5a002e80 +1.141906e53 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 285938762 { 0x110b144a +1.8655667e163 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 71535141 { 0x4438a25 +1.52765333e137 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 202 , m_adder -> 183), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1227325228 , 1000 , 8 ) -> 963596164, () -> 1838790607, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 16777216 { 0x1000000 +1.0e131 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform3676 : BV:32
5 : Lambda29626 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda29627 : BV:32
8 : 699225617 { 0x29ad5611 +1.35418903e212 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : sym_const(14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 963596164 { 0x396f4f84 +1.86961412e243 } : BV:32
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 1509961343 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1509961344; 1509961347 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1509961348; 2147483640 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483641; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 71535141 { 0x4438a25 +1.52765333e137 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1509961344 { 0x5a002e80 +1.141906e53 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1509961347 { 0x5a002e83 +1.141942e53 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 16777216 { 0x1000000 +1.0e131 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 202 , m_adder -> 183), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2532060640
=counter_example_end
=global nodece 76 num_edges_traversed 2
=global nodece 76 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=graph_with_ce done
=point_set for reason inductive-invariants
=inductive-invariants point_set global exprs map
=inductive-invariants point_set point_expr 1
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=inductive-invariants point_set point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=inductive-invariants point_set point_expr 3
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=inductive-invariants point_set point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=inductive-invariants point_set point_expr 5
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=inductive-invariants point_set point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=inductive-invariants point_set point_expr 7
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=inductive-invariants point_set point_expr 8
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=inductive-invariants point_set point_expr 9
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=inductive-invariants point_set point_expr 10
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=inductive-invariants point_set point_expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=inductive-invariants point_set point_expr 12
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=inductive-invariants point_set point_expr 13
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=inductive-invariants point_set point_expr 14
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=inductive-invariants point_set point_expr 15
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 16
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 17
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : bvadd(14, 5) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(10, 11, 12, 15, 16, 17) : BV:32
19 : lambda(9, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(8, 19) : MAP[BV:32 -> BV:32]
21 : eq(1, 20) : BOOL
=inductive-invariants point_set point_expr 18
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 19
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 20
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 21
1 : spec-%tmpvar-10.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 0 { 0x0 +1.0e1025 } : INT
4 : unit : UNIT
5 : sum_init(2, 3, 4) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : eq(1, 5) : BOOL
=inductive-invariants point_set point_expr 22
1 : spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 23
1 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 0 { 0x0 +1.0e1025 } : INT
4 : unit : UNIT
5 : sum_init(2, 3, 4) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : eq(1, 5) : BOOL
=inductive-invariants point_set point_expr 24
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 25
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 26
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 27
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 28
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=inductive-invariants point_set point_expr 29
1 : spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : input.spec-%var-i-0.L3%6%bbentry : BV:32
23 : map_get(21, 22) : SUM[UNIT,BV:32]
24 : eq(1, 23) : BOOL
=inductive-invariants point_set point_expr 30
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 31
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%tmpvar-1.L3%6%bbentry : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
27 : sum_get(22, 23) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(26, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : eq(25, 42) : BOOL
44 : and(24, 43) : BOOL
=inductive-invariants point_set point_expr 32
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%tmpvar-2.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 33
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%var-new_l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 34
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 35
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(14, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=inductive-invariants point_set point_expr 36
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 37
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(4, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=inductive-invariants point_set point_expr 38
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : bvadd(13, 4) : BV:32
15 : 4 { 0x4 +1.0e1025 } : INT
16 : 0 { 0x0 } : BOOL
17 : select(9, 10, 11, 14, 15, 16) : BV:32
18 : lambda(8, 17) : FUNCTION[BV:32 -> BV:32]
19 : map(7, 18) : MAP[BV:32 -> BV:32]
20 : input.spec-%var-i-0.L3%6%bbentry : BV:32
21 : map_get(19, 20) : SUM[UNIT,BV:32]
22 : 1 { 0x1 +1.0e1025 } : INT
23 : sum_is(21, 22) : BOOL
24 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
27 : sum_get(21, 22) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 15, 16) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 15, 16) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(26, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(25, 22, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(24, 43) : BOOL
45 : and(23, 44) : BOOL
=inductive-invariants point_set point_expr 39
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 40
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(4, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=inductive-invariants point_set point_expr 41
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=inductive-invariants point_set point_expr 42
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 43
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 44
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : bvadd(14, 5) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(10, 11, 12, 15, 16, 17) : BV:32
19 : lambda(9, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(8, 19) : MAP[BV:32 -> BV:32]
21 : eq(1, 20) : BOOL
=inductive-invariants point_set point_expr 45
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 46
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 47
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 48
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 49
1 : spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : input.spec-%var-i-0.L3%6%bbentry : BV:32
23 : map_get(21, 22) : SUM[UNIT,BV:32]
24 : eq(1, 23) : BOOL
=inductive-invariants point_set point_expr 50
1 : spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 51
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 52
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%tmpvar-1.L3%6%bbentry : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
27 : sum_get(22, 23) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(26, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : eq(25, 42) : BOOL
44 : and(24, 43) : BOOL
=inductive-invariants point_set point_expr 53
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%tmpvar-2.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 54
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%var-new_l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 55
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 56
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 57
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 58
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 59
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 60
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 61
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(14, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=inductive-invariants point_set point_expr 62
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 63
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(4, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=inductive-invariants point_set point_expr 64
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : bvadd(13, 4) : BV:32
15 : 4 { 0x4 +1.0e1025 } : INT
16 : 0 { 0x0 } : BOOL
17 : select(9, 10, 11, 14, 15, 16) : BV:32
18 : lambda(8, 17) : FUNCTION[BV:32 -> BV:32]
19 : map(7, 18) : MAP[BV:32 -> BV:32]
20 : input.spec-%var-i-0.L3%6%bbentry : BV:32
21 : map_get(19, 20) : SUM[UNIT,BV:32]
22 : 1 { 0x1 +1.0e1025 } : INT
23 : sum_is(21, 22) : BOOL
24 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
27 : sum_get(21, 22) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 15, 16) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 15, 16) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(26, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(25, 22, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(24, 43) : BOOL
45 : and(23, 44) : BOOL
=inductive-invariants point_set point_expr 65
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 66
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(4, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=inductive-invariants point_set point_expr 67
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set point_expr 68
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=inductive-invariants point_set global exprs map done
=inductive-invariants point_set points
=inductive-invariants point_set point z3.ce6
=inductive-invariants point_set point z3.ce6 expr point z3.ce6
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2859808244
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce6 expr point z3.ce6 done
=inductive-invariants point_set point z3v487.ce20
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
262144
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 done
=inductive-invariants point_set point z3.ce19
=inductive-invariants point_set point z3.ce19 expr point z3.ce19
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4139645696
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
150402806
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 done
=inductive-invariants point_set point z3v487.ce42
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 done
=inductive-invariants point_set point z3.ce41
=inductive-invariants point_set point z3.ce41 expr point z3.ce41
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4294090240
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4076007937
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 done
=inductive-invariants point_set point z3v487.ce64
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4294967040
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4294967295
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 done
=inductive-invariants point_set point z3.ce63
=inductive-invariants point_set point z3.ce63 expr point z3.ce63
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3982394112
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4294967295
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 done
=inductive-invariants point_set point z3.ce1555
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4139645696
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
150402806
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
44611973
=inductive-invariants point_set point z3.ce1555 expr point z3.ce1555 done
=inductive-invariants point_set point z3v487.ce86
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 done
=inductive-invariants point_set point z3.ce85
=inductive-invariants point_set point z3.ce85 expr point z3.ce85
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4284083456
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
3991792897
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 done
=inductive-invariants point_set point z3.ce1549
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4294090240
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4076007937
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1081939524
=inductive-invariants point_set point z3.ce1549 expr point z3.ce1549 done
=inductive-invariants point_set point z3.ce121
=inductive-invariants point_set point z3.ce121 expr point z3.ce121
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3113745468
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce121 expr point z3.ce121 done
=inductive-invariants point_set point z3v487.ce122
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
806883344
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce122 expr point z3v487.ce122 done
=inductive-invariants point_set point z3.ce143
=inductive-invariants point_set point z3.ce143 expr point z3.ce143
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
322408992
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce143 expr point z3.ce143 done
=inductive-invariants point_set point z3v487.ce144
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
17825808
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce144 expr point z3v487.ce144 done
=inductive-invariants point_set point z3v487.ce165
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
17825808
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce165 expr point z3v487.ce165 done
=inductive-invariants point_set point z3.ce166
=inductive-invariants point_set point z3.ce166 expr point z3.ce166
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2122499072
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce166 expr point z3.ce166 done
=inductive-invariants point_set point z3v487.ce215
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce215 expr point z3v487.ce215 done
=inductive-invariants point_set point z3.ce214
=inductive-invariants point_set point z3.ce214 expr point z3.ce214
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3360983068
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
151007441
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce214 expr point z3.ce214 done
=inductive-invariants point_set point z3.ce688
=inductive-invariants point_set point z3.ce688 expr point z3.ce688
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce688 expr point z3.ce688 done
=inductive-invariants point_set point z3v487.ce692
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
16
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce692 expr point z3v487.ce692 done
=inductive-invariants point_set point z3v487.ce948
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce948 expr point z3v487.ce948 done
=inductive-invariants point_set point z3.ce947
=inductive-invariants point_set point z3.ce947 expr point z3.ce947
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce947 expr point z3.ce947 done
=inductive-invariants point_set point z3v487.ce973
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
131072
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce973 expr point z3v487.ce973 done
=inductive-invariants point_set point z3.ce974
=inductive-invariants point_set point z3.ce974 expr point z3.ce974
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8192
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce974 expr point z3.ce974 done
=inductive-invariants point_set point z3v487.ce1000
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
134217728
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1000 expr point z3v487.ce1000 done
=inductive-invariants point_set point z3.ce999
=inductive-invariants point_set point z3.ce999 expr point z3.ce999
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1048576
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce999 expr point z3.ce999 done
=inductive-invariants point_set point z3v487.ce1026
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4294967295
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1026 expr point z3v487.ce1026 done
=inductive-invariants point_set point z3.ce1025
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4294967295
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1025 expr point z3.ce1025 done
=inductive-invariants point_set point z3v487.ce1052
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1052 expr point z3v487.ce1052 done
=inductive-invariants point_set point z3.ce1051
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1051 expr point z3.ce1051 done
=inductive-invariants point_set point z3v487.ce1119
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
69287936
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1119 expr point z3v487.ce1119 done
=inductive-invariants point_set point z3.ce1120
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1284178436
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1120 expr point z3.ce1120 done
=inductive-invariants point_set point z3v487.ce1159
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
32768
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1159 expr point z3v487.ce1159 done
=inductive-invariants point_set point z3.ce1160
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8192
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1160 expr point z3.ce1160 done
=inductive-invariants point_set point z3v487.ce1199
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1879181440
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1199 expr point z3v487.ce1199 done
=inductive-invariants point_set point z3.ce1200
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2386657284
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1024
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1200 expr point z3.ce1200 done
=inductive-invariants point_set point z3v487.ce1293
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
524288
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1293 expr point z3v487.ce1293 done
=inductive-invariants point_set point z3.ce1294
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
256
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1294 expr point z3.ce1294 done
=inductive-invariants point_set point z3v487.ce1376
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
125831168
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
34639874
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1376 expr point z3v487.ce1376 done
=inductive-invariants point_set point z3.ce1375
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4067509440
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
21136962
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1375 expr point z3.ce1375 done
=inductive-invariants point_set point z3v487.ce1402
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
19269384
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
256
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1402 expr point z3v487.ce1402 done
=inductive-invariants point_set point z3.ce1401
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3430483348
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1401 expr point z3.ce1401 done
=inductive-invariants point_set point z3v487.ce1516
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
605829035
=inductive-invariants point_set point z3v487.ce1516 expr point z3v487.ce1516 done
=inductive-invariants point_set point z3.ce1519
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4096
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8192
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
707089864
=inductive-invariants point_set point z3.ce1519 expr point z3.ce1519 done
=inductive-invariants point_set point z3.ce1546
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3982394112
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4294967295
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1049355574
=inductive-invariants point_set point z3.ce1546 expr point z3.ce1546 done
=inductive-invariants point_set point z3v487.ce1552
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
262144
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1441260588
=inductive-invariants point_set point z3v487.ce1552 expr point z3v487.ce1552 done
=inductive-invariants point_set point z3v487.ce1804
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1199676058
=inductive-invariants point_set point z3v487.ce1804 expr point z3v487.ce1804 done
=inductive-invariants point_set point z3.ce1805
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
241671673
=inductive-invariants point_set point z3.ce1805 expr point z3.ce1805 done
=inductive-invariants point_set point z3v487.ce1829
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1354562492
=inductive-invariants point_set point z3v487.ce1829 expr point z3v487.ce1829 done
=inductive-invariants point_set point z3.ce1828
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1727686483
=inductive-invariants point_set point z3.ce1828 expr point z3.ce1828 done
=inductive-invariants point_set point z3v487.ce1866
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1132535372
=inductive-invariants point_set point z3v487.ce1866 expr point z3v487.ce1866 done
=inductive-invariants point_set point z3.ce1867
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
16
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
825804044
=inductive-invariants point_set point z3.ce1867 expr point z3.ce1867 done
=inductive-invariants point_set point z3v487.ce1890
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
135020608
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
134217728
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1894407907
=inductive-invariants point_set point z3v487.ce1890 expr point z3v487.ce1890 done
=inductive-invariants point_set point z3.ce1891
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3069199360
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
269214809
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
422146530
=inductive-invariants point_set point z3.ce1891 expr point z3.ce1891 done
=inductive-invariants point_set point z3v487.ce1925
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
77595648
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
524288
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
16777218
=inductive-invariants point_set point z3v487.ce1925 expr point z3v487.ce1925 done
=inductive-invariants point_set point z3v487.ce1969
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1982405609
=inductive-invariants point_set point z3v487.ce1969 expr point z3v487.ce1969 done
=inductive-invariants point_set point z3.ce1968
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
134217728
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
557967651
=inductive-invariants point_set point z3.ce1968 expr point z3.ce1968 done
=inductive-invariants point_set point z3v487.ce2032
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1109430272
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
656706707
=inductive-invariants point_set point z3v487.ce2032 expr point z3v487.ce2032 done
=inductive-invariants point_set point z3.ce2033
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
34880960
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4194304
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
133472672
=inductive-invariants point_set point z3.ce2033 expr point z3.ce2033 done
=inductive-invariants point_set point z3v487.ce2161
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
134257696
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8192
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
332726119
=inductive-invariants point_set point z3v487.ce2161 expr point z3v487.ce2161 done
=inductive-invariants point_set point z3.ce2162
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2709562708
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
131072
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1433210393
=inductive-invariants point_set point z3.ce2162 expr point z3.ce2162 done
=inductive-invariants point_set point z3v487.ce2185
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
16912384
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
214562744
=inductive-invariants point_set point z3v487.ce2185 expr point z3v487.ce2185 done
=inductive-invariants point_set point z3.ce2186
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
22151448
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
536870912
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
105576869
=inductive-invariants point_set point z3.ce2186 expr point z3.ce2186 done
=inductive-invariants point_set point z3v487.ce2305
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1908513724
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1083179008
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4194304
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2305 expr point z3v487.ce2305 done
=inductive-invariants point_set point z3v487.ce2340
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1908513724
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1083179008
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4194304
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1257741413
=inductive-invariants point_set point z3v487.ce2340 expr point z3v487.ce2340 done
=inductive-invariants point_set point z3v487.ce2358
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
151086424
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
262144
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2358 expr point z3v487.ce2358 done
=inductive-invariants point_set point z3v487.ce2393
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
151086424
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
262144
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
636809097
=inductive-invariants point_set point z3v487.ce2393 expr point z3v487.ce2393 done
=inductive-invariants point_set point z3v487.ce2412
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1593837056
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
402661376
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2412 expr point z3v487.ce2412 done
=inductive-invariants point_set point z3v487.ce2447
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1593837056
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
402661376
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
422485367
=inductive-invariants point_set point z3v487.ce2447 expr point z3v487.ce2447 done
=inductive-invariants point_set point z3v487.ce2466
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3523383680
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
2147483640
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2466 expr point z3v487.ce2466 done
=inductive-invariants point_set point z3v487.ce2501
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3523383680
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
2147483640
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
2038816070
=inductive-invariants point_set point z3v487.ce2501 expr point z3v487.ce2501 done
=inductive-invariants point_set point z3v487.ce2519
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1096093776
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1644167172
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2519 expr point z3v487.ce2519 done
=inductive-invariants point_set point z3v487.ce2554
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1096093776
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1644167172
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1996964283
=inductive-invariants point_set point z3v487.ce2554 expr point z3v487.ce2554 done
=inductive-invariants point_set point z3v487.ce2611
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 2 for input.spec-%var-i-0.L3%6%bbentry
2
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1429441536
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
2
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
621644646
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 done
=inductive-invariants point_set point z3v487.ce2576
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 2 for input.spec-%var-i-0.L3%6%bbentry
2
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1429441536
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
2
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 done
=inductive-invariants point_set point z3v487.ce2669
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 2 for input.spec-%var-i-0.L3%6%bbentry
4
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1879048176
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1152671553
=inductive-invariants point_set point z3v487.ce2669 expr point z3v487.ce2669 done
=inductive-invariants point_set point z3v487.ce2634
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 2 for input.spec-%var-i-0.L3%6%bbentry
4
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1879048176
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2634 expr point z3v487.ce2634 done
=inductive-invariants point_set point z3v487.ce2726
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 2 for input.spec-%var-i-0.L3%6%bbentry
5
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1073741812
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
5
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4227731324
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
2059878344
=inductive-invariants point_set point z3v487.ce2726 expr point z3v487.ce2726 done
=inductive-invariants point_set point z3v487.ce2761
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 2 for input.spec-%var-i-0.L3%6%bbentry
6
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1073741812
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
6
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
2059878344
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce2761 expr point z3v487.ce2761 done
=inductive-invariants point_set point z3v487.ce2691
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 2 for input.spec-%var-i-0.L3%6%bbentry
5
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1073741812
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
5
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4227731324
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2691 expr point z3v487.ce2691 done
=inductive-invariants point_set point z3v487.ce2816
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 2 for input.spec-%var-i-0.L3%6%bbentry
8
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
816120192
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
268435456
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
12
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1957607768
=inductive-invariants point_set point z3v487.ce2816 expr point z3v487.ce2816 done
=inductive-invariants point_set point z3v487.ce2781
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 2 for input.spec-%var-i-0.L3%6%bbentry
8
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
816120192
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
268435456
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
12
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2781 expr point z3v487.ce2781 done
=inductive-invariants point_set point z3v487.ce2851
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 2 for input.spec-%var-i-0.L3%6%bbentry
9
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
816120192
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
9
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1957607768
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
12
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce2851 expr point z3v487.ce2851 done
=inductive-invariants point_set point z3v487.ce2906
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 2 for input.spec-%var-i-0.L3%6%bbentry
9
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
825181252
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
9
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
55215504
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
94560105
=inductive-invariants point_set point z3v487.ce2906 expr point z3v487.ce2906 done
=inductive-invariants point_set point z3v487.ce2871
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 2 for input.spec-%var-i-0.L3%6%bbentry
9
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
825181252
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
9
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
55215504
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2871 expr point z3v487.ce2871 done
=inductive-invariants point_set point z3v487.ce2938
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 2 for input.spec-%var-i-0.L3%6%bbentry
71535141
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
71535141
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
285938762
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce2938 expr point z3v487.ce2938 done
=inductive-invariants point_set point z3.ce2939
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 2 for input.spec-%var-i-0.L3%6%bbentry
138049637
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
138049637
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4294934268
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2154650162
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce2939 expr point z3.ce2939 done
=inductive-invariants point_set points done
=out-of-bound-exprs for reason inductive-invariants
=out-of-bound-exprs for reason inductive-invariants at L0%0%d_L0%0%d

=out-of-bound-exprs for reason inductive-invariants at L3%6%bbentry_Lfor.body%1%fcallStart

=out-of-bound-exprs for reason inductive-invariants at L3%6%bbentry_Lfor.body%1%fcallEnd

=out-of-bound-exprs for reason inductive-invariants at L3%6%bbentry_Lfor.cond%1%bbentry

=out-of-bound-exprs for reason inductive-invariants at E0%0%d_E0%0%d

=graph_with_points done
=Invariant state at node L0%0%d_L0%0%d for reason inductive-invariants
=pc L0%0%d_L0%0%d inductive-invariants invariant_state 
is_top 0
is_stable 1
=pc L0%0%d_L0%0%d inductive-invariants invariant_state failcond.description

=pc L0%0%d_L0%0%d inductive-invariants invariant_state failcond.expr is null
=pc L0%0%d_L0%0%d inductive-invariants invariant_state failcond done
=pc L0%0%d_L0%0%d inductive-invariants invariant_state done
=Invariant state at node L3%6%bbentry_Lfor.body%1%fcallStart for reason inductive-invariants
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants invariant_state 
is_top 0
is_stable 1
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants invariant_state failcond.description

=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants invariant_state failcond.expr is null
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants invariant_state failcond done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability name abstract-memlabel-asserts
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability expr_group_type HOUDINI_EXPECTS_STABILITY with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability point_expr 1
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability pred 0
=Comment
abstract-memlabel-asserts-houdini-guess
=LhsExpr
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ce 0: z3v487.ce692
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability summary: number of exprs=1; number of visited CEs=1; number of preds=1
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv name expr-group-bvs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv expr_group_type BV_EQ with 6 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 3
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 5
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 28
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv pred 0
=Comment
expr-group-bvs.linear1-32-free_var_idx.28
=LhsExpr
1 : 1 { 0x1 +1.11e129 } : BV:32
=RhsExpr
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
2 : bool_to_bv(1) : BV:1
3 : 31 { 0x1f +1.0e1025 } : INT
4 : bvzero_ext(2, 3) : BV:32
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv pred 1
=Comment
expr-group-bvs.linear1-2-free_var_idx.5
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv pred 2
=Comment
expr-group-bvs.linear1-2-free_var_idx.3
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv pred 3
=Comment
expr-group-bvs.linear2-32-free_var_idx.2
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvneg(3) : BV:32
=RhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 0: z3.ce688
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 1: z3v487.ce692
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 2: z3.ce947
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 3: z3v487.ce973
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 4: z3.ce974
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 5: z3.ce999
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 6: z3v487.ce2761
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 7: z3v487.ce2851
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 8: z3v487.ce2938
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv summary: number of exprs=6; number of visited CEs=9; number of preds=4
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv output matrix
matrix:
2
-2147483648->0; 2->4294967295; 3->0; 4->1; 5->0; 6->0; 28->0; 
3
-2147483648->0; 2->0; 3->1073741824; 4->0; 5->0; 6->0; 28->0; 
5
-2147483648->0; 2->0; 3->0; 4->0; 5->1073741824; 6->0; 28->0; 
28
-2147483648->4294967295; 2->0; 3->0; 4->0; 5->0; 6->0; 28->1; 
matrix done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv state elems done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const name src-branches-const-ineq
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const pred 0
=Comment
src-branches-const-ineq.ub-unsigned
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const pred 1
=Comment
src-branches-const-ineq.lb-signed
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const visited ce 0: z3v487.ce692
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const visited ce 1: z3v487.ce2761
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const visited ce 2: z3v487.ce2851
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const summary: number of exprs=1; number of visited CEs=3; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const pred 0
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.ub-unsigned
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const pred 1
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.lb-signed
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const visited ce 0: z3v487.ce692
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const visited ce 1: z3v487.ce2761
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const visited ce 2: z3v487.ce2851
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const summary: number of exprs=1; number of visited CEs=3; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%n.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const pred 0
=Comment
dst-branches-const-ineq.input.dst.llvm-%n.Lfor.cond%1%bbentry.lb-unsigned
=LhsExpr
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvuge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const visited ce 0: z3.ce688
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const visited ce 1: z3v487.ce692
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const visited ce 2: z3.ce1025
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const visited ce 3: z3.ce1051
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const summary: number of exprs=1; number of visited CEs=4; number of preds=1
=m_lower_bound_signed_cur -2147483648
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 1
=m_upper_bound_unsigned_cur 4294967295
=m_lower_bound_signed_known -2147483648
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 1
=m_upper_bound_unsigned_known 4294967295
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini name dst-ineq
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini expr_group_type HOUDINI with 8 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 7
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 8
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 9
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 10
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 12
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 13
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 14
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini pred 0
=Comment
dst-ineq-houdini-guess
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini pred 1
=Comment
dst-ineq-houdini-guess
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini visited ce 0: z3v487.ce692
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini visited ce 1: z3.ce1025
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini summary: number of exprs=8; number of visited CEs=2; number of preds=2
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based name spec-coupling-invariants
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based expr_group_type HOUDINI_AXIOM_BASED with 23 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 15
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 16
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 17
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : bvadd(14, 5) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(10, 11, 12, 15, 16, 17) : BV:32
19 : lambda(9, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(8, 19) : MAP[BV:32 -> BV:32]
21 : eq(1, 20) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 18
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 19
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 20
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 22
1 : spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 24
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 25
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 26
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 27
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 29
1 : spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : input.spec-%var-i-0.L3%6%bbentry : BV:32
23 : map_get(21, 22) : SUM[UNIT,BV:32]
24 : eq(1, 23) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 30
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 31
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%tmpvar-1.L3%6%bbentry : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
27 : sum_get(22, 23) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(26, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : eq(25, 42) : BOOL
44 : and(24, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 32
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%tmpvar-2.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 33
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%var-new_l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 34
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 35
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(14, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 36
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 37
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(4, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 38
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : bvadd(13, 4) : BV:32
15 : 4 { 0x4 +1.0e1025 } : INT
16 : 0 { 0x0 } : BOOL
17 : select(9, 10, 11, 14, 15, 16) : BV:32
18 : lambda(8, 17) : FUNCTION[BV:32 -> BV:32]
19 : map(7, 18) : MAP[BV:32 -> BV:32]
20 : input.spec-%var-i-0.L3%6%bbentry : BV:32
21 : map_get(19, 20) : SUM[UNIT,BV:32]
22 : 1 { 0x1 +1.0e1025 } : INT
23 : sum_is(21, 22) : BOOL
24 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
27 : sum_get(21, 22) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 15, 16) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 15, 16) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(26, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(25, 22, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(24, 43) : BOOL
45 : and(23, 44) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 39
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 40
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(4, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 0
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 1
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 2
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ce 0: z3v487.ce692
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based summary: number of exprs=23; number of visited CEs=1; number of preds=3
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants invariant_state done
=Invariant state at node L3%6%bbentry_Lfor.body%1%fcallEnd for reason inductive-invariants
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants invariant_state 
is_top 0
is_stable 1
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants invariant_state failcond.description

=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants invariant_state failcond.expr is null
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants invariant_state failcond done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability name abstract-memlabel-asserts
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability expr_group_type HOUDINI_EXPECTS_STABILITY with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability point_expr 1
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability pred 0
=Comment
abstract-memlabel-asserts-houdini-guess
=LhsExpr
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ce 0: z3.ce1555
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability summary: number of exprs=1; number of visited CEs=1; number of preds=1
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv name expr-group-bvs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv expr_group_type BV_EQ with 6 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 3
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 5
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 41
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv pred 0
=Comment
expr-group-bvs.linear1-2-free_var_idx.5
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv pred 1
=Comment
expr-group-bvs.linear1-2-free_var_idx.3
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv pred 2
=Comment
expr-group-bvs.linear2-32-free_var_idx.2
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvneg(3) : BV:32
=RhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 0: z3.ce1555
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 1: z3.ce1549
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 2: z3.ce1546
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 3: z3v487.ce1552
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 4: z3v487.ce1804
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 5: z3v487.ce2340
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 6: z3v487.ce2393
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 7: z3v487.ce2447
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 8: z3v487.ce2501
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 9: z3v487.ce2554
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv summary: number of exprs=6; number of visited CEs=10; number of preds=3
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv output matrix
matrix:
2
-2147483648->0; 2->4294967295; 3->0; 4->1; 5->0; 6->0; 41->0; 
3
-2147483648->0; 2->0; 3->1073741824; 4->0; 5->0; 6->0; 41->0; 
5
-2147483648->0; 2->0; 3->0; 4->0; 5->1073741824; 6->0; 41->0; 
matrix done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv state elems done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const name src-branches-const-ineq
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const pred 0
=Comment
src-branches-const-ineq.ub-unsigned
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const pred 1
=Comment
src-branches-const-ineq.lb-signed
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 0: z3.ce1555
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 1: z3v487.ce2340
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 2: z3v487.ce2611
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 3: z3v487.ce2669
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 4: z3v487.ce2726
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 5: z3v487.ce2816
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 6: z3v487.ce2906
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const summary: number of exprs=1; number of visited CEs=7; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const pred 0
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.ub-unsigned
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const pred 1
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.lb-signed
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 0: z3.ce1555
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 1: z3v487.ce2340
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 2: z3v487.ce2611
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 3: z3v487.ce2669
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 4: z3v487.ce2726
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 5: z3v487.ce2816
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 6: z3v487.ce2906
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const summary: number of exprs=1; number of visited CEs=7; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%n.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const pred 0
=Comment
dst-branches-const-ineq.input.dst.llvm-%n.Lfor.cond%1%bbentry.lb-unsigned
=LhsExpr
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvuge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ce 0: z3.ce1555
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ce 1: z3.ce1549
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ce 2: z3.ce1546
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ce 3: z3.ce1828
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const summary: number of exprs=1; number of visited CEs=4; number of preds=1
=m_lower_bound_signed_cur -2147483648
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 1
=m_upper_bound_unsigned_cur 4294967295
=m_lower_bound_signed_known -2147483648
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 1
=m_upper_bound_unsigned_known 4294967295
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini name dst-ineq
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini expr_group_type HOUDINI with 8 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 7
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 8
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 9
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 10
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 12
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 13
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 14
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini pred 0
=Comment
dst-ineq-houdini-guess
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini pred 1
=Comment
dst-ineq-houdini-guess
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini visited ce 0: z3.ce1555
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini visited ce 1: z3.ce1549
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini summary: number of exprs=8; number of visited CEs=2; number of preds=2
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based name spec-coupling-invariants
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based expr_group_type HOUDINI_AXIOM_BASED with 27 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 42
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 43
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 44
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : bvadd(14, 5) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(10, 11, 12, 15, 16, 17) : BV:32
19 : lambda(9, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(8, 19) : MAP[BV:32 -> BV:32]
21 : eq(1, 20) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 45
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 46
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 47
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 48
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 49
1 : spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : input.spec-%var-i-0.L3%6%bbentry : BV:32
23 : map_get(21, 22) : SUM[UNIT,BV:32]
24 : eq(1, 23) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 50
1 : spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 51
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 52
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%tmpvar-1.L3%6%bbentry : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
27 : sum_get(22, 23) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(26, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : eq(25, 42) : BOOL
44 : and(24, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 53
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%tmpvar-2.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 54
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : spec-%var-new_l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 55
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 56
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 57
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 58
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 59
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 60
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 61
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(14, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 62
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 63
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(4, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 64
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : bvadd(13, 4) : BV:32
15 : 4 { 0x4 +1.0e1025 } : INT
16 : 0 { 0x0 } : BOOL
17 : select(9, 10, 11, 14, 15, 16) : BV:32
18 : lambda(8, 17) : FUNCTION[BV:32 -> BV:32]
19 : map(7, 18) : MAP[BV:32 -> BV:32]
20 : input.spec-%var-i-0.L3%6%bbentry : BV:32
21 : map_get(19, 20) : SUM[UNIT,BV:32]
22 : 1 { 0x1 +1.0e1025 } : INT
23 : sum_is(21, 22) : BOOL
24 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
27 : sum_get(21, 22) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 15, 16) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 15, 16) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(26, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(25, 22, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(24, 43) : BOOL
45 : and(23, 44) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 65
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 66
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : Indxform0 : BV:32
30 : bvadd(8, 12) : BV:32
31 : select(9, 10, 11, 30, 16, 17) : BV:32
32 : lambda(8, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(2, 1) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 2, 34) : BV:32
36 : unit : UNIT
37 : select(9, 10, 11, 1, 16, 17) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(1, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(4, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(27, 28, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(26, 23, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(25, 43) : BOOL
45 : and(24, 44) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 67
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 68
1 : Lambda0 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
5 : bvult(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : lambda(1, 6) : FUNCTION[BV:32 -> BOOL]
8 : Lambda1 : BV:32
9 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
10 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
11 : memlabel-top : MEMLABEL
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(8, 12) : BV:32
14 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
15 : bvadd(13, 14) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(9, 10, 11, 15, 16, 17) : BV:32
19 : lambda(8, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(7, 19) : MAP[BV:32 -> BV:32]
21 : input.spec-%var-i-0.L3%6%bbentry : BV:32
22 : map_get(20, 21) : SUM[UNIT,BV:32]
23 : 1 { 0x1 +1.0e1025 } : INT
24 : sum_is(22, 23) : BOOL
25 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
26 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
27 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
28 : sum_get(22, 23) : BV:32
29 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
30 : Indxform0 : BV:32
31 : bvadd(8, 12) : BV:32
32 : select(9, 10, 11, 31, 16, 17) : BV:32
33 : lambda(8, 32) : FUNCTION[BV:32 -> BV:32]
34 : eq(2, 1) : BOOL
35 : 1 { 0x1 +1.11e129 } : BV:32
36 : ite(34, 2, 35) : BV:32
37 : unit : UNIT
38 : select(9, 10, 11, 1, 16, 17) : BV:32
39 : prod(38, 30) : PROD[BV:32,BV:32]
40 : sum(36, 37, 39) : SUM[UNIT,PROD[BV:32,BV:32]]
41 : lambda(1, 40) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
42 : ind(29, 30, 33, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : prod_init(27, 28, 42) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
44 : sum_init(26, 23, 43) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
45 : eq(25, 44) : BOOL
46 : and(24, 45) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 0
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 1
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 2
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ce 0: z3.ce1555
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based summary: number of exprs=27; number of visited CEs=1; number of preds=3
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants invariant_state done
=Invariant state at node L3%6%bbentry_Lfor.cond%1%bbentry for reason inductive-invariants
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants invariant_state 
is_top 0
is_stable 1
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants invariant_state failcond.description

=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants invariant_state failcond.expr is null
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants invariant_state failcond done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability name abstract-memlabel-asserts
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability expr_group_type HOUDINI_EXPECTS_STABILITY with 1 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability point_expr 1
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability pred 0
=Comment
abstract-memlabel-asserts-houdini-guess
=LhsExpr
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ce 0: z3.ce6
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability summary: number of exprs=1; number of visited CEs=1; number of preds=1
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv name expr-group-bvs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv expr_group_type BV_EQ with 5 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv point_expr 3
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv point_expr 5
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv pred 0
=Comment
expr-group-bvs.linear1-2-free_var_idx.5
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv pred 1
=Comment
expr-group-bvs.linear1-2-free_var_idx.3
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv pred 2
=Comment
expr-group-bvs.linear2-32-free_var_idx.2
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvneg(3) : BV:32
=RhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 0: z3.ce6
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 1: z3v487.ce20
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 2: z3.ce19
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 3: z3.ce41
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 4: z3v487.ce2305
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 5: z3v487.ce2358
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 6: z3v487.ce2412
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 7: z3v487.ce2466
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 8: z3v487.ce2519
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv summary: number of exprs=5; number of visited CEs=9; number of preds=3
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv output matrix
matrix:
2
-2147483648->0; 2->4294967295; 3->0; 4->1; 5->0; 6->0; 
3
-2147483648->0; 2->0; 3->1073741824; 4->0; 5->0; 6->0; 
5
-2147483648->0; 2->0; 3->0; 4->0; 5->1073741824; 6->0; 
matrix done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv state elems done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const name src-branches-const-ineq
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const pred 0
=Comment
src-branches-const-ineq.ub-unsigned
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const pred 1
=Comment
src-branches-const-ineq.lb-signed
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 0: z3.ce6
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 1: z3v487.ce2305
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 2: z3v487.ce2576
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 3: z3v487.ce2634
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 4: z3v487.ce2691
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 5: z3v487.ce2781
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 6: z3v487.ce2871
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const summary: number of exprs=1; number of visited CEs=7; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const pred 0
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.ub-unsigned
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const pred 1
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.lb-signed
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 0: z3.ce6
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 1: z3v487.ce2305
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 2: z3v487.ce2576
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 3: z3v487.ce2634
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 4: z3v487.ce2691
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 5: z3v487.ce2781
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 6: z3v487.ce2871
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const summary: number of exprs=1; number of visited CEs=7; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%n.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const visited ce 0: z3.ce6
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const visited ce 1: z3.ce19
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const visited ce 2: z3.ce41
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const visited ce 3: z3.ce63
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const summary: number of exprs=1; number of visited CEs=4; number of preds=0
=m_lower_bound_signed_cur -2147483648
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967295
=m_lower_bound_signed_known -2147483648
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967295
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini name dst-ineq
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini expr_group_type HOUDINI with 8 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 7
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 8
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 9
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 10
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 12
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 13
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 14
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini pred 0
=Comment
dst-ineq-houdini-guess
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini visited ce 0: z3.ce6
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini visited ce 1: z3.ce19
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini visited ce 2: z3.ce41
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini summary: number of exprs=8; number of visited CEs=3; number of preds=1
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based name spec-coupling-invariants
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based expr_group_type HOUDINI_AXIOM_BASED with 13 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 15
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 16
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 17
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : bvadd(14, 5) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(10, 11, 12, 15, 16, 17) : BV:32
19 : lambda(9, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(8, 19) : MAP[BV:32 -> BV:32]
21 : eq(1, 20) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 18
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 19
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 20
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 21
1 : spec-%tmpvar-10.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 0 { 0x0 +1.0e1025 } : INT
4 : unit : UNIT
5 : sum_init(2, 3, 4) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : eq(1, 5) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 22
1 : spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 23
1 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 0 { 0x0 +1.0e1025 } : INT
4 : unit : UNIT
5 : sum_init(2, 3, 4) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : eq(1, 5) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 24
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 25
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 26
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 27
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 0
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 1
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 2
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ce 0: z3.ce6
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based summary: number of exprs=13; number of visited CEs=1; number of preds=3
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants invariant_state done
=Invariant state at node E0%0%d_E0%0%d for reason inductive-invariants
=pc E0%0%d_E0%0%d inductive-invariants invariant_state 
is_top 0
is_stable 1
=pc E0%0%d_E0%0%d inductive-invariants invariant_state failcond.description

=pc E0%0%d_E0%0%d inductive-invariants invariant_state failcond.expr is null
=pc E0%0%d_E0%0%d inductive-invariants invariant_state failcond done
=pc E0%0%d_E0%0%d inductive-invariants invariant_state done
=invariant_state_changed_at_pcs for reason inductive-invariants:
=graph_with_guessing done
=graph_with_correctness_covers begin
=graph_with_correctness_covers done
=m_dst_fcall_edges_already_updated_from_pcs:
=m_internal_pcs:
=m_super_edges:
=AllocaPCLocalSprelAssumptionsBegin:
=Local offsets from compile log
=Local offsets from compile log done
=done
=AllocaPCLocalSprelAssumptionsEnd
=DeallocaPCLocalSprelAssumptionsBegin:
=Local offsets from compile log
=Local offsets from compile log done
=done
=DeallocaPCLocalSprelAssumptionsEnd
=src_tfg pcs reaching pcpair L0%0%d_L0%0%d
=src_tfg pc: L0%0%d
=exit_pc_asserts at E0%0%d_E0%0%d
=exit_pc_assert.0 at E0%0%d_E0%0%d
=Comment
ret-pointer-implements-inductive-list
=LhsExpr
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=well-formedness-conditions for L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry
=well-formedness-conditions for L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry edge well-formedness condition
=well-formedness-conditions for L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry edge well-formedness condition done
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd edge well-formedness condition
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd edge well-formedness condition done
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge well-formedness condition
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond cg_path
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond cg_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond src_path
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond src_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond dst_path
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond dst_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond pred.0
=Comment
wfcond.from_pcL3%6%bbentry_Lfor.body%1%fcallEnd.to_pcL3%6%bbentry_Lfor.cond%1%bbentry-dst-edgecond-implies-src-edgecond
=LhsExpr
1 : 1 { 0x1 } : BOOL
2 : not(1) : BOOL
3 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
4 : input.spec-%var-i-0.L3%6%bbentry : BV:32
5 : map_get(3, 4) : SUM[UNIT,BV:32]
6 : 1 { 0x1 +1.0e1025 } : INT
7 : sum_is(5, 6) : BOOL
8 : or(2, 7) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge well-formedness condition done
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart edge well-formedness condition
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart edge well-formedness condition done
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge well-formedness condition
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond cg_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond cg_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond src_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond src_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond dst_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond dst_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond pred.0
=Comment
wfcond.from_pcL3%6%bbentry_Lfor.cond%1%bbentry.to_pcE0%0%d_E0%0%d-dst-edgecond-implies-src-edgecond
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
4 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
5 : input.spec-%var-i-0.L3%6%bbentry : BV:32
6 : map_get(4, 5) : SUM[UNIT,BV:32]
7 : 0 { 0x0 +1.0e1025 } : INT
8 : sum_is(6, 7) : BOOL
9 : or(3, 8) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond cg_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond cg_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond src_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond src_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond dst_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond dst_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond pred.0
=Comment
ret-pointer-implements-inductive-list
=LhsExpr
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge well-formedness condition done
=Ranking exprs at node L3%6%bbentry_Lfor.body%1%fcallStart
=SRC Ranking expr 0
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=SRC Tie Breaking expr 0
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 1
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 2
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=DST Ranking expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 1
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 2
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 3
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=DST Tie Breaking expr 0
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=bv_rank_exprs done
=Ranking exprs at node L3%6%bbentry_Lfor.body%1%fcallEnd
=SRC Ranking expr 0
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=SRC Tie Breaking expr 0
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 1
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 2
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=DST Ranking expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=DST Ranking expr 2
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 3
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 4
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=bv_rank_exprs done
=Ranking exprs at node L3%6%bbentry_Lfor.cond%1%bbentry
=SRC Ranking expr 0
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=SRC Tie Breaking expr 0
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 1
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 2
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=DST Ranking expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 1
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 2
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 3
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=bv_rank_exprs done
=Ranking exprs done
=dst-to-src submaps done
=cg-edge-contains-repeated-src-tfg-edge at edge-id L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry
0
=cg-edge-contains-repeated-src-tfg-edge at edge-id L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd
1
=cg-edge-contains-repeated-src-tfg-edge at edge-id L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry
1
=cg-edge-contains-repeated-src-tfg-edge at edge-id L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart
1
=cg-edge-contains-repeated-src-tfg-edge at edge-id L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d
0
=cg-edge-contains-repeated-src-tfg-edge-map done
=cg.assumes_around_edge
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.ec
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.pred
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
140458 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
140459 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
140583 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
140461 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
140430 : 4 { 0x4 +1.0e1025 } : INT
140431 : 0 { 0x0 } : BOOL
140584 : select(140458, 140459, 140583, 140461, 140430, 140431) : BV:32
=RhsExpr
140456 : input.dst.llvm-%n : BV:32
=predicate done

cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.ec
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.pred
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
140458 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
140459 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
140585 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
140460 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
140430 : 4 { 0x4 +1.0e1025 } : INT
140431 : 0 { 0x0 } : BOOL
140586 : select(140458, 140459, 140585, 140460, 140430, 140431) : BV:32
=RhsExpr
140457 : input.dst.llvm-%arr : BV:32
=predicate done

cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.ec
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.pred
=Comment
undef-behaviour-align-assume.edge.L0%0%d=>Lfor.cond%1%bbentry
=LhsExpr
140457 : input.dst.llvm-%arr : BV:32
140430 : 4 { 0x4 +1.0e1025 } : INT
140467 : islangaligned(140457, 140430) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #3
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #3.ec
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #3.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #3.pred
=Comment
pointer-implements-map
=LhsExpr
140273 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
140315 : Lambda0 : BV:32
140276 : 0 { 0x0 +1.0e129 } : BV:32
140375 : bvule(140276, 140315) : BOOL
140456 : input.dst.llvm-%n : BV:32
141355 : bvult(140315, 140456) : BOOL
141356 : and(140375, 141355) : BOOL
141357 : lambda(140315, 141356) : FUNCTION[BV:32 -> BOOL]
140317 : Lambda1 : BV:32
140458 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
140459 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
140425 : memlabel-top : MEMLABEL
140427 : 4 { 0x4 +1.47e129 } : BV:32
140428 : bvmul(140317, 140427) : BV:32
140457 : input.dst.llvm-%arr : BV:32
141377 : bvadd(140428, 140457) : BV:32
140430 : 4 { 0x4 +1.0e1025 } : INT
140431 : 0 { 0x0 } : BOOL
141378 : select(140458, 140459, 140425, 141377, 140430, 140431) : BV:32
141380 : lambda(140317, 141378) : FUNCTION[BV:32 -> BV:32]
141381 : map(141357, 141380) : MAP[BV:32 -> BV:32]
141385 : eq(140273, 141381) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #4
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #4.ec
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #4.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #4.pred
=Comment
precond-mlasserts
=LhsExpr
141327 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
141328 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
141329 : bvule(141327, 141328) : BOOL
140427 : 4 { 0x4 +1.47e129 } : BV:32
140505 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
141330 : bvadd(140427, 140505) : BV:32
141331 : bvadd(141327, 141330) : BV:32
141332 : eq(141328, 141331) : BOOL
141333 : and(141329, 141332) : BOOL
141334 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
141335 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
141336 : bvule(141334, 141335) : BOOL
141337 : and(141333, 141336) : BOOL
141338 : bvadd(141334, 141330) : BV:32
141339 : eq(141335, 141338) : BOOL
141340 : and(141337, 141339) : BOOL
140461 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
141341 : 3 { 0x3 +1.35e129 } : BV:32
141342 : bvand(140461, 141341) : BV:32
140276 : 0 { 0x0 +1.0e129 } : BV:32
141343 : eq(141342, 140276) : BOOL
140460 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
141344 : bvand(140460, 141341) : BV:32
141345 : eq(141344, 140276) : BOOL
141346 : and(141343, 141345) : BOOL
141347 : and(141340, 141346) : BOOL
141348 : eq(140461, 141327) : BOOL
141349 : eq(140460, 141334) : BOOL
141350 : and(141348, 141349) : BOOL
141351 : and(141347, 141350) : BOOL
140459 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
140298 : 1 { 0x1 +1.11e129 } : BV:32
140462 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
141352 : region_agrees_with_memlabel(140459, 140276, 140298, 140462) : BOOL
141353 : and(141351, 141352) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry done
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #0
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #0.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #0.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #0.pred
=Comment
undef-behaviour-align-assume
=LhsExpr
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140287 : 1 { 0x1 +1.0e1025 } : INT
140750 : islangaligned(140713, 140287) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #1
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #1.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #1.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #1.pred
=Comment
undef-behavioursome
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140903 : eq(140276, 140713) : BOOL
140431 : 0 { 0x0 } : BOOL
140487 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
140722 : heap_alloc_ptr(140713, 140487) : BV:32
140647 : 7 { 0x7 +1.83e129 } : BV:32
140944 : bvadd(140647, 140722) : BV:32
140947 : bvule(140722, 140944) : BOOL
140950 : or(140431, 140947) : BOOL
140954 : or(140903, 140950) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #2
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #2.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #2.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #2.pred
=Comment
undef-behavioursome
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140903 : eq(140276, 140713) : BOOL
140714 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
140474 : 8 { 0x8 +1.95e129 } : BV:32
140462 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
141257 : region_agrees_with_memlabel(140714, 140713, 140474, 140462) : BOOL
141263 : or(140903, 141257) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd done
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.pred
=Comment
undef-behaviour-align-assume.edge.Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
=LhsExpr
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140287 : 1 { 0x1 +1.0e1025 } : INT
140750 : islangaligned(140713, 140287) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.pred
=Comment
merged-predicate
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140903 : eq(140276, 140713) : BOOL
140714 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
140474 : 8 { 0x8 +1.95e129 } : BV:32
140462 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
141257 : region_agrees_with_memlabel(140714, 140713, 140474, 140462) : BOOL
141263 : or(140903, 141257) : BOOL
140431 : 0 { 0x0 } : BOOL
140487 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
140722 : heap_alloc_ptr(140713, 140487) : BV:32
140647 : 7 { 0x7 +1.83e129 } : BV:32
140944 : bvadd(140647, 140722) : BV:32
140947 : bvule(140722, 140944) : BOOL
140950 : or(140431, 140947) : BOOL
140954 : or(140903, 140950) : BOOL
314518 : and(141263, 140954) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.pred
=Comment
merged-predicate
=LhsExpr
140275 : 1 { 0x1 } : BOOL
140276 : 0 { 0x0 +1.0e129 } : BV:32
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140903 : eq(140276, 140713) : BOOL
140487 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
140722 : heap_alloc_ptr(140713, 140487) : BV:32
140911 : ite(140903, 140276, 140722) : BV:32
312902 : isgepoffset(140911, 140276) : BOOL
312914 : and(140275, 312902) : BOOL
140652 : 4 { 0x4 +1.0e1025 } : BV:64
140726 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
140714 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
140474 : 8 { 0x8 +1.95e129 } : BV:32
140718 : heap_alloc(140714, 140487, 140713, 140474) : ARRAY[BV:32 -> MEMLABEL]
140905 : ite(140903, 140714, 140718) : ARRAY[BV:32 -> MEMLABEL]
140913 : malloc_side_effect(140726, 140905, 140487) : BV:32
140519 : 32 { 0x20 +1.0e1025 } : INT
312953 : bvsign_ext(140913, 140519) : BV:64
312960 : bvmul(140652, 312953) : BV:64
140523 : 63 { 0x3f +1.0e1025 } : INT
312971 : bvextract(312960, 140523, 140519) : BV:32
313833 : bvslt(140913, 140276) : BOOL
140505 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
313834 : ite(313833, 140505, 140276) : BV:32
313835 : eq(312971, 313834) : BOOL
140430 : 4 { 0x4 +1.0e1025 } : INT
313836 : isindexforsize(313835, 140430) : BOOL
140712 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
140908 : malloc_side_effect(140712, 140905, 140487) : BV:32
140427 : 4 { 0x4 +1.47e129 } : BV:32
157004 : bvmul(140427, 140913) : BV:32
157005 : bvadd(140908, 157004) : BV:32
314053 : isgepoffset(157005, 157004) : BOOL
314054 : and(313836, 314053) : BOOL
314071 : islangaligned(157005, 140430) : BOOL
314512 : and(314054, 314071, 312902, 312914) : BOOL
314513 : islangaligned(140911, 140430) : BOOL
311706 : bvadd(140427, 140911) : BV:32
314514 : isgepoffset(311706, 140427) : BOOL
314515 : and(312914, 314512, 314513, 314514) : BOOL
314516 : islangaligned(311706, 140430) : BOOL
314517 : and(314515, 314516) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry done
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #0
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #0.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #0.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #0.pred
=Comment
undef-behaviour-align-assume
=LhsExpr
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140287 : 1 { 0x1 +1.0e1025 } : INT
140750 : islangaligned(140713, 140287) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #1
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #1.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #1.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #1.pred
=Comment
undef-behavioursome
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140903 : eq(140276, 140713) : BOOL
140431 : 0 { 0x0 } : BOOL
140487 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
140722 : heap_alloc_ptr(140713, 140487) : BV:32
140647 : 7 { 0x7 +1.83e129 } : BV:32
140944 : bvadd(140647, 140722) : BV:32
140947 : bvule(140722, 140944) : BOOL
140950 : or(140431, 140947) : BOOL
140954 : or(140903, 140950) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #2
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #2.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #2.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #2.pred
=Comment
undef-behavioursome
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140713 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140903 : eq(140276, 140713) : BOOL
140714 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
140474 : 8 { 0x8 +1.95e129 } : BV:32
140462 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
141257 : region_agrees_with_memlabel(140714, 140713, 140474, 140462) : BOOL
141263 : or(140903, 141257) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart done
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d done
cg.assumes_around_edge done
=corr_graph_done
=bv_rank_map
=bv_rank at L0%0%d_L0%0%d
m_dst_rank: 0, m_src_rank: 0, m_spec_rank: 0
=bv_rank at L3%6%bbentry_Lfor.body%1%fcallStart
m_dst_rank: 3, m_src_rank: 0, m_spec_rank: 20
=bv_rank at L3%6%bbentry_Lfor.body%1%fcallEnd
m_dst_rank: 4, m_src_rank: 0, m_spec_rank: 24
=bv_rank at L3%6%bbentry_Lfor.cond%1%bbentry
m_dst_rank: 3, m_src_rank: 0, m_spec_rank: 11
=bv_rank at E0%0%d_E0%0%d
m_dst_rank: 0, m_src_rank: 0, m_spec_rank: 0
=cg_with_rank done
=cg_with_backtracker done
=asm filename

=cg_with_asm_annotation done
