=FunctionName: make_list
=result: 1
=cg_with_asm_annotation
=cg_with_backtracker
=cg_with_rank
=corr_graph make_list.A2.B1.C1.D1.E2
=src_tfg
=TFG_SSA:
=TFG_SPEC src.spec.make_list:
=TFG:
=Nodes: L0%0%d L3%6%bbentry L3%7%d L3%8%bbentry L3%10%bbentry E0%0%d
=Edges:
L0%0%d => L3%6%bbentry
L3%6%bbentry => L3%7%d
L3%7%d => L3%10%bbentry
L3%7%d => L3%8%bbentry
L3%8%bbentry => E0%0%d
L3%10%bbentry => L3%6%bbentry (backedge) 
=graph done
=is_ssa_graph:
1
=StartState:
=spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=state_end
=PC to var-version map at L0%0%d
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=PC to var-version map at L3%6%bbentry
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=PC to var-version map at L3%7%d
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=PC to var-version map at L3%8%bbentry
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=PC to var-version map at L3%10%bbentry
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=PC to var-version map at E0%0%d
=version for spec-mem.alloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=version for spec-mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=var-version done
=graph_with_var_versions done
=FunctionName: make_list
=Input: tfg-method-arg.0
=arg addr
1 : (undefined) : UNDEFINED
=arg val
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=arg end
=Node outputs: E0%0%d
=Output: spec-%ret-reg
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Node outputs done for E0%0%d
=input_outputs done
=Symbol-map:
=Touched symbols:
=Symbol-map done
=Locals-map:
=Locals-map done
=Global assumes
=global assume predicate_set done
Memlabel map for call-context {*;make_list}
=memlabel_map.0 for call-context {*;make_list}
mlheap.src.spec.make_list : memlabel-mem--heap
=Edge: L0%0%d => L3%6%bbentry
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=spec-%tmpvar-10.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : unit : UNIT
4 : sum_init(1, 2, 3) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=spec-%var-arr-0.L3%6%bbentry
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=spec-%var-l-0.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : unit : UNIT
4 : sum_init(1, 2, 3) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:2:((((func_head*ctor_bv)*ctor_sum)*(inline_entry*func_head))*(ghost_var.itervar.firstedge*ghost_var.itervar.secondedge))
tfg_edge_comment end

=Edge: L3%6%bbentry => L3%7%d
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=spec-%tmpvar-0.L3%7%d
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : map_get(1, 2) : SUM[UNIT,BV:32]
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:-1:(bb_entry*intrinsic_app_map_get)
tfg_edge_comment end

=Edge: L3%7%d => L3%10%bbentry
=Edge.EdgeCond: 
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : sum_is(1, 2) : BOOL
=Edge.StateTo: 
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:6:match_sum_cond_1
tfg_edge_comment end

=Edge: L3%7%d => L3%8%bbentry
=Edge.EdgeCond: 
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : sum_is(1, 2) : BOOL
=Edge.StateTo: 
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:4:match_sum_cond_0
tfg_edge_comment end

=Edge: L3%8%bbentry => E0%0%d
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=spec-%tmpvar-7.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-11.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-12.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-8.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%var-u-0.E0%0%d
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : sum_get(1, 2) : UNIT
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:-1:((((bb_entry*match_sum_val_0)*match_sum_merge_0)*func_ret)*(inline_exit*func_ret))
tfg_edge_comment end

=Edge: L3%10%bbentry => L3%6%bbentry
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=spec-%var-i-0.L3%6%bbentry
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : input.src.spec-ghostvar.itervar.1.L3%6%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=spec-%var-arr-0.L3%6%bbentry
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=spec-%var-l-0.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-1.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
2 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : sum_get(2, 3) : BV:32
5 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : prod_init(1, 4, 5) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=spec-%var-arr_i-0.L3%6%bbentry
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : sum_get(1, 2) : BV:32
=spec-%tmpvar-2.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=spec-%tmpvar-4.L3%6%bbentry
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=spec-%var-new_l-0.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:-1:(((bb_entry*match_sum_val_1)*ctor_prod)*((((ctor_sum*letin_def)*ctor_bv)*(intrinsic_app_bvadd*tailrec_backedge))*(ghost_var.itervar.firstedge*ghost_var.itervar.secondedge)))
tfg_edge_comment end

=graph_with_predicates_done

=start_pc_preconditions
=graph_with_precondition_done

=Locs in src.spec.make_list
=Loc 1 in src.spec.make_list.
REGMEM
spec-%var-arr-1
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=Loc 20 in src.spec.make_list.
MASKED
=mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--heap
=Loc 21 in src.spec.make_list.
MASKED
=mem
1 : input.spec-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.spec-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.0
=Loc 22 in src.spec.make_list.
REGMEM
spec-%tmpvar-0.L3%7%d
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
=Loc 23 in src.spec.make_list.
REGMEM
spec-%var-arr-0.L3%6%bbentry
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=Loc 24 in src.spec.make_list.
REGMEM
spec-%var-i-0.L3%6%bbentry
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=Loc 25 in src.spec.make_list.
REGMEM
spec-%tmpvar-11.E0%0%d
1 : input.spec-%tmpvar-11.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 26 in src.spec.make_list.
REGMEM
spec-%tmpvar-12.E0%0%d
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 27 in src.spec.make_list.
REGMEM
spec-%tmpvar-7.E0%0%d
1 : input.spec-%tmpvar-7.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 28 in src.spec.make_list.
REGMEM
spec-%tmpvar-8.E0%0%d
1 : input.spec-%tmpvar-8.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 29 in src.spec.make_list.
REGMEM
spec-%var-l-0.L3%6%bbentry
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 30 in src.spec.make_list.
REGMEM
spec-%var-u-0.E0%0%d
1 : input.spec-%var-u-0.E0%0%d : UNIT
=Loc 31 in src.spec.make_list.
REGMEM
spec-%tmpvar-10.L3%6%bbentry
1 : input.spec-%tmpvar-10.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 32 in src.spec.make_list.
REGMEM
spec-%tmpvar-9.L3%6%bbentry
1 : input.spec-%tmpvar-9.L3%6%bbentry : BV:32
=Loc 33 in src.spec.make_list.
REGMEM
src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : input.src.spec-ghostvar.itervar.1.L3%6%bbentry : BV:32
=Loc 34 in src.spec.make_list.
REGMEM
spec-%tmpvar-1.L3%6%bbentry
1 : input.spec-%tmpvar-1.L3%6%bbentry : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=Loc 35 in src.spec.make_list.
REGMEM
spec-%tmpvar-2.L3%6%bbentry
1 : input.spec-%tmpvar-2.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Loc 36 in src.spec.make_list.
REGMEM
spec-%tmpvar-3.L3%6%bbentry
1 : input.spec-%tmpvar-3.L3%6%bbentry : BV:32
=Loc 37 in src.spec.make_list.
REGMEM
spec-%tmpvar-4.L3%6%bbentry
1 : input.spec-%tmpvar-4.L3%6%bbentry : BV:32
=Loc 38 in src.spec.make_list.
REGMEM
spec-%var-arr_i-0.L3%6%bbentry
1 : input.spec-%var-arr_i-0.L3%6%bbentry : BV:32
=Loc 39 in src.spec.make_list.
REGMEM
spec-%var-new_l-0.L3%6%bbentry
1 : input.spec-%var-new_l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=Locs end
=Liveness in src.spec.make_list
=live locs at L0%0%d
1, 
=live locs at L3%6%bbentry
23, 24, 29, 
=live locs at L3%7%d
22, 23, 24, 29, 
=live locs at L3%8%bbentry
29, 
=live locs at L3%10%bbentry
22, 23, 24, 29, 
=live locs at E0%0%d
26, 

=Definedness in src.spec.make_list
=loc definedness at L0%0%d
1, 20, 21
=loc definedness at L3%6%bbentry
1, 20, 21, 23, 24, 29, 31, 32, 33
=loc definedness at L3%7%d
1, 20, 21, 22, 23, 24, 29, 31, 32, 33
=loc definedness at L3%8%bbentry
1, 20, 21, 22, 23, 24, 29, 31, 32, 33
=loc definedness at L3%10%bbentry
1, 20, 21, 22, 23, 24, 29, 31, 32, 33
=loc definedness at E0%0%d
1, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33

=Branch affecting variable locs in src.spec.make_list
=branch affecting variable locs at L0%0%d
1
=branch affecting variable locs at L3%6%bbentry
23, 24
=branch affecting variable locs at L3%7%d
22, 23, 24
=branch affecting variable locs at L3%8%bbentry

=branch affecting variable locs at L3%10%bbentry
23, 24
=branch affecting variable locs at E0%0%d


=Relevant Memlabels in src.spec.make_list
=relevant memlabels
=function: make_list
memlabel-mem--heap
memlabel-mem--arg.0
=touched symbol ids

=relevant memlabels done
=graph_with_locs_done
=graph_with_edge_structures
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 23 {input.spec-%var-arr-0.L3%6%bbentry }
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 24 {input.spec-%var-i-0.L3%6%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 29 {input.spec-%var-l-0.L3%6%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 31 {input.spec-%tmpvar-10.L3%6%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 32 {input.spec-%tmpvar-9.L3%6%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry for loc_id 33 {input.src.spec-ghostvar.itervar.1.L3%6%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>L3%6%bbentry done
=graph_with_edge_structures.loc_to_expr_map at L3%6%bbentry=>L3%7%d
=graph_with_edge_structures.loc_to_expr_map at L3%6%bbentry=>L3%7%d for loc_id 22 {input.spec-%tmpvar-0.L3%7%d }
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : map_get(1, 2) : SUM[UNIT,BV:32]
=graph_with_edge_structures.loc_to_expr_map at L3%6%bbentry=>L3%7%d done
=graph_with_edge_structures.loc_to_expr_map at L3%7%d=>L3%8%bbentry
=graph_with_edge_structures.loc_to_expr_map at L3%7%d=>L3%8%bbentry done
=graph_with_edge_structures.loc_to_expr_map at L3%7%d=>L3%10%bbentry
=graph_with_edge_structures.loc_to_expr_map at L3%7%d=>L3%10%bbentry done
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d for loc_id 25 {input.spec-%tmpvar-11.E0%0%d }
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d for loc_id 26 {input.spec-%tmpvar-12.E0%0%d }
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d for loc_id 27 {input.spec-%tmpvar-7.E0%0%d }
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d for loc_id 28 {input.spec-%tmpvar-8.E0%0%d }
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d for loc_id 30 {input.spec-%var-u-0.E0%0%d }
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : sum_get(1, 2) : UNIT
=graph_with_edge_structures.loc_to_expr_map at L3%8%bbentry=>E0%0%d done
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 24 {input.spec-%var-i-0.L3%6%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 29 {input.spec-%var-l-0.L3%6%bbentry }
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 33 {input.src.spec-ghostvar.itervar.1.L3%6%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.src.spec-ghostvar.itervar.1.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 34 {input.spec-%tmpvar-1.L3%6%bbentry }
1 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
2 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : sum_get(2, 3) : BV:32
5 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : prod_init(1, 4, 5) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 35 {input.spec-%tmpvar-2.L3%6%bbentry }
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 36 {input.spec-%tmpvar-3.L3%6%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 37 {input.spec-%tmpvar-4.L3%6%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 38 {input.spec-%var-arr_i-0.L3%6%bbentry }
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : sum_get(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry for loc_id 39 {input.spec-%var-new_l-0.L3%6%bbentry }
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=graph_with_edge_structures.loc_to_expr_map at L3%10%bbentry=>L3%6%bbentry done
=graph_with_edge_structures.loc_to_expr_map done
=graph_with_edge_structures done
=graph_with_ml_contiguity_info vacuous mls
vacuous mls at L0%0%d:
vacuous mls at L3%6%bbentry:
vacuous mls at L3%7%d:
vacuous mls at L3%8%bbentry:
vacuous mls at L3%10%bbentry:
vacuous mls at E0%0%d:
=graph_with_ml_contiguity_info non-vacuous mls
non-vacuous mls at L0%0%d:
non-vacuous mls at L3%6%bbentry:
non-vacuous mls at L3%7%d:
non-vacuous mls at L3%8%bbentry:
non-vacuous mls at L3%10%bbentry:
non-vacuous mls at E0%0%d:
=graph_with_ml_contiguity_info discontiguous mls
discontiguous mls:
=graph_with_ml_contiguity_info done
=Available expressions in src.spec.make_list
=avail_exprs begin
=loc 1
=loc_expr
140273 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 23
=loc_expr
140366 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=avail_exprs_val.end
=loc 31
=loc_expr
140388 : input.spec-%tmpvar-10.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=avail_exprs_val.end
=loc 32
=loc_expr
140389 : input.spec-%tmpvar-9.L3%6%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 36
=loc_expr
140392 : input.spec-%tmpvar-3.L3%6%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 1 { 0x1 +1.11e129 } : BV:32
=avail_exprs_val.end
=avail_exprs end
=sprel_map in src.spec.make_list
=loc 31 expr
1 : input.spec-%tmpvar-10.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=loc 31 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140279 : unit : UNIT
140417 : Indxform9 : BV:32
140420 : Lambda18 : BV:32
140421 : lambda(140420, 140420) : FUNCTION[BV:32 -> BV:32]
140422 : Lambda19 : BV:32
140418 : sum(140276, 140279, 140417) : SUM[UNIT,BV:32]
140419 : prod(140276, 140418) : PROD[BV:32,SUM[UNIT,BV:32]]
140423 : lambda(140422, 140419) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
140426 : ind(140276, 140417, 140421, 140423) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
140427 : sum(140276, 140279, 140426) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
140428 : sym_const(140427) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=loc 32 expr
1 : input.spec-%tmpvar-9.L3%6%bbentry : BV:32
=loc 32 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 36 expr
1 : input.spec-%tmpvar-3.L3%6%bbentry : BV:32
=loc 36 spreled-expr
140298 : 1 { 0x1 +1.11e129 } : BV:32
=sprel_map done
=lr-status-map
=lr-status-map at call-context {*;make_list}
=loc_id 1 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 20 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, )
=loc_id 21 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, )
=loc_id 22 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 23 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 24 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 25 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 26 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 27 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 28 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 29 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 30 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 31 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 32 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 33 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 34 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 35 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 36 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 37 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 38 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=loc_id 39 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; memlabel-mem--heap, memlabel-mem--arg.0, )
=lr-status-map done
=lr-status-for-sprel-locs-map
=loc_id 31 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 32 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 36 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=lr-status-for-sprel-locs-map done
=graph_with_aliasing_done
=Memlabel assertions empty
=Memlabel assertions done
=graph_with_proofs done
=graph_with_ce done
=graph_with_points done
=graph_with_guessing done
=graph_with_simplified_assets
=graph_with_simplified_assets.simplified_edgecond at L0%0%d=>L3%6%bbentry
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at L3%6%bbentry=>L3%7%d
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at L3%7%d=>L3%8%bbentry
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : sum_is(1, 2) : BOOL
=graph_with_simplified_assets.simplified_edgecond at L3%7%d=>L3%10%bbentry
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : sum_is(1, 2) : BOOL
=graph_with_simplified_assets.simplified_edgecond at L3%8%bbentry=>E0%0%d
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at L3%10%bbentry=>L3%6%bbentry
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond done
=graph_with_simplified_assets.simplified_to_state at L0%0%d=>L3%6%bbentry
=spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=spec-%var-arr-0.L3%6%bbentry
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=state_end
=graph_with_simplified_assets.simplified_to_state at L3%6%bbentry=>L3%7%d
=spec-%tmpvar-0.L3%7%d
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : map_get(1, 2) : SUM[UNIT,BV:32]
=state_end
=graph_with_simplified_assets.simplified_to_state at L3%7%d=>L3%8%bbentry
=state_end
=graph_with_simplified_assets.simplified_to_state at L3%7%d=>L3%10%bbentry
=state_end
=graph_with_simplified_assets.simplified_to_state at L3%8%bbentry=>E0%0%d
=spec-%tmpvar-7.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-11.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-12.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-8.E0%0%d
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%var-u-0.E0%0%d
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 0 { 0x0 +1.0e1025 } : INT
3 : sum_get(1, 2) : UNIT
=state_end
=graph_with_simplified_assets.simplified_to_state at L3%10%bbentry=>L3%6%bbentry
=spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.src.spec-ghostvar.itervar.1.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=spec-%var-l-0.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-1.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
2 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : sum_get(2, 3) : BV:32
5 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : prod_init(1, 4, 5) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=spec-%var-arr_i-0.L3%6%bbentry
1 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : sum_get(1, 2) : BV:32
=spec-%tmpvar-2.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=spec-%tmpvar-4.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.spec-%var-i-0.L3%6%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=spec-%var-new_l-0.L3%6%bbentry
1 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : 1 { 0x1 +1.0e1025 } : INT
3 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
4 : input.spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
5 : sum_get(4, 2) : BV:32
6 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
7 : prod_init(3, 5, 6) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
8 : sum_init(1, 2, 7) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=state_end
=graph_with_simplified_assets.simplified_to_state done
=graph_with_simplified_assets.simplified_assumes at L0%0%d=>L3%6%bbentry
=graph_with_simplified_assets.simplified_assumes at L0%0%d=>L3%6%bbentry done
=graph_with_simplified_assets.simplified_assumes at L3%6%bbentry=>L3%7%d
=graph_with_simplified_assets.simplified_assumes at L3%6%bbentry=>L3%7%d done
=graph_with_simplified_assets.simplified_assumes at L3%7%d=>L3%8%bbentry
=graph_with_simplified_assets.simplified_assumes at L3%7%d=>L3%8%bbentry done
=graph_with_simplified_assets.simplified_assumes at L3%7%d=>L3%10%bbentry
=graph_with_simplified_assets.simplified_assumes at L3%7%d=>L3%10%bbentry done
=graph_with_simplified_assets.simplified_assumes at L3%8%bbentry=>E0%0%d
=graph_with_simplified_assets.simplified_assumes at L3%8%bbentry=>E0%0%d done
=graph_with_simplified_assets.simplified_assumes at L3%10%bbentry=>L3%6%bbentry
=graph_with_simplified_assets.simplified_assumes at L3%10%bbentry=>L3%6%bbentry done
=graph_with_simplified_assets.simplified_assumes done
=graph_with_simplified_assets done
=max-memlabel-varnum
0
=String-contents:
=Nextpc-map:
=Nextpc-map done
=suffixpaths for src.spec.make_list
=suffixpath_at_L0%0%d for src.spec.make_list
=suffixpath_at_L0%0%d.graph_edge_composition
(epsilon)
=suffixpath_at_L3%6%bbentry for src.spec.make_list
=suffixpath_at_L3%6%bbentry.graph_edge_composition
(L0%0%d=>L3%6%bbentry)
=suffixpath_at_L3%7%d for src.spec.make_list
=suffixpath_at_L3%7%d.graph_edge_composition
((L0%0%d=>L3%6%bbentry)*(L3%6%bbentry=>L3%7%d))
=suffixpath_at_L3%8%bbentry for src.spec.make_list
=suffixpath_at_L3%8%bbentry.graph_edge_composition
((L0%0%d=>L3%6%bbentry)*((L3%6%bbentry=>L3%7%d)*(L3%7%d=>L3%8%bbentry)))
=suffixpath_at_L3%10%bbentry for src.spec.make_list
=suffixpath_at_L3%10%bbentry.graph_edge_composition
((L0%0%d=>L3%6%bbentry)*((L3%6%bbentry=>L3%7%d)*(L3%7%d=>L3%10%bbentry)))
=suffixpath_at_E0%0%d for src.spec.make_list
=suffixpath_at_E0%0%d.graph_edge_composition
((L0%0%d=>L3%6%bbentry)*((L3%6%bbentry=>L3%7%d)*((L3%7%d=>L3%8%bbentry)*(L3%8%bbentry=>E0%0%d))))
=suffixpaths for src.spec.make_list done
=tfg.assumes_around_edge
tfg.assumes_around_edge at L0%0%d=>L3%6%bbentry
tfg.assumes_around_edge at L0%0%d=>L3%6%bbentry done
tfg.assumes_around_edge at L3%6%bbentry=>L3%7%d
tfg.assumes_around_edge at L3%6%bbentry=>L3%7%d done
tfg.assumes_around_edge at L3%7%d=>L3%8%bbentry
tfg.assumes_around_edge at L3%7%d=>L3%8%bbentry done
tfg.assumes_around_edge at L3%7%d=>L3%10%bbentry
tfg.assumes_around_edge at L3%7%d=>L3%10%bbentry done
tfg.assumes_around_edge at L3%8%bbentry=>E0%0%d
tfg.assumes_around_edge at L3%8%bbentry=>E0%0%d done
tfg.assumes_around_edge at L3%10%bbentry=>L3%6%bbentry
tfg.assumes_around_edge at L3%10%bbentry=>L3%6%bbentry done
tfg.assumes_around_edge done
=TFGdone
=TFG_SPEC_done
=TFG_SSA_done
=dst_tfg
=TFG_SSA:
=TFG_LLVM dst.llvm.make_list:
=TFG:
=Nodes: L0%0%d Lfor.body%1%intermediateVal1 Lfor.body%1%fcallStart Lfor.body%1%fcallEnd Lfor.body%2%d Lfor.cond%1%bbentry Lfor.cond%2%d Lfor.end%1%d E0%0%d
=Edges:
L0%0%d => Lfor.cond%1%bbentry
Lfor.cond%1%bbentry => Lfor.cond%2%d
Lfor.cond%2%d => Lfor.body%1%fcallStart
Lfor.cond%2%d => Lfor.end%1%d
Lfor.end%1%d => E0%0%d
Lfor.body%1%fcallStart => Lfor.body%1%fcallEnd
Lfor.body%1%fcallEnd => Lfor.body%1%intermediateVal1
Lfor.body%1%intermediateVal1 => Lfor.body%2%d
Lfor.body%2%d => Lfor.cond%1%bbentry (backedge) 
=graph done
=is_ssa_graph:
1
=StartState:
=dst.llvm-%arr
1 : input.dst.llvm-%arr : BV:32
=dst.llvm-%n
1 : input.dst.llvm-%n : BV:32
=dst.llvm-mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=state_end
=PC to var-version map at L0%0%d
=version for dst.llvm-mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.body%1%intermediateVal1
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.body%1%fcallStart
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.body%1%fcallEnd
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.body%2%d
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.cond%1%bbentry
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.cond%2%d
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at Lfor.end%1%d
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=PC to var-version map at E0%0%d
=version for dst.llvm-mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=version for dst.llvm-mem.alloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=var-version done
=graph_with_var_versions done
=FunctionName: make_list
=Input: tfg-method-arg.0
=arg addr
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
=arg val
1 : input.dst.llvm-%arr : BV:32
=arg end
=Input: tfg-method-arg.1
=arg addr
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
=arg val
1 : input.dst.llvm-%n : BV:32
=arg end
=Node outputs: E0%0%d
=Output: heap
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=Output: llvm-indir_tgt
1 : retaddr_const : BV:32
=Output: llvm-%ret-reg
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=Node outputs done for E0%0%d
=input_outputs done
=Symbol-map:
C_SYMBOL1 : make_list : 26 : 1 : 0
=Touched symbols:
=Symbol-map done
=Locals-map:
C_LOCAL=L0%0%argnum0= : dst.llvm-%arr : 4 : 4 : 0
C_LOCAL=L0%0%argnum1= : dst.llvm-%n : 4 : 4 : 0
=Locals-map done
=Global assumes
=global assume predicate_set done
Memlabel map for call-context {*;make_list}
=memlabel_map.0 for call-context {*;make_list}
mlcall.dst.llvm.make_list.3 : memlabel-mem-
=memlabel_map.1 for call-context {*;make_list}
mlcall.dst.llvm.make_list.4 : memlabel-mem-
=memlabel_map.2 for call-context {*;make_list}
mlheap.dst.llvm.make_list : memlabel-mem-may-straddle-symbol.1-heap
=memlabel_map.3 for call-context {*;make_list}
mlvar.dst.llvm.make_list.0 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0
=memlabel_map.4 for call-context {*;make_list}
mlvar.dst.llvm.make_list.1 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=memlabel_map.5 for call-context {*;make_list}
mlvar.dst.llvm.make_list.2 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Edge: L0%0%d => Lfor.cond%1%bbentry
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=dst.llvm-%arr.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr : BV:32
=dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%n.Lfor.cond%1%bbentry
1 : input.dst.llvm-%n : BV:32
=dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-mem.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.cond%1%bbentry
1 : input.dst.local_alloc_count.=L0%0%d= : COUNT
=state_end
=Edge.Assumes.begin:
=EdgeAssume.0
1 : input.dst.llvm-%arr : BV:32
2 : 4 { 0x4 +1.0e1025 } : INT
3 : islangaligned(1, 2) : BOOL
=Edge.Assumes.end
=Edge.te_comment
0:-1:((((((start_pc_edge*  br label %for.cond, !dbg !28)*  %l.0 = phi %struct.list* [ null, %entry ], [ %0, %for.inc ], !dbg !22)*(  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ], !dbg !27*  br label %for.cond, !dbg !28))*  br label %for.cond, !dbg !28)*(  br label %for.cond, !dbg !28*  br label %for.cond, !dbg !28))*(ghost_var.itervar.firstedge*ghost_var.itervar.secondedge))
tfg_edge_comment end

=Edge: Lfor.cond%1%bbentry => Lfor.cond%2%d
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.llvm-%cmp.Lfor.cond%2%d
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:-1:(bb_entry*  %cmp = icmp ult i32 %i.0, %n, !dbg !29)
tfg_edge_comment end

=Edge: Lfor.cond%2%d => Lfor.body%1%fcallStart
=Edge.EdgeCond: 
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=Edge.StateTo: 
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:2:((  br i1 %cmp, label %for.body, label %for.end, !dbg !31*  br i1 %cmp, label %for.body, label %for.end, !dbg !31)*(  br i1 %cmp, label %for.body, label %for.end, !dbg !31*fcall_edge_start))
tfg_edge_comment end

=Edge: Lfor.cond%2%d => Lfor.end%1%d
=Edge.EdgeCond: 
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
2 : not(1) : BOOL
=Edge.StateTo: 
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:2:((  br i1 %cmp, label %for.body, label %for.end, !dbg !31*  br i1 %cmp, label %for.body, label %for.end, !dbg !31)*  br i1 %cmp, label %for.body, label %for.end, !dbg !31)
tfg_edge_comment end

=Edge: Lfor.end%1%d => E0%0%d
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.llvm-%hidden-reg.E0%0%d
1 : input.dst.llvm-%hidden-reg : BV:32
2 : input.dst.llvm-callee-save.0 : BV:32
3 : bvxor(1, 2) : BV:32
4 : input.dst.llvm-callee-save.1 : BV:32
5 : bvxor(3, 4) : BV:32
6 : input.dst.llvm-callee-save.2 : BV:32
7 : bvxor(5, 6) : BV:32
8 : input.dst.llvm-callee-save.3 : BV:32
9 : bvxor(7, 8) : BV:32
=dst.llvm-%ret-reg.E0%0%d
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=dst.llvm-indir_tgt.E0%0%d
1 : retaddr_const : BV:32
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:1:  ret %struct.list* %l.0, !dbg !46
tfg_edge_comment end

=Edge: Lfor.body%1%fcallStart => Lfor.body%1%fcallEnd
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.llvm-%call.Lfor.body%1%fcallEnd
1 : func.calla4bcb626de6152719ca44f8b649b9c4a.reg : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
2 : mlcall.dst.llvm.make_list.3 : MEMLABEL
3 : mlcall.dst.llvm.make_list.4 : MEMLABEL
4 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : nextpc_const.1 : BV:32
7 : 1000 { 0x3e8 +1.11920e129 } : REGID
8 : 8 { 0x8 +1.95e129 } : BV:32
9 : function_call(1, 2, 3, 4, 5, 6, 7, 8) : BV:32
=dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=dst.llvm-mem.Lfor.body%1%fcallEnd
1 : func.call30eccc4aa0775a3174483e053ab761b.mem : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> ARRAY[BV:32 -> BV:8]]
2 : mlcall.dst.llvm.make_list.3 : MEMLABEL
3 : mlcall.dst.llvm.make_list.4 : MEMLABEL
4 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : nextpc_const.1 : BV:32
7 : 0 { 0x0 +1.0e129 } : REGID
8 : 8 { 0x8 +1.95e129 } : BV:32
9 : function_call(1, 2, 3, 4, 5, 6, 7, 8) : ARRAY[BV:32 -> BV:8]
=state_end
=Edge.Assumes.begin:
=Edge.Assumes.end
=Edge.te_comment
0:-1:(fcall_edge_arg*  %call = call i8* @malloc(i32 8), !dbg !32)
tfg_edge_comment end

=Edge: Lfor.body%1%fcallEnd => Lfor.body%1%intermediateVal1
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=state_end
=Edge.Assumes.begin:
=EdgeAssume.0
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : islangaligned(1, 2) : BOOL
=Edge.Assumes.end
=Edge.te_comment
0:-1:(fcall_edge_end*  %call = call i8* @malloc(i32 8), !dbg !32)
tfg_edge_comment end

=Edge: Lfor.body%1%intermediateVal1 => Lfor.body%2%d
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.llvm-%arr.Lfor.body%2%d
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%call.Lfor.body%2%d
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
5 : heap_alloc_ptr(1, 4) : BV:32
6 : ite(3, 2, 5) : BV:32
=dst.llvm-%i.0.Lfor.body%2%d
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%l.0.Lfor.body%2%d
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%n.Lfor.body%2%d
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-mem.Lfor.body%2%d
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 1, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 1, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.body%2%d
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
6 : 8 { 0x8 +1.95e129 } : BV:32
7 : heap_alloc(4, 5, 1, 6) : ARRAY[BV:32 -> MEMLABEL]
8 : ite(3, 4, 7) : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.body%2%d
1 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
2 : increment_count(1) : COUNT
=state_end
=Edge.Assumes.begin:
=EdgeAssume.0
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 8 { 0x8 +1.95e129 } : BV:32
5 : eq(4, 2) : BOOL
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : heap_alloc_ptr(1, 6) : BV:32
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : bvadd(7, 9) : BV:32
11 : bvule(7, 10) : BOOL
12 : or(5, 11) : BOOL
13 : or(3, 12) : BOOL
=EdgeAssume.1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : 8 { 0x8 +1.95e129 } : BV:32
6 : mlheap.dst.llvm.make_list : MEMLABEL
7 : region_agrees_with_memlabel(4, 1, 5, 6) : BOOL
8 : or(3, 7) : BOOL
=Edge.Assumes.end
=Edge.te_comment
0:1:  %call = call i8* @malloc(i32 8), !dbg !32
tfg_edge_comment end

=Edge: Lfor.body%2%d => Lfor.cond%1%bbentry
=Edge.EdgeCond: 
1 : 1 { 0x1 } : BOOL
=Edge.StateTo: 
=dst.llvm-%arr.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=dst.llvm-%n.Lfor.cond%1%bbentry
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-mem.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : mlvar.dst.llvm.make_list.1 : MEMLABEL
4 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : 8 { 0x8 +1.95e129 } : BV:32
7 : bvmul(5, 6) : BV:32
8 : bvadd(5, 7) : BV:32
9 : bvadd(8, 5) : BV:32
10 : bvadd(4, 9) : BV:32
11 : mlvar.dst.llvm.make_list.0 : MEMLABEL
12 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
13 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
14 : 4 { 0x4 +1.47e129 } : BV:32
15 : bvmul(13, 14) : BV:32
16 : bvadd(5, 15) : BV:32
17 : bvadd(12, 16) : BV:32
18 : 4 { 0x4 +1.0e1025 } : INT
19 : 0 { 0x0 } : BOOL
20 : select(1, 2, 11, 17, 18, 19) : BV:32
21 : store(1, 2, 3, 10, 20, 18, 19) : ARRAY[BV:32 -> BV:8]
22 : mlvar.dst.llvm.make_list.2 : MEMLABEL
23 : bvadd(8, 14) : BV:32
24 : bvadd(4, 23) : BV:32
25 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
26 : store(21, 2, 22, 24, 25, 18, 19) : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.cond%1%bbentry
1 : input.dst.local_alloc_count.Lfor.body%2%d : COUNT
=dst.llvm-%0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%1.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : mlvar.dst.llvm.make_list.0 : MEMLABEL
4 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
7 : 4 { 0x4 +1.47e129 } : BV:32
8 : bvmul(6, 7) : BV:32
9 : bvadd(5, 8) : BV:32
10 : bvadd(4, 9) : BV:32
11 : 4 { 0x4 +1.0e1025 } : INT
12 : 0 { 0x0 } : BOOL
13 : select(1, 2, 3, 10, 11, 12) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(3, 4) : BV:32
6 : bvadd(2, 5) : BV:32
7 : bvadd(1, 6) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : bvmul(1, 2) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvadd(1, 3) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvadd(1, 3) : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvadd(4, 5) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 8 { 0x8 +1.95e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(2, 4) : BV:32
6 : 4 { 0x4 +1.47e129 } : BV:32
7 : bvadd(5, 6) : BV:32
8 : bvadd(1, 7) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(3, 4) : BV:32
6 : bvadd(2, 5) : BV:32
7 : bvadd(1, 6) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvadd(1, 3) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvadd(1, 3) : BV:32
5 : bvadd(4, 1) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 8 { 0x8 +1.95e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(2, 4) : BV:32
6 : bvadd(5, 2) : BV:32
7 : bvadd(1, 6) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : bvmul(1, 2) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%next.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 8 { 0x8 +1.95e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(2, 4) : BV:32
6 : 4 { 0x4 +1.47e129 } : BV:32
7 : bvadd(5, 6) : BV:32
8 : bvadd(1, 7) : BV:32
=dst.llvm-%val.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 8 { 0x8 +1.95e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(2, 4) : BV:32
6 : bvadd(5, 2) : BV:32
7 : bvadd(1, 6) : BV:32
=state_end
=Edge.Assumes.begin:
=EdgeAssume.0
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 8 { 0x8 +1.95e129 } : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(2, 4) : BV:32
6 : 4 { 0x4 +1.47e129 } : BV:32
7 : bvadd(5, 6) : BV:32
8 : bvadd(1, 7) : BV:32
9 : 4 { 0x4 +1.0e1025 } : INT
10 : islangaligned(8, 9) : BOOL
=EdgeAssume.1
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvslt(1, 2) : BOOL
4 : 32 { 0x20 +1.0e1025 } : INT
5 : bvsign_ext(1, 4) : BV:64
6 : 4 { 0x4 +1.47e129 } : BV:32
7 : bvzero_ext(6, 4) : BV:64
8 : bvmul(5, 7) : BV:64
9 : 63 { 0x3f +1.0e1025 } : INT
10 : bvextract(8, 9, 4) : BV:32
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : eq(10, 11) : BOOL
13 : eq(10, 2) : BOOL
14 : ite(3, 12, 13) : BOOL
15 : 4 { 0x4 +1.0e1025 } : INT
16 : isindexforsize(14, 15) : BOOL
17 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
18 : bvmul(1, 6) : BV:32
19 : bvadd(2, 18) : BV:32
20 : bvadd(17, 19) : BV:32
21 : isgepoffset(20, 18) : BOOL
22 : and(16, 21) : BOOL
23 : islangaligned(20, 15) : BOOL
24 : and(22, 23) : BOOL
25 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
26 : 8 { 0x8 +1.95e129 } : BV:32
27 : bvmul(2, 26) : BV:32
28 : bvadd(2, 27) : BV:32
29 : bvadd(25, 28) : BV:32
30 : isgepoffset(29, 27) : BOOL
31 : bvslt(2, 2) : BOOL
32 : bvsign_ext(2, 4) : BV:64
33 : bvzero_ext(26, 4) : BV:64
34 : bvmul(32, 33) : BV:64
35 : bvextract(34, 9, 4) : BV:32
36 : eq(35, 11) : BOOL
37 : eq(35, 2) : BOOL
38 : ite(31, 36, 37) : BOOL
39 : 8 { 0x8 +1.0e1025 } : INT
40 : isindexforsize(38, 39) : BOOL
41 : and(30, 40) : BOOL
42 : bvadd(28, 2) : BV:32
43 : bvadd(25, 42) : BV:32
44 : isgepoffset(43, 2) : BOOL
45 : and(41, 44) : BOOL
46 : and(24, 45) : BOOL
47 : islangaligned(43, 15) : BOOL
48 : and(46, 47) : BOOL
49 : bvadd(28, 6) : BV:32
50 : bvadd(25, 49) : BV:32
51 : isgepoffset(50, 6) : BOOL
52 : and(41, 51) : BOOL
53 : and(48, 52) : BOOL
=Edge.Assumes.end
=Edge.te_comment
0:2:(((((((  %0 = bitcast i8* %call to %struct.list*, !dbg !32*  %arrayidx = getelementptr inbounds i32, i32* %arr, i32 %i.0, !dbg !36)*(  %arrayidx = getelementptr inbounds i32, i32* %arr, i32 %i.0, !dbg !36*  %arrayidx = getelementptr inbounds i32, i32* %arr, i32 %i.0, !dbg !36))*(  %1 = load i32, i32* %arrayidx, align 4, !dbg !36*  %1 = load i32, i32* %arrayidx, align 4, !dbg !36))*((  %val = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 0, !dbg !37*  %val = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 0, !dbg !37)*(  %val = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 0, !dbg !37*  %val = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 0, !dbg !37)))*  store i32 %1, i32* %val, align 4, !dbg !38)*((  %next = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 1, !dbg !39*  %next = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 1, !dbg !39)*(  %next = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 1, !dbg !39*  %next = getelementptr inbounds %struct.list, %struct.list* %0, i32 0, i32 1, !dbg !39)))*(((((  store %struct.list* %l.0, %struct.list** %next, align 4, !dbg !40*  br label %for.inc, !dbg !41)*  br label %for.inc, !dbg !41)*  br label %for.inc, !dbg !41)*(((((  %inc = add i32 %i.0, 1, !dbg !42*  br label %for.cond, !dbg !43, !llvm.loop !44)*  %l.0 = phi %struct.list* [ null, %entry ], [ %0, %for.inc ], !dbg !22)*(  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ], !dbg !27*  br label %for.cond, !dbg !43, !llvm.loop !44))*  br label %for.cond, !dbg !43, !llvm.loop !44)*(  br label %for.cond, !dbg !43, !llvm.loop !44*  br label %for.cond, !dbg !43, !llvm.loop !44)))*(ghost_var.itervar.firstedge*ghost_var.itervar.secondedge)))
tfg_edge_comment end

=graph_with_predicates_done

=start_pc_preconditions
=start_pc_precondition.0
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
5 : 4 { 0x4 +1.0e1025 } : INT
6 : 0 { 0x0 } : BOOL
7 : select(1, 2, 3, 4, 5, 6) : BV:32
=RhsExpr
1 : input.dst.llvm-%arr : BV:32
=predicate done
=start_pc_precondition.1
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
5 : 4 { 0x4 +1.0e1025 } : INT
6 : 0 { 0x0 } : BOOL
7 : select(1, 2, 3, 4, 5, 6) : BV:32
=RhsExpr
1 : input.dst.llvm-%n : BV:32
=predicate done
=graph_with_precondition_done

=Locs in dst.llvm.make_list
=Loc 100006 in dst.llvm.make_list.
REGMEM
dst.llvm-%n
1 : input.dst.llvm-%n : BV:32
=Loc 100008 in dst.llvm.make_list.
REGMEM
dst.llvm-%arr
1 : input.dst.llvm-%arr : BV:32
=Loc 100031 in dst.llvm.make_list.
REGMEM
dst.llvm-%hidden-reg
1 : input.dst.llvm-%hidden-reg : BV:32
=Loc 100033 in dst.llvm.make_list.
REGMEM
dst.llvm-callee-save.0
1 : input.dst.llvm-callee-save.0 : BV:32
=Loc 100034 in dst.llvm.make_list.
REGMEM
dst.llvm-callee-save.1
1 : input.dst.llvm-callee-save.1 : BV:32
=Loc 100035 in dst.llvm.make_list.
REGMEM
dst.llvm-callee-save.2
1 : input.dst.llvm-callee-save.2 : BV:32
=Loc 100036 in dst.llvm.make_list.
REGMEM
dst.llvm-callee-save.3
1 : input.dst.llvm-callee-save.3 : BV:32
=Loc 100040 in dst.llvm.make_list.
REGMEM
dst.local_alloc_count.=L0%0%d=
1 : input.dst.local_alloc_count.=L0%0%d= : COUNT
=Loc 100041 in dst.llvm.make_list.
REGMEM
dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
=Loc 100042 in dst.llvm.make_list.
REGMEM
dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
=Loc 100044 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.0
=Loc 100045 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100046 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
=Loc 100047 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem-may-straddle-symbol.1-heap
=Loc 100048 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
=Loc 100049 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100050 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.1
=Loc 100051 in dst.llvm.make_list.
REGMEM
dst.llvm-%arr.Lfor.body%2%d
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=Loc 100052 in dst.llvm.make_list.
REGMEM
dst.llvm-%arr.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=Loc 100053 in dst.llvm.make_list.
REGMEM
dst.llvm-%call.Lfor.body%1%fcallEnd
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=Loc 100054 in dst.llvm.make_list.
REGMEM
dst.llvm-%call.Lfor.body%2%d
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=Loc 100055 in dst.llvm.make_list.
REGMEM
dst.llvm-%i.0.Lfor.body%2%d
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=Loc 100056 in dst.llvm.make_list.
REGMEM
dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=Loc 100057 in dst.llvm.make_list.
REGMEM
dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=Loc 100058 in dst.llvm.make_list.
REGMEM
dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=Loc 100059 in dst.llvm.make_list.
REGMEM
dst.llvm-%l.0.Lfor.body%2%d
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=Loc 100060 in dst.llvm.make_list.
REGMEM
dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=Loc 100061 in dst.llvm.make_list.
REGMEM
dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=Loc 100062 in dst.llvm.make_list.
REGMEM
dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=Loc 100063 in dst.llvm.make_list.
REGMEM
dst.llvm-%n.Lfor.body%2%d
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=Loc 100064 in dst.llvm.make_list.
REGMEM
dst.llvm-%n.Lfor.cond%1%bbentry
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=Loc 100065 in dst.llvm.make_list.
REGMEM
dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=Loc 100066 in dst.llvm.make_list.
REGMEM
dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=Loc 100067 in dst.llvm.make_list.
REGMEM
dst.llvm-%hidden-reg.E0%0%d
1 : input.dst.llvm-%hidden-reg.E0%0%d : BV:32
=Loc 100068 in dst.llvm.make_list.
REGMEM
dst.llvm-%ret-reg.E0%0%d
1 : input.dst.llvm-%ret-reg.E0%0%d : BV:32
=Loc 100069 in dst.llvm.make_list.
REGMEM
dst.llvm-indir_tgt.E0%0%d
1 : input.dst.llvm-indir_tgt.E0%0%d : BV:32
=Loc 100070 in dst.llvm.make_list.
REGMEM
dst.llvm-%cmp.Lfor.cond%2%d
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=Loc 100071 in dst.llvm.make_list.
REGMEM
dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=Loc 100072 in dst.llvm.make_list.
REGMEM
dst.llvm-%0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=Loc 100073 in dst.llvm.make_list.
REGMEM
dst.llvm-%1.Lfor.cond%1%bbentry
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=Loc 100074 in dst.llvm.make_list.
REGMEM
dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100075 in dst.llvm.make_list.
REGMEM
dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100076 in dst.llvm.make_list.
REGMEM
dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=Loc 100077 in dst.llvm.make_list.
REGMEM
dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100078 in dst.llvm.make_list.
REGMEM
dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100079 in dst.llvm.make_list.
REGMEM
dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100080 in dst.llvm.make_list.
REGMEM
dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=Loc 100081 in dst.llvm.make_list.
REGMEM
dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=Loc 100082 in dst.llvm.make_list.
REGMEM
dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=Loc 100083 in dst.llvm.make_list.
REGMEM
dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100084 in dst.llvm.make_list.
REGMEM
dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100085 in dst.llvm.make_list.
REGMEM
dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=Loc 100086 in dst.llvm.make_list.
REGMEM
dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=Loc 100087 in dst.llvm.make_list.
REGMEM
dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=Loc 100088 in dst.llvm.make_list.
REGMEM
dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=Loc 100089 in dst.llvm.make_list.
REGMEM
dst.llvm-%inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=Loc 100090 in dst.llvm.make_list.
REGMEM
dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=Loc 100091 in dst.llvm.make_list.
REGMEM
dst.llvm-%next.Lfor.cond%1%bbentry
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=Loc 100092 in dst.llvm.make_list.
REGMEM
dst.llvm-%val.Lfor.cond%1%bbentry
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=Loc 100093 in dst.llvm.make_list.
REGMEM
dst.local_alloc_count.Lfor.body%2%d
1 : input.dst.local_alloc_count.Lfor.body%2%d : COUNT
=Loc 100094 in dst.llvm.make_list.
REGMEM
dst.local_alloc_count.Lfor.cond%1%bbentry
1 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
=Loc 100095 in dst.llvm.make_list.
REGMEM
dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : input.dst.cur_rounding_mode.Lfor.cond%1%bbentry : ROUNDING_MODE
=Loc 100096 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.0
=Loc 100097 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem-may-straddle-symbol.1-heap
=Loc 100098 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100099 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100100 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
=Loc 100101 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
=Loc 100102 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.1
=Loc 100103 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.0
=Loc 100104 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem-may-straddle-symbol.1-heap
=Loc 100105 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100106 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100107 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
=Loc 100108 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
=Loc 100109 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.1
=Loc 100110 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.0
=Loc 100111 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem-may-straddle-symbol.1-heap
=Loc 100112 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100113 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
=Loc 100114 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
=Loc 100115 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
=Loc 100116 in dst.llvm.make_list.
MASKED
=mem
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
=memalloc
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=memlabel
memlabel-mem--arg.1
=Locs end
=Liveness in dst.llvm.make_list
=live locs at L0%0%d
100006, 100008, 100040, 100045, 100046, 100047, 100048, 100049, 
=live locs at Lfor.body%1%intermediateVal1
100052, 100053, 100056, 100060, 100064, 100094, 100097, 100098, 100099, 100100, 100101, 
=live locs at Lfor.body%1%fcallStart
100052, 100056, 100060, 100064, 100094, 100104, 100105, 100106, 100107, 100108, 
=live locs at Lfor.body%1%fcallEnd
100052, 100053, 100056, 100060, 100064, 100094, 100097, 100098, 100099, 100100, 100101, 
=live locs at Lfor.body%2%d
100051, 100054, 100055, 100059, 100063, 100093, 100111, 100112, 100113, 100114, 100115, 
=live locs at Lfor.cond%1%bbentry
100052, 100056, 100060[f], 100064, 100094, 100104, 100105, 100106, 100107, 100108, 
=live locs at Lfor.cond%2%d
100052, 100056, 100060[f], 100064, 100070, 100094, 100104, 100105, 100106, 100107, 100108, 
=live locs at Lfor.end%1%d
100060[f], 100104, 
=live locs at E0%0%d
100060[f], 100104, 

=Definedness in dst.llvm.make_list
=loc definedness at L0%0%d
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050
=loc definedness at Lfor.body%1%intermediateVal1
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100053, 100056, 100058, 100060, 100062, 100064, 100065, 100070, 100071, 100094, 100095, 100096, 100097, 100098, 100099, 100100, 100101, 100102, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at Lfor.body%1%fcallStart
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100056, 100058, 100060, 100062, 100064, 100070, 100071, 100094, 100095, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at Lfor.body%1%fcallEnd
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100053, 100056, 100058, 100060, 100062, 100064, 100065, 100070, 100071, 100094, 100095, 100096, 100097, 100098, 100099, 100100, 100101, 100102, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at Lfor.body%2%d
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100051, 100052, 100053, 100054, 100055, 100056, 100057, 100058, 100059, 100060, 100061, 100062, 100063, 100064, 100065, 100066, 100070, 100071, 100093, 100094, 100095, 100096, 100097, 100098, 100099, 100100, 100101, 100102, 100103, 100104, 100105, 100106, 100107, 100108, 100109, 100110, 100111, 100112, 100113, 100114, 100115, 100116
=loc definedness at Lfor.cond%1%bbentry
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100056, 100058, 100060, 100062, 100064, 100071, 100094, 100095, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at Lfor.cond%2%d
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100056, 100058, 100060, 100062, 100064, 100070, 100071, 100094, 100095, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at Lfor.end%1%d
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100056, 100058, 100060, 100062, 100064, 100070, 100071, 100094, 100095, 100103, 100104, 100105, 100106, 100107, 100108, 100109
=loc definedness at E0%0%d
100006, 100008, 100041, 100042, 100044, 100045, 100046, 100047, 100048, 100049, 100050, 100052, 100056, 100058, 100060, 100062, 100064, 100067, 100068, 100069, 100070, 100071, 100094, 100095, 100103, 100104, 100105, 100106, 100107, 100108, 100109

=Branch affecting variable locs in dst.llvm.make_list
=branch affecting variable locs at L0%0%d
100006
=branch affecting variable locs at Lfor.body%1%intermediateVal1
100056, 100064
=branch affecting variable locs at Lfor.body%1%fcallStart
100056, 100064
=branch affecting variable locs at Lfor.body%1%fcallEnd
100056, 100064
=branch affecting variable locs at Lfor.body%2%d
100055, 100063
=branch affecting variable locs at Lfor.cond%1%bbentry
100056, 100064
=branch affecting variable locs at Lfor.cond%2%d
100056, 100064, 100070
=branch affecting variable locs at Lfor.end%1%d

=branch affecting variable locs at E0%0%d


=Relevant Memlabels in dst.llvm.make_list
=relevant memlabels
=function: make_list
memlabel-mem--arg.0
memlabel-mem-may-straddle-symbol.1-heap
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
memlabel-mem--arg.1
=touched symbol ids

=relevant memlabels done
=graph_with_locs_done
=graph_with_edge_structures
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100052 {input.dst.llvm-%arr.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%arr : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100056 {input.dst.llvm-%i.0.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100058 {input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100060 {input.dst.llvm-%l.0.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100062 {input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100064 {input.dst.llvm-%n.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%n : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100071 {input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100094 {input.dst.local_alloc_count.Lfor.cond%1%bbentry }
1 : input.dst.local_alloc_count.=L0%0%d= : COUNT
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100095 {input.dst.cur_rounding_mode.Lfor.cond%1%bbentry }
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100103 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.0) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100104 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem-may-straddle-symbol.1-heap) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100105 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100106 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100107 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100108 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry for loc_id 100109 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.1) }
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at L0%0%d=>Lfor.cond%1%bbentry done
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100051 {input.dst.llvm-%arr.Lfor.body%2%d }
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100054 {input.dst.llvm-%call.Lfor.body%2%d }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
5 : heap_alloc_ptr(2, 4) : BV:32
6 : ite(3, 1, 5) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100055 {input.dst.llvm-%i.0.Lfor.body%2%d }
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100057 {input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d }
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100059 {input.dst.llvm-%l.0.Lfor.body%2%d }
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100061 {input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d }
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100063 {input.dst.llvm-%n.Lfor.body%2%d }
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100066 {input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d }
1 : 8 { 0x8 +1.95e129 } : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : heap_alloc(5, 6, 3, 1) : ARRAY[BV:32 -> MEMLABEL]
8 : ite(4, 5, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : malloc_side_effect(1, 8, 6) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100093 {input.dst.local_alloc_count.Lfor.body%2%d }
1 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
2 : increment_count(1) : COUNT
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100110 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--arg.0) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem--arg.0 : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100111 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem-may-straddle-symbol.1-heap) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100112 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memmask(13, 12, 6) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100113 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100114 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100115 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d for loc_id 100116 {memmask(input.dst.llvm-mem.Lfor.body%2%d, input.dst.llvm-mem.alloc.Lfor.body%2%d, memlabel-mem--arg.1) }
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
14 : memlabel-mem--arg.1 : MEMLABEL
15 : memmask(13, 12, 14) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%intermediateVal1=>Lfor.body%2%d done
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100053 {input.dst.llvm-%call.Lfor.body%1%fcallEnd }
1 : func.calla4bcb626de6152719ca44f8b649b9c4a.reg : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
2 : memlabel-mem- : MEMLABEL
3 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : nextpc_const.1 : BV:32
6 : 1000 { 0x3e8 +1.11920e129 } : REGID
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : function_call(1, 2, 2, 3, 4, 5, 6, 7) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100065 {input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd }
1 : 8 { 0x8 +1.95e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100096 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.0) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100097 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem-may-straddle-symbol.1-heap) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100098 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100099 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100100 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100101 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd for loc_id 100102 {memmask(input.dst.llvm-mem.Lfor.body%1%fcallEnd, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.1) }
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd done
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 done
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100052 {input.dst.llvm-%arr.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100056 {input.dst.llvm-%i.0.Lfor.cond%1%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100058 {input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100060 {input.dst.llvm-%l.0.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100062 {input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100064 {input.dst.llvm-%n.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100071 {input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100072 {input.dst.llvm-%0.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100073 {input.dst.llvm-%1.Lfor.cond%1%bbentry }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0 : MEMLABEL
4 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
7 : bvmul(5, 6) : BV:32
8 : bvadd(4, 7) : BV:32
9 : 4 { 0x4 +1.0e1025 } : INT
10 : 0 { 0x0 } : BOOL
11 : select(1, 2, 3, 8, 9, 10) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100074 {input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100075 {input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100076 {input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100077 {input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100078 {input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100079 {input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100080 {input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100081 {input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100082 {input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100083 {input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100084 {input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100085 {input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100086 {input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100087 {input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry }
1 : 0 { 0x0 +1.0e129 } : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100088 {input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100089 {input.dst.llvm-%inc.Lfor.cond%1%bbentry }
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100090 {input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100091 {input.dst.llvm-%next.Lfor.cond%1%bbentry }
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100092 {input.dst.llvm-%val.Lfor.cond%1%bbentry }
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100094 {input.dst.local_alloc_count.Lfor.cond%1%bbentry }
1 : input.dst.local_alloc_count.Lfor.body%2%d : COUNT
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100103 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.0) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100104 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem-may-straddle-symbol.1-heap) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100105 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
5 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0 : MEMLABEL
6 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
7 : 4 { 0x4 +1.47e129 } : BV:32
8 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
9 : bvmul(7, 8) : BV:32
10 : bvadd(6, 9) : BV:32
11 : 4 { 0x4 +1.0e1025 } : INT
12 : 0 { 0x0 } : BOOL
13 : select(1, 2, 5, 10, 11, 12) : BV:32
14 : store(1, 2, 3, 4, 13, 11, 12) : ARRAY[BV:32 -> BV:8]
15 : bvadd(7, 4) : BV:32
16 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
17 : store(14, 2, 3, 15, 16, 11, 12) : ARRAY[BV:32 -> BV:8]
18 : memmask(17, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100106 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100107 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100108 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry for loc_id 100109 {memmask(input.dst.llvm-mem.Lfor.cond%1%bbentry, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--arg.1) }
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=graph_with_edge_structures.loc_to_expr_map at Lfor.body%2%d=>Lfor.cond%1%bbentry done
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%1%bbentry=>Lfor.cond%2%d
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%1%bbentry=>Lfor.cond%2%d for loc_id 100070 {input.dst.llvm-%cmp.Lfor.cond%2%d }
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%1%bbentry=>Lfor.cond%2%d done
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%2%d=>Lfor.body%1%fcallStart
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%2%d=>Lfor.body%1%fcallStart done
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%2%d=>Lfor.end%1%d
=graph_with_edge_structures.loc_to_expr_map at Lfor.cond%2%d=>Lfor.end%1%d done
=graph_with_edge_structures.loc_to_expr_map at Lfor.end%1%d=>E0%0%d
=graph_with_edge_structures.loc_to_expr_map at Lfor.end%1%d=>E0%0%d for loc_id 100067 {input.dst.llvm-%hidden-reg.E0%0%d }
1 : input.dst.llvm-%hidden-reg : BV:32
2 : input.dst.llvm-callee-save.0 : BV:32
3 : bvxor(1, 2) : BV:32
4 : input.dst.llvm-callee-save.1 : BV:32
5 : bvxor(3, 4) : BV:32
6 : input.dst.llvm-callee-save.2 : BV:32
7 : bvxor(5, 6) : BV:32
8 : input.dst.llvm-callee-save.3 : BV:32
9 : bvxor(7, 8) : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.end%1%d=>E0%0%d for loc_id 100068 {input.dst.llvm-%ret-reg.E0%0%d }
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.end%1%d=>E0%0%d for loc_id 100069 {input.dst.llvm-indir_tgt.E0%0%d }
1 : retaddr_const : BV:32
=graph_with_edge_structures.loc_to_expr_map at Lfor.end%1%d=>E0%0%d done
=graph_with_edge_structures.loc_to_expr_map done
=graph_with_edge_structures done
=graph_with_ml_contiguity_info vacuous mls
vacuous mls at L0%0%d:
vacuous mls at Lfor.body%1%intermediateVal1:
vacuous mls at Lfor.body%1%fcallStart:
vacuous mls at Lfor.body%1%fcallEnd:
vacuous mls at Lfor.body%2%d:
vacuous mls at Lfor.cond%1%bbentry:
vacuous mls at Lfor.cond%2%d:
vacuous mls at Lfor.end%1%d:
vacuous mls at E0%0%d:
=graph_with_ml_contiguity_info non-vacuous mls
non-vacuous mls at L0%0%d:
non-vacuous mls at Lfor.body%1%intermediateVal1:
non-vacuous mls at Lfor.body%1%fcallStart:
non-vacuous mls at Lfor.body%1%fcallEnd:
non-vacuous mls at Lfor.body%2%d:
non-vacuous mls at Lfor.cond%1%bbentry:
non-vacuous mls at Lfor.cond%2%d:
non-vacuous mls at Lfor.end%1%d:
non-vacuous mls at E0%0%d:
=graph_with_ml_contiguity_info discontiguous mls
discontiguous mls:
=graph_with_ml_contiguity_info done
=Available expressions in dst.llvm.make_list
=avail_exprs begin
=loc 100006
=loc_expr
140468 : input.dst.llvm-%n : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100008
=loc_expr
140467 : input.dst.llvm-%arr : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100031
=loc_expr
140585 : input.dst.llvm-%hidden-reg : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100033
=loc_expr
140586 : input.dst.llvm-callee-save.0 : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100034
=loc_expr
140588 : input.dst.llvm-callee-save.1 : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100035
=loc_expr
140590 : input.dst.llvm-callee-save.2 : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100036
=loc_expr
140592 : input.dst.llvm-callee-save.3 : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100040
=loc_expr
140476 : input.dst.local_alloc_count.=L0%0%d= : COUNT
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100041
=loc_expr
140471 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100042
=loc_expr
140472 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
=avail_exprs_val.m_is_top 1
=avail_exprs_val.end
=loc 100051
=loc_expr
140766 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=avail_exprs_val.end
=loc 100054
=loc_expr
140763 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
5 : heap_alloc_ptr(2, 4) : BV:32
6 : ite(3, 1, 5) : BV:32
=avail_exprs_val.end
=loc 100063
=loc_expr
140777 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=avail_exprs_val.end
=loc 100065
=loc_expr
140742 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 8 { 0x8 +1.95e129 } : BV:32
=avail_exprs_val.end
=loc 100066
=loc_expr
140812 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 8 { 0x8 +1.95e129 } : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : heap_alloc(5, 6, 3, 1) : ARRAY[BV:32 -> MEMLABEL]
8 : ite(4, 5, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : malloc_side_effect(1, 8, 6) : BV:32
=avail_exprs_val.end
=loc 100067
=loc_expr
140813 : input.dst.llvm-%hidden-reg.E0%0%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%hidden-reg : BV:32
2 : input.dst.llvm-callee-save.0 : BV:32
3 : bvxor(1, 2) : BV:32
4 : input.dst.llvm-callee-save.1 : BV:32
5 : bvxor(3, 4) : BV:32
6 : input.dst.llvm-callee-save.2 : BV:32
7 : bvxor(5, 6) : BV:32
8 : input.dst.llvm-callee-save.3 : BV:32
9 : bvxor(7, 8) : BV:32
=avail_exprs_val.end
=loc 100068
=loc_expr
140814 : input.dst.llvm-%ret-reg.E0%0%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.end
=loc 100069
=loc_expr
140815 : input.dst.llvm-indir_tgt.E0%0%d : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : retaddr_const : BV:32
=avail_exprs_val.end
=loc 100072
=loc_expr
140816 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=avail_exprs_val.end
=loc 100073
=loc_expr
140817 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0 : MEMLABEL
4 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
7 : bvmul(5, 6) : BV:32
8 : bvadd(4, 7) : BV:32
9 : 4 { 0x4 +1.0e1025 } : INT
10 : 0 { 0x0 } : BOOL
11 : select(1, 2, 3, 8, 9, 10) : BV:32
=avail_exprs_val.end
=loc 100074
=loc_expr
140818 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=avail_exprs_val.end
=loc 100075
=loc_expr
140819 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=avail_exprs_val.end
=loc 100076
=loc_expr
140820 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=avail_exprs_val.end
=loc 100077
=loc_expr
140821 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100078
=loc_expr
140822 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
=avail_exprs_val.end
=loc 100079
=loc_expr
140823 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=avail_exprs_val.end
=loc 100080
=loc_expr
140824 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100081
=loc_expr
140825 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
=avail_exprs_val.end
=loc 100082
=loc_expr
140826 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=avail_exprs_val.end
=loc 100083
=loc_expr
140827 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100084
=loc_expr
140828 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100085
=loc_expr
140829 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=avail_exprs_val.end
=loc 100086
=loc_expr
140830 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100087
=loc_expr
140831 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 0 { 0x0 +1.0e129 } : BV:32
=avail_exprs_val.end
=loc 100088
=loc_expr
140832 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=avail_exprs_val.end
=loc 100089
=loc_expr
140833 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=avail_exprs_val.end
=loc 100090
=loc_expr
140834 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=avail_exprs_val.end
=loc 100091
=loc_expr
140835 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=avail_exprs_val.end
=loc 100092
=loc_expr
140836 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=avail_exprs_val.end
=loc 100095
=loc_expr
140837 : input.dst.cur_rounding_mode.Lfor.cond%1%bbentry : ROUNDING_MODE
=avail_exprs_val.m_is_top 0
=avail_exprs_val.m_expr
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=avail_exprs_val.end
=avail_exprs end
=sprel_map in dst.llvm.make_list
=loc 100065 expr
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=loc 100065 spreled-expr
140485 : 8 { 0x8 +1.95e129 } : BV:32
=loc 100069 expr
1 : input.dst.llvm-indir_tgt.E0%0%d : BV:32
=loc 100069 spreled-expr
140267 : retaddr_const : BV:32
=loc 100077 expr
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=loc 100077 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100078 expr
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=loc 100078 spreled-expr
140438 : 4 { 0x4 +1.47e129 } : BV:32
=loc 100080 expr
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=loc 100080 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100081 expr
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=loc 100081 spreled-expr
140438 : 4 { 0x4 +1.47e129 } : BV:32
=loc 100083 expr
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=loc 100083 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100084 expr
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=loc 100084 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100086 expr
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=loc 100086 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100087 expr
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=loc 100087 spreled-expr
140276 : 0 { 0x0 +1.0e129 } : BV:32
=loc 100095 expr
1 : input.dst.cur_rounding_mode.Lfor.cond%1%bbentry : ROUNDING_MODE
=loc 100095 spreled-expr
140477 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=sprel_map done
=lr-status-map
=lr-status-map at call-context {*;make_list}
=loc_id 100006 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=loc_id 100008 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100031 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100033 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100034 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100035 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100036 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100040 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100041 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100042 lr-status in lr-status-map at call-context {*;make_list}
lr_status_top
=loc_id 100044 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100045 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100046 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100047 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100048 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100049 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100050 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100051 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100052 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100053 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(; )
=loc_id 100054 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100055 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100056 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100057 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100058 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100059 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100060 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100061 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100062 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100063 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=loc_id 100064 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=loc_id 100065 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100066 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100067 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100068 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100069 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100070 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100071 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100072 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100073 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100074 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100075 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100076 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100077 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100078 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100079 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100080 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100081 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100082 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100083 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100084 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100085 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100086 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100087 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100088 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100089 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100090 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100091 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100092 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=loc_id 100093 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100094 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100095 lr-status in lr-status-map at call-context {*;make_list}
lr_status_linearly_related(; )
=loc_id 100096 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100097 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100098 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100099 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100100 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100101 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100102 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100103 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100104 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100105 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100106 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100107 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100108 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100109 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100110 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100111 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100112 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100113 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100114 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100115 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=loc_id 100116 lr-status in lr-status-map at call-context {*;make_list}
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=lr-status-map done
=lr-status-for-sprel-locs-map
=loc_id 100065 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100069 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100077 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100078 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100080 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100081 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100083 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100084 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100086 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100087 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=loc_id 100095 lr-status in lr-status-for-sprel-locs-map
lr_status_linearly_related(; )
=lr-status-for-sprel-locs-map done
=graph_with_aliasing_done
=Memlabel assertions empty
=Memlabel assertions done
=graph_with_proofs done
=graph_with_ce done
=graph_with_points done
=graph_with_guessing done
=graph_with_simplified_assets
=graph_with_simplified_assets.simplified_edgecond at L0%0%d=>Lfor.cond%1%bbentry
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.body%1%intermediateVal1=>Lfor.body%2%d
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.body%2%d=>Lfor.cond%1%bbentry
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.cond%1%bbentry=>Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.cond%2%d=>Lfor.body%1%fcallStart
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.cond%2%d=>Lfor.end%1%d
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
2 : not(1) : BOOL
=graph_with_simplified_assets.simplified_edgecond at Lfor.end%1%d=>E0%0%d
1 : 1 { 0x1 } : BOOL
=graph_with_simplified_assets.simplified_edgecond done
=graph_with_simplified_assets.simplified_to_state at L0%0%d=>Lfor.cond%1%bbentry
=dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=dst.llvm-%arr.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr : BV:32
=dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%n.Lfor.cond%1%bbentry
1 : input.dst.llvm-%n : BV:32
=dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-mem.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.cond%1%bbentry
1 : input.dst.local_alloc_count.=L0%0%d= : COUNT
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=dst.llvm-%arr.Lfor.body%2%d
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%call.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
5 : heap_alloc_ptr(2, 4) : BV:32
6 : ite(3, 1, 5) : BV:32
=dst.llvm-%i.0.Lfor.body%2%d
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%l.0.Lfor.body%2%d
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-%n.Lfor.body%2%d
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 3, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : ite(4, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
10 : malloc_side_effect(1, 9, 6) : BV:32
=dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
4 : eq(2, 3) : BOOL
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : heap_alloc(5, 6, 3, 1) : ARRAY[BV:32 -> MEMLABEL]
8 : ite(4, 5, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : malloc_side_effect(1, 8, 6) : BV:32
=dst.llvm-mem.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
5 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
6 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : heap_alloc(5, 6, 2, 7) : ARRAY[BV:32 -> MEMLABEL]
9 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
10 : store_uninit(4, 8, 6, 2, 7, 9) : ARRAY[BV:32 -> BV:8]
11 : ite(3, 4, 10) : ARRAY[BV:32 -> BV:8]
12 : ite(3, 5, 8) : ARRAY[BV:32 -> MEMLABEL]
13 : malloc_side_effect(11, 12, 6) : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
6 : 8 { 0x8 +1.95e129 } : BV:32
7 : heap_alloc(4, 5, 2, 6) : ARRAY[BV:32 -> MEMLABEL]
8 : ite(3, 4, 7) : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.body%2%d
1 : input.dst.local_alloc_count.Lfor.cond%1%bbentry : COUNT
2 : increment_count(1) : COUNT
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=dst.llvm-%call.Lfor.body%1%fcallEnd
1 : func.calla4bcb626de6152719ca44f8b649b9c4a.reg : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
2 : memlabel-mem- : MEMLABEL
3 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : nextpc_const.1 : BV:32
6 : 1000 { 0x3e8 +1.11920e129 } : REGID
7 : 8 { 0x8 +1.95e129 } : BV:32
8 : function_call(1, 2, 2, 3, 4, 5, 6, 7) : BV:32
=dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=dst.llvm-mem.Lfor.body%1%fcallEnd
1 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.body%2%d=>Lfor.cond%1%bbentry
=dst.llvm-%arr.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=dst.llvm-%n.Lfor.cond%1%bbentry
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-mem.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
5 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0 : MEMLABEL
6 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
7 : 4 { 0x4 +1.47e129 } : BV:32
8 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
9 : bvmul(7, 8) : BV:32
10 : bvadd(6, 9) : BV:32
11 : 4 { 0x4 +1.0e1025 } : INT
12 : 0 { 0x0 } : BOOL
13 : select(1, 2, 5, 10, 11, 12) : BV:32
14 : store(1, 2, 3, 4, 13, 11, 12) : ARRAY[BV:32 -> BV:8]
15 : bvadd(7, 4) : BV:32
16 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
17 : store(14, 2, 3, 15, 16, 11, 12) : ARRAY[BV:32 -> BV:8]
=dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
=dst.local_alloc_count.Lfor.cond%1%bbentry
1 : input.dst.local_alloc_count.Lfor.body%2%d : COUNT
=dst.llvm-%0.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%1.Lfor.cond%1%bbentry
1 : input.dst.llvm-mem.Lfor.body%2%d : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc.Lfor.body%2%d : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-no-straddle-symbol.1-hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/-heap-arg.0 : MEMLABEL
4 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
7 : bvmul(5, 6) : BV:32
8 : bvadd(4, 7) : BV:32
9 : 4 { 0x4 +1.0e1025 } : INT
10 : 0 { 0x0 } : BOOL
11 : select(1, 2, 3, 8, 9, 10) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvmul(1, 2) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
4 : bvmul(2, 3) : BV:32
5 : bvadd(1, 4) : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=dst.llvm-%next.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
=dst.llvm-%val.Lfor.cond%1%bbentry
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.cond%1%bbentry=>Lfor.cond%2%d
=dst.llvm-%cmp.Lfor.cond%2%d
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.cond%2%d=>Lfor.body%1%fcallStart
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.cond%2%d=>Lfor.end%1%d
=state_end
=graph_with_simplified_assets.simplified_to_state at Lfor.end%1%d=>E0%0%d
=dst.llvm-%hidden-reg.E0%0%d
1 : input.dst.llvm-%hidden-reg : BV:32
2 : input.dst.llvm-callee-save.0 : BV:32
3 : bvxor(1, 2) : BV:32
4 : input.dst.llvm-callee-save.1 : BV:32
5 : bvxor(3, 4) : BV:32
6 : input.dst.llvm-callee-save.2 : BV:32
7 : bvxor(5, 6) : BV:32
8 : input.dst.llvm-callee-save.3 : BV:32
9 : bvxor(7, 8) : BV:32
=dst.llvm-%ret-reg.E0%0%d
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=dst.llvm-indir_tgt.E0%0%d
1 : retaddr_const : BV:32
=state_end
=graph_with_simplified_assets.simplified_to_state done
=graph_with_simplified_assets.simplified_assumes at L0%0%d=>Lfor.cond%1%bbentry
=graph_with_simplified_assets.simplified_assumes at L0%0%d=>Lfor.cond%1%bbentry assume# 0
1 : input.dst.llvm-%arr : BV:32
2 : 4 { 0x4 +1.0e1025 } : INT
3 : islangaligned(1, 2) : BOOL
=graph_with_simplified_assets.simplified_assumes at L0%0%d=>Lfor.cond%1%bbentry done
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume# 0
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
5 : 8 { 0x8 +1.95e129 } : BV:32
6 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
7 : region_agrees_with_memlabel(4, 2, 5, 6) : BOOL
8 : or(3, 7) : BOOL
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume# 1
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 } : BOOL
5 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
6 : heap_alloc_ptr(2, 5) : BV:32
7 : 7 { 0x7 +1.83e129 } : BV:32
8 : bvadd(7, 6) : BV:32
9 : bvule(6, 8) : BOOL
10 : or(4, 9) : BOOL
11 : or(3, 10) : BOOL
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%intermediateVal1=>Lfor.body%2%d done
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd done
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 assume# 0
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : islangaligned(1, 2) : BOOL
=graph_with_simplified_assets.simplified_assumes at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 done
=graph_with_simplified_assets.simplified_assumes at Lfor.body%2%d=>Lfor.cond%1%bbentry
=graph_with_simplified_assets.simplified_assumes at Lfor.body%2%d=>Lfor.cond%1%bbentry assume# 0
1 : 1 { 0x1 } : BOOL
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : isgepoffset(2, 3) : BOOL
5 : and(1, 4) : BOOL
6 : 4 { 0x4 +1.0e1025 } : BV:64
7 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
8 : 32 { 0x20 +1.0e1025 } : INT
9 : bvsign_ext(7, 8) : BV:64
10 : bvmul(6, 9) : BV:64
11 : 63 { 0x3f +1.0e1025 } : INT
12 : bvextract(10, 11, 8) : BV:32
13 : bvslt(7, 3) : BOOL
14 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
15 : ite(13, 14, 3) : BV:32
16 : eq(12, 15) : BOOL
17 : 4 { 0x4 +1.0e1025 } : INT
18 : isindexforsize(16, 17) : BOOL
19 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 7) : BV:32
22 : bvadd(19, 21) : BV:32
23 : isgepoffset(22, 21) : BOOL
24 : and(18, 23) : BOOL
25 : islangaligned(22, 17) : BOOL
26 : and(24, 25, 4, 5) : BOOL
27 : islangaligned(2, 17) : BOOL
28 : bvadd(20, 2) : BV:32
29 : isgepoffset(28, 20) : BOOL
30 : and(5, 26, 27, 29) : BOOL
=graph_with_simplified_assets.simplified_assumes at Lfor.body%2%d=>Lfor.cond%1%bbentry assume# 1
1 : 4 { 0x4 +1.47e129 } : BV:32
2 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
3 : bvadd(1, 2) : BV:32
4 : 4 { 0x4 +1.0e1025 } : INT
5 : islangaligned(3, 4) : BOOL
=graph_with_simplified_assets.simplified_assumes at Lfor.body%2%d=>Lfor.cond%1%bbentry done
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%1%bbentry=>Lfor.cond%2%d
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%1%bbentry=>Lfor.cond%2%d done
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%2%d=>Lfor.body%1%fcallStart
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%2%d=>Lfor.body%1%fcallStart done
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%2%d=>Lfor.end%1%d
=graph_with_simplified_assets.simplified_assumes at Lfor.cond%2%d=>Lfor.end%1%d done
=graph_with_simplified_assets.simplified_assumes at Lfor.end%1%d=>E0%0%d
=graph_with_simplified_assets.simplified_assumes at Lfor.end%1%d=>E0%0%d done
=graph_with_simplified_assets.simplified_assumes done
=graph_with_simplified_assets done
=max-memlabel-varnum
5
=String-contents:
=Nextpc-map:
C_NEXTPC1 : malloc
=Nextpc-map done
=suffixpaths for dst.llvm.make_list
=suffixpath_at_L0%0%d for dst.llvm.make_list
=suffixpath_at_L0%0%d.graph_edge_composition
(epsilon)
=suffixpath_at_Lfor.body%1%intermediateVal1 for dst.llvm.make_list
=suffixpath_at_Lfor.body%1%intermediateVal1.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*((Lfor.cond%2%d=>Lfor.body%1%fcallStart)*((Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd)*(Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1)))))
=suffixpath_at_Lfor.body%1%fcallStart for dst.llvm.make_list
=suffixpath_at_Lfor.body%1%fcallStart.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*(Lfor.cond%2%d=>Lfor.body%1%fcallStart)))
=suffixpath_at_Lfor.body%1%fcallEnd for dst.llvm.make_list
=suffixpath_at_Lfor.body%1%fcallEnd.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*((Lfor.cond%2%d=>Lfor.body%1%fcallStart)*(Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd))))
=suffixpath_at_Lfor.body%2%d for dst.llvm.make_list
=suffixpath_at_Lfor.body%2%d.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*((Lfor.cond%2%d=>Lfor.body%1%fcallStart)*((Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd)*((Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1)*(Lfor.body%1%intermediateVal1=>Lfor.body%2%d))))))
=suffixpath_at_Lfor.cond%1%bbentry for dst.llvm.make_list
=suffixpath_at_Lfor.cond%1%bbentry.graph_edge_composition
(L0%0%d=>Lfor.cond%1%bbentry)
=suffixpath_at_Lfor.cond%2%d for dst.llvm.make_list
=suffixpath_at_Lfor.cond%2%d.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*(Lfor.cond%1%bbentry=>Lfor.cond%2%d))
=suffixpath_at_Lfor.end%1%d for dst.llvm.make_list
=suffixpath_at_Lfor.end%1%d.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*(Lfor.cond%2%d=>Lfor.end%1%d)))
=suffixpath_at_E0%0%d for dst.llvm.make_list
=suffixpath_at_E0%0%d.graph_edge_composition
((L0%0%d=>Lfor.cond%1%bbentry)*((Lfor.cond%1%bbentry=>Lfor.cond%2%d)*((Lfor.cond%2%d=>Lfor.end%1%d)*(Lfor.end%1%d=>E0%0%d))))
=suffixpaths for dst.llvm.make_list done
=tfg.assumes_around_edge
tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry
tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry assume #0
tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry assume #0.ec
tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry assume #0.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry assume #0.pred
=Comment
undef-behaviour-align-assume.edge.L0%0%d=>Lfor.cond%1%bbentry
=LhsExpr
140467 : input.dst.llvm-%arr : BV:32
140441 : 4 { 0x4 +1.0e1025 } : INT
140478 : islangaligned(140467, 140441) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at L0%0%d=>Lfor.cond%1%bbentry done
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #0
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #0.ec
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #0.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #0.pred
=Comment
undef-behavioursome.edge.Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140909 : eq(140276, 140719) : BOOL
140720 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
140485 : 8 { 0x8 +1.95e129 } : BV:32
140473 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
141263 : region_agrees_with_memlabel(140720, 140719, 140485, 140473) : BOOL
141269 : or(140909, 141263) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #1
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #1.ec
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #1.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d assume #1.pred
=Comment
undef-behavioursome.edge.Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140909 : eq(140276, 140719) : BOOL
140442 : 0 { 0x0 } : BOOL
140498 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
140727 : heap_alloc_ptr(140719, 140498) : BV:32
140658 : 7 { 0x7 +1.83e129 } : BV:32
140950 : bvadd(140658, 140727) : BV:32
140953 : bvule(140727, 140950) : BOOL
140956 : or(140442, 140953) : BOOL
140960 : or(140909, 140956) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at Lfor.body%1%intermediateVal1=>Lfor.body%2%d done
tfg.assumes_around_edge at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
tfg.assumes_around_edge at Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd done
tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 assume #0
tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 assume #0.ec
tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 assume #0.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 assume #0.pred
=Comment
undef-behaviour-align-assume.edge.Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
=LhsExpr
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140287 : 1 { 0x1 +1.0e1025 } : INT
140756 : islangaligned(140719, 140287) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1 done
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #0
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #0.ec
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #0.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #0.pred
=Comment
undef-behavioursome.edge.Lfor.body%2%d=>Lfor.cond%1%bbentry
=LhsExpr
140275 : 1 { 0x1 } : BOOL
140763 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
140276 : 0 { 0x0 +1.0e129 } : BV:32
141136 : isgepoffset(140763, 140276) : BOOL
141147 : and(140275, 141136) : BOOL
140663 : 4 { 0x4 +1.0e1025 } : BV:64
140767 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
140530 : 32 { 0x20 +1.0e1025 } : INT
140787 : bvsign_ext(140767, 140530) : BV:64
141108 : bvmul(140663, 140787) : BV:64
140534 : 63 { 0x3f +1.0e1025 } : INT
141109 : bvextract(141108, 140534, 140530) : BV:32
140784 : bvslt(140767, 140276) : BOOL
140516 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
141122 : ite(140784, 140516, 140276) : BV:32
141124 : eq(141109, 141122) : BOOL
140441 : 4 { 0x4 +1.0e1025 } : INT
141126 : isindexforsize(141124, 140441) : BOOL
140766 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
140438 : 4 { 0x4 +1.47e129 } : BV:32
141079 : bvmul(140438, 140767) : BV:32
141083 : bvadd(140766, 141079) : BV:32
141128 : isgepoffset(141083, 141079) : BOOL
141130 : and(141126, 141128) : BOOL
141132 : islangaligned(141083, 140441) : BOOL
141153 : and(141130, 141132, 141136, 141147) : BOOL
141155 : islangaligned(140763, 140441) : BOOL
141086 : bvadd(140438, 140763) : BV:32
141161 : isgepoffset(141086, 140438) : BOOL
141169 : and(141147, 141153, 141155, 141161) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #1
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #1.ec
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #1.ec.graph_edge_composition
(epsilon)
tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry assume #1.pred
=Comment
undef-behaviour-align-assume.edge.Lfor.body%2%d=>Lfor.cond%1%bbentry
=LhsExpr
140438 : 4 { 0x4 +1.47e129 } : BV:32
140763 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
141086 : bvadd(140438, 140763) : BV:32
140441 : 4 { 0x4 +1.0e1025 } : INT
141100 : islangaligned(141086, 140441) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

tfg.assumes_around_edge at Lfor.body%2%d=>Lfor.cond%1%bbentry done
tfg.assumes_around_edge at Lfor.cond%1%bbentry=>Lfor.cond%2%d
tfg.assumes_around_edge at Lfor.cond%1%bbentry=>Lfor.cond%2%d done
tfg.assumes_around_edge at Lfor.cond%2%d=>Lfor.body%1%fcallStart
tfg.assumes_around_edge at Lfor.cond%2%d=>Lfor.body%1%fcallStart done
tfg.assumes_around_edge at Lfor.cond%2%d=>Lfor.end%1%d
tfg.assumes_around_edge at Lfor.cond%2%d=>Lfor.end%1%d done
tfg.assumes_around_edge at Lfor.end%1%d=>E0%0%d
tfg.assumes_around_edge at Lfor.end%1%d=>E0%0%d done
tfg.assumes_around_edge done
=TFGdone
=PC_to_linename:
=pc
Lentry%1%d
=linename
line 8
=pc
Lfor.body%1%d
=linename
line 9
=pc
Lfor.body%2%d
=linename
line 9
=pc
Lfor.body%3%d
=linename
line 10
=pc
Lfor.body%4%d
=linename
line 10
=pc
Lfor.body%5%d
=linename
line 10
=pc
Lfor.body%6%d
=linename
line 10
=pc
Lfor.body%7%d
=linename
line 11
=pc
Lfor.body%8%d
=linename
line 11
=pc
Lfor.body%9%d
=linename
line 13
=pc
Lfor.cond%1%d
=linename
line 8
=pc
Lfor.cond%2%d
=linename
line 8
=pc
Lfor.end%1%d
=linename
line 14
=pc
Lfor.inc%1%d
=linename
line 8
=pc
Lfor.inc%2%d
=linename
line 8
=PC_to_linename done
=PC_to_column_name:
=pc
Lentry%1%d
=column_name
 at column 8
=pc
Lfor.body%1%d
=column_name
 at column 18
=pc
Lfor.body%2%d
=column_name
 at column 18
=pc
Lfor.body%3%d
=column_name
 at column 17
=pc
Lfor.body%4%d
=column_name
 at column 17
=pc
Lfor.body%5%d
=column_name
 at column 11
=pc
Lfor.body%6%d
=column_name
 at column 15
=pc
Lfor.body%7%d
=column_name
 at column 11
=pc
Lfor.body%8%d
=column_name
 at column 16
=pc
Lfor.body%9%d
=column_name
 at column 3
=pc
Lfor.cond%1%d
=column_name
 at column 26
=pc
Lfor.cond%2%d
=column_name
 at column 3
=pc
Lfor.end%1%d
=column_name
 at column 3
=pc
Lfor.inc%1%d
=column_name
 at column 31
=pc
Lfor.inc%2%d
=column_name
 at column 3
=PC_to_column_name done
=PC_to_line_and_column:
=pc
Lentry%1%d
=line_and_column
(line 8 at column 8)
=pc
Lfor.body%1%d
=line_and_column
line 9
=pc
Lfor.body%2%d
=line_and_column
line 9
=pc
Lfor.body%3%d
=line_and_column
(line 10 at column 17)
=pc
Lfor.body%4%d
=line_and_column
(line 10 at column 17)
=pc
Lfor.body%5%d
=line_and_column
(line 10 at column 11)
=pc
Lfor.body%6%d
=line_and_column
(line 10 at column 15)
=pc
Lfor.body%7%d
=line_and_column
(line 11 at column 11)
=pc
Lfor.body%8%d
=line_and_column
(line 11 at column 16)
=pc
Lfor.body%9%d
=line_and_column
line 13
=pc
Lfor.cond%1%d
=line_and_column
(line 8 at column 26)
=pc
Lfor.cond%2%d
=line_and_column
(line 8 at column 3)
=pc
Lfor.end%1%d
=line_and_column
line 14
=pc
Lfor.inc%1%d
=line_and_column
(line 8 at column 31)
=pc
Lfor.inc%2%d
=line_and_column
(line 8 at column 3)
=PC_to_line_and_column done
=SourceToLLVMVarnames:
=SourceToLLVMVarnames done
=InputLLVMToSourceVarnames:
input.dst.llvm-%arr : L0%0%d : arr'
input.dst.llvm-%n : L0%0%d : n'
input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : L0%0%d : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : L0%0%d : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
input.dst.llvm-%l.0 : Lfor.cond%1%bbentry : l'
input.dst.local_alloc_count.=L0%0%d= : L0%0%d : input.dst.local_alloc_count.=L0%0%d=
input.dst.llvm-%i.0 : Lfor.cond%1%bbentry : i'
input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset : L0%0%d : bvmul(input.dst.llvm-%i.0, 4)
input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset : L0%0%d : (arr' + input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset)
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset : L0%0%d : 0
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset : L0%0%d : 0
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset : L0%0%d : input.dst.llvm-%0
input.dst.llvm-%1 : L0%0%d : DSTMEM[input.dst.llvm-%arrayidx]_4
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset : L0%0%d : 0
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset : L0%0%d : 4
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset : L0%0%d : (4 + input.dst.llvm-%0)
input.dst.llvm-%inc : Lfor.inc%2%bbentry : i'
input.dst.llvm-%hidden-reg : L0%0%d : input.dst.llvm-%hidden-reg
input.dst.llvm-callee-save.0 : L0%0%d : input.dst.llvm-callee-save.0
input.dst.llvm-callee-save.1 : L0%0%d : input.dst.llvm-callee-save.1
input.dst.llvm-callee-save.2 : L0%0%d : input.dst.llvm-callee-save.2
input.dst.llvm-callee-save.3 : L0%0%d : input.dst.llvm-callee-save.3
input.dst.llvm-%0 : Lfor.body%3%bbentry : node'
input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset : L0%0%d : bvmul(input.dst.llvm-%i.0, 4)
input.dst.llvm-%arrayidx : L0%0%d : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset : L0%0%d : 0
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset : L0%0%d : 0
input.dst.llvm-%val : L0%0%d : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset : L0%0%d : 0
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset : L0%0%d : 4
input.dst.llvm-%next : L0%0%d : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset
input.dst.llvm-%l.0.phi.tmpvar.for.inc : L0%0%d : input.dst.llvm-%0
input.dst.llvm-%i.0.phi.tmpvar.for.inc : L0%0%d : input.dst.llvm-%inc
input.dst.llvm-%ret-reg : L0%0%d : input.dst.llvm-%l.0
input.dst.llvm-indir_tgt : L0%0%d : return-address
input.dst.cur_rounding_mode : L0%0%d : ROUND_to_nearest_ties_to_even
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : L0%0%d : 8
input.dst.llvm-%arr.Lfor.body%2%d : L0%0%d : malloc_side_effect(input.dst.llvm-%arr.Lfor.cond%1%bbentry, ite(input.dst.llvm-%call.Lfor.body%1%fcallEnd = 0, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, heap_alloc(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, input.dst.llvm-%call.Lfor.body%1%fcallEnd, 8)), memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/)
input.dst.llvm-%n.Lfor.body%2%d : L0%0%d : malloc_side_effect(input.dst.llvm-%n.Lfor.cond%1%bbentry, ite(input.dst.llvm-%call.Lfor.body%1%fcallEnd = 0, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, heap_alloc(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, input.dst.llvm-%call.Lfor.body%1%fcallEnd, 8)), memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/)
input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : L0%0%d : (1 + input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%call.Lfor.body%2%d : L0%0%d : ite(input.dst.llvm-%call.Lfor.body%1%fcallEnd = 0, 0, heap_alloc_ptr(input.dst.llvm-%call.Lfor.body%1%fcallEnd, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/))
input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : L0%0%d : bvmul(4, input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : L0%0%d : 4
input.dst.llvm-indir_tgt.E0%0%d : L0%0%d : return-address
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : L0%0%d : (4 + input.dst.llvm-%call.Lfor.body%2%d)
input.dst.llvm-%ret-reg.E0%0%d : L0%0%d : input.dst.llvm-%l.0.Lfor.cond%1%bbentry
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : L0%0%d : malloc_side_effect(8, ite(input.dst.llvm-%call.Lfor.body%1%fcallEnd = 0, input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, heap_alloc(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, input.dst.llvm-%call.Lfor.body%1%fcallEnd, 8)), memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/)
input.dst.llvm-%hidden-reg.E0%0%d : L0%0%d : bvxor(bvxor(bvxor(bvxor(input.dst.llvm-%hidden-reg, input.dst.llvm-callee-save.0), input.dst.llvm-callee-save.1), input.dst.llvm-callee-save.2), input.dst.llvm-callee-save.3)
input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : L0%0%d : 4
input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : L0%0%d : (input.dst.llvm-%arr.Lfor.body%2%d + 4*input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%0.Lfor.cond%1%bbentry : L0%0%d : input.dst.llvm-%call.Lfor.body%2%d
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-%1.Lfor.cond%1%bbentry : L0%0%d : input.dst.llvm-mem.Lfor.body%2%d[(input.dst.llvm-%arr.Lfor.body%2%d + 4*input.dst.llvm-%i.0.Lfor.body%2%d)]_4
input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : L0%0%d : bvmul(4, input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : L0%0%d : (input.dst.llvm-%arr.Lfor.body%2%d + 4*input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : L0%0%d : input.dst.llvm-%call.Lfor.body%2%d
input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : L0%0%d : 0
input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : L0%0%d : input.dst.llvm-%call.Lfor.body%2%d
input.dst.llvm-%inc.Lfor.cond%1%bbentry : L0%0%d : (1 + input.dst.llvm-%i.0.Lfor.body%2%d)
input.dst.llvm-%next.Lfor.cond%1%bbentry : L0%0%d : (4 + input.dst.llvm-%call.Lfor.body%2%d)
input.dst.llvm-%val.Lfor.cond%1%bbentry : L0%0%d : input.dst.llvm-%call.Lfor.body%2%d
input.dst.cur_rounding_mode.Lfor.cond%1%bbentry : L0%0%d : ROUND_to_nearest_ties_to_even
=InputLLVMToSourceVarnames done
=PotentialSCEVRelations:
=dst.llvm-%i.0
=dst.llvm-%i.0 loop pc: Lfor.cond%1%d
=dst.llvm-%i.0 val_scevb
=dst.llvm-%i.0 val_scevb scev
=dst.llvm-%i.0 val_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%i.0 val_scevb scev scev_overflow_flag: 
=dst.llvm-%i.0 val_scevb scev scev_expr
1 : 00000000000000000000000000000000b
2 : 00000000000000000000000000000001b
3 : scev_op_addrec(1, 2) : loop Lfor.cond%1%d : 
=dst.llvm-%i.0 val_scevb scev scev_expr done
=dst.llvm-%i.0 val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%i.0 val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%i.0 val_scevb signed lower bound: 32:4294967295
=dst.llvm-%i.0 val_scevb signed upper bound: 32:4294967295
=dst.llvm-%i.0 atuse_scevb
=dst.llvm-%i.0 atuse_scevb scev
=dst.llvm-%i.0 atuse_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%i.0 atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%i.0 atuse_scevb scev scev_expr
1 : 00000000000000000000000000000000b
2 : 00000000000000000000000000000001b
3 : scev_op_addrec(1, 2) : loop Lfor.cond%1%d : 
=dst.llvm-%i.0 atuse_scevb scev scev_expr done
=dst.llvm-%i.0 atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%i.0 atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%i.0 atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%i.0 atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%i.0 atexit_scev
=dst.llvm-%i.0 atexit_scev loop: L0%0%d
=dst.llvm-%i.0 atexit_scev scev_overflow_flag: 
=dst.llvm-%i.0 atexit_scev scev_expr
4 : input.dst.llvm-%n : BV32
=dst.llvm-%i.0 atexit_scev scev_expr done
=dst.llvm-%l.0
=dst.llvm-%l.0 loop pc: Lfor.cond%1%d
=dst.llvm-%l.0 val_scevb
=dst.llvm-%l.0 val_scevb scev
=dst.llvm-%l.0 val_scevb scev loop: L0%0%d
=dst.llvm-%l.0 val_scevb scev scev_overflow_flag: 
=dst.llvm-%l.0 val_scevb scev scev_expr
5 : input.dst.llvm-%l.0 : BV32
=dst.llvm-%l.0 val_scevb scev scev_expr done
=dst.llvm-%l.0 val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%l.0 val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%l.0 val_scevb signed lower bound: 32:4294967295
=dst.llvm-%l.0 val_scevb signed upper bound: 32:4294967295
=dst.llvm-%l.0 atuse_scevb
=dst.llvm-%l.0 atuse_scevb scev
=dst.llvm-%l.0 atuse_scevb scev loop: L0%0%d
=dst.llvm-%l.0 atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%l.0 atuse_scevb scev scev_expr
5 : input.dst.llvm-%l.0 : BV32
=dst.llvm-%l.0 atuse_scevb scev scev_expr done
=dst.llvm-%l.0 atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%l.0 atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%l.0 atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%l.0 atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%l.0 atexit_scev
=dst.llvm-%l.0 atexit_scev loop: L0%0%d
=dst.llvm-%l.0 atexit_scev scev_overflow_flag: 
=dst.llvm-%l.0 atexit_scev scev_expr
5 : input.dst.llvm-%l.0 : BV32
=dst.llvm-%l.0 atexit_scev scev_expr done
=dst.llvm-%call
=dst.llvm-%call loop pc: Lfor.cond%1%d
=dst.llvm-%call val_scevb
=dst.llvm-%call val_scevb scev
=dst.llvm-%call val_scevb scev loop: L0%0%d
=dst.llvm-%call val_scevb scev scev_overflow_flag: 
=dst.llvm-%call val_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%call val_scevb scev scev_expr done
=dst.llvm-%call val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%call val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%call val_scevb signed lower bound: 32:4294967295
=dst.llvm-%call val_scevb signed upper bound: 32:4294967295
=dst.llvm-%call atuse_scevb
=dst.llvm-%call atuse_scevb scev
=dst.llvm-%call atuse_scevb scev loop: L0%0%d
=dst.llvm-%call atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%call atuse_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%call atuse_scevb scev scev_expr done
=dst.llvm-%call atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%call atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%call atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%call atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%call atexit_scev
=dst.llvm-%call atexit_scev loop: L0%0%d
=dst.llvm-%call atexit_scev scev_overflow_flag: 
=dst.llvm-%call atexit_scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%call atexit_scev scev_expr done
=dst.llvm-%0
=dst.llvm-%0 loop pc: Lfor.cond%1%d
=dst.llvm-%0 val_scevb
=dst.llvm-%0 val_scevb scev
=dst.llvm-%0 val_scevb scev loop: L0%0%d
=dst.llvm-%0 val_scevb scev scev_overflow_flag: 
=dst.llvm-%0 val_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%0 val_scevb scev scev_expr done
=dst.llvm-%0 val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%0 val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%0 val_scevb signed lower bound: 32:4294967295
=dst.llvm-%0 val_scevb signed upper bound: 32:4294967295
=dst.llvm-%0 atuse_scevb
=dst.llvm-%0 atuse_scevb scev
=dst.llvm-%0 atuse_scevb scev loop: L0%0%d
=dst.llvm-%0 atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%0 atuse_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%0 atuse_scevb scev scev_expr done
=dst.llvm-%0 atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%0 atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%0 atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%0 atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%0 atexit_scev
=dst.llvm-%0 atexit_scev loop: L0%0%d
=dst.llvm-%0 atexit_scev scev_overflow_flag: 
=dst.llvm-%0 atexit_scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%0 atexit_scev scev_expr done
=dst.llvm-%arrayidx
=dst.llvm-%arrayidx loop pc: Lfor.cond%1%d
=dst.llvm-%arrayidx val_scevb
=dst.llvm-%arrayidx val_scevb scev
=dst.llvm-%arrayidx val_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%arrayidx val_scevb scev scev_overflow_flag: 
=dst.llvm-%arrayidx val_scevb scev scev_expr
7 : input.dst.llvm-%arr : BV32
8 : 00000000000000000000000000000100b
9 : scev_op_addrec(7, 8) : loop Lfor.cond%1%d : 
=dst.llvm-%arrayidx val_scevb scev scev_expr done
=dst.llvm-%arrayidx val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%arrayidx val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%arrayidx val_scevb signed lower bound: 32:4294967295
=dst.llvm-%arrayidx val_scevb signed upper bound: 32:4294967295
=dst.llvm-%arrayidx atuse_scevb
=dst.llvm-%arrayidx atuse_scevb scev
=dst.llvm-%arrayidx atuse_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%arrayidx atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%arrayidx atuse_scevb scev scev_expr
7 : input.dst.llvm-%arr : BV32
8 : 00000000000000000000000000000100b
9 : scev_op_addrec(7, 8) : loop Lfor.cond%1%d : 
=dst.llvm-%arrayidx atuse_scevb scev scev_expr done
=dst.llvm-%arrayidx atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%arrayidx atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%arrayidx atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%arrayidx atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%arrayidx atexit_scev
=dst.llvm-%arrayidx atexit_scev loop: L0%0%d
=dst.llvm-%arrayidx atexit_scev scev_overflow_flag: 
=dst.llvm-%arrayidx atexit_scev scev_expr
8 : 00000000000000000000000000000100b
4 : input.dst.llvm-%n : BV32
10 : scev_op_mul(8, 4) : loop L0%0%d : 
7 : input.dst.llvm-%arr : BV32
11 : scev_op_add(10, 7) : loop L0%0%d : 
=dst.llvm-%arrayidx atexit_scev scev_expr done
=dst.llvm-%1
=dst.llvm-%1 loop pc: Lfor.cond%1%d
=dst.llvm-%1 val_scevb
=dst.llvm-%1 val_scevb scev
=dst.llvm-%1 val_scevb scev loop: L0%0%d
=dst.llvm-%1 val_scevb scev scev_overflow_flag: 
=dst.llvm-%1 val_scevb scev scev_expr
12 : input.dst.llvm-%1 : BV32
=dst.llvm-%1 val_scevb scev scev_expr done
=dst.llvm-%1 val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%1 val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%1 val_scevb signed lower bound: 32:4294967295
=dst.llvm-%1 val_scevb signed upper bound: 32:4294967295
=dst.llvm-%1 atuse_scevb
=dst.llvm-%1 atuse_scevb scev
=dst.llvm-%1 atuse_scevb scev loop: L0%0%d
=dst.llvm-%1 atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%1 atuse_scevb scev scev_expr
12 : input.dst.llvm-%1 : BV32
=dst.llvm-%1 atuse_scevb scev scev_expr done
=dst.llvm-%1 atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%1 atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%1 atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%1 atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%1 atexit_scev
=dst.llvm-%1 atexit_scev loop: L0%0%d
=dst.llvm-%1 atexit_scev scev_overflow_flag: 
=dst.llvm-%1 atexit_scev scev_expr
12 : input.dst.llvm-%1 : BV32
=dst.llvm-%1 atexit_scev scev_expr done
=dst.llvm-%val
=dst.llvm-%val loop pc: Lfor.cond%1%d
=dst.llvm-%val val_scevb
=dst.llvm-%val val_scevb scev
=dst.llvm-%val val_scevb scev loop: L0%0%d
=dst.llvm-%val val_scevb scev scev_overflow_flag: 
=dst.llvm-%val val_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%val val_scevb scev scev_expr done
=dst.llvm-%val val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%val val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%val val_scevb signed lower bound: 32:4294967295
=dst.llvm-%val val_scevb signed upper bound: 32:4294967295
=dst.llvm-%val atuse_scevb
=dst.llvm-%val atuse_scevb scev
=dst.llvm-%val atuse_scevb scev loop: L0%0%d
=dst.llvm-%val atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%val atuse_scevb scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%val atuse_scevb scev scev_expr done
=dst.llvm-%val atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%val atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%val atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%val atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%val atexit_scev
=dst.llvm-%val atexit_scev loop: L0%0%d
=dst.llvm-%val atexit_scev scev_overflow_flag: 
=dst.llvm-%val atexit_scev scev_expr
6 : input.dst.llvm-%call : BV32
=dst.llvm-%val atexit_scev scev_expr done
=dst.llvm-%next
=dst.llvm-%next loop pc: Lfor.cond%1%d
=dst.llvm-%next val_scevb
=dst.llvm-%next val_scevb scev
=dst.llvm-%next val_scevb scev loop: L0%0%d
=dst.llvm-%next val_scevb scev scev_overflow_flag: nsw
=dst.llvm-%next val_scevb scev scev_expr
8 : 00000000000000000000000000000100b
6 : input.dst.llvm-%call : BV32
13 : scev_op_add(8, 6) : loop L0%0%d : nsw
=dst.llvm-%next val_scevb scev scev_expr done
=dst.llvm-%next val_scevb unsigned lower bound: 32:2147483652
=dst.llvm-%next val_scevb unsigned upper bound: 32:2147483648
=dst.llvm-%next val_scevb signed lower bound: 32:2147483652
=dst.llvm-%next val_scevb signed upper bound: 32:2147483648
=dst.llvm-%next atuse_scevb
=dst.llvm-%next atuse_scevb scev
=dst.llvm-%next atuse_scevb scev loop: L0%0%d
=dst.llvm-%next atuse_scevb scev scev_overflow_flag: nsw
=dst.llvm-%next atuse_scevb scev scev_expr
8 : 00000000000000000000000000000100b
6 : input.dst.llvm-%call : BV32
13 : scev_op_add(8, 6) : loop L0%0%d : nsw
=dst.llvm-%next atuse_scevb scev scev_expr done
=dst.llvm-%next atuse_scevb unsigned lower bound: 32:2147483652
=dst.llvm-%next atuse_scevb unsigned upper bound: 32:2147483648
=dst.llvm-%next atuse_scevb signed lower bound: 32:2147483652
=dst.llvm-%next atuse_scevb signed upper bound: 32:2147483648
=dst.llvm-%next atexit_scev
=dst.llvm-%next atexit_scev loop: L0%0%d
=dst.llvm-%next atexit_scev scev_overflow_flag: nsw
=dst.llvm-%next atexit_scev scev_expr
8 : 00000000000000000000000000000100b
6 : input.dst.llvm-%call : BV32
13 : scev_op_add(8, 6) : loop L0%0%d : nsw
=dst.llvm-%next atexit_scev scev_expr done
=dst.llvm-%inc
=dst.llvm-%inc loop pc: Lfor.cond%1%d
=dst.llvm-%inc val_scevb
=dst.llvm-%inc val_scevb scev
=dst.llvm-%inc val_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%inc val_scevb scev scev_overflow_flag: 
=dst.llvm-%inc val_scevb scev scev_expr
2 : 00000000000000000000000000000001b
14 : scev_op_addrec(2, 2) : loop Lfor.cond%1%d : 
=dst.llvm-%inc val_scevb scev scev_expr done
=dst.llvm-%inc val_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%inc val_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%inc val_scevb signed lower bound: 32:4294967295
=dst.llvm-%inc val_scevb signed upper bound: 32:4294967295
=dst.llvm-%inc atuse_scevb
=dst.llvm-%inc atuse_scevb scev
=dst.llvm-%inc atuse_scevb scev loop: Lfor.cond%1%d
=dst.llvm-%inc atuse_scevb scev scev_overflow_flag: 
=dst.llvm-%inc atuse_scevb scev scev_expr
2 : 00000000000000000000000000000001b
14 : scev_op_addrec(2, 2) : loop Lfor.cond%1%d : 
=dst.llvm-%inc atuse_scevb scev scev_expr done
=dst.llvm-%inc atuse_scevb unsigned lower bound: 32:4294967295
=dst.llvm-%inc atuse_scevb unsigned upper bound: 32:4294967295
=dst.llvm-%inc atuse_scevb signed lower bound: 32:4294967295
=dst.llvm-%inc atuse_scevb signed upper bound: 32:4294967295
=dst.llvm-%inc atexit_scev
=dst.llvm-%inc atexit_scev loop: L0%0%d
=dst.llvm-%inc atexit_scev scev_overflow_flag: 
=dst.llvm-%inc atexit_scev scev_expr
2 : 00000000000000000000000000000001b
4 : input.dst.llvm-%n : BV32
15 : scev_op_add(2, 4) : loop L0%0%d : 
=dst.llvm-%inc atexit_scev scev_expr done
=PotentialSCEVRelations done
=ReachingDefinitionsForLocs:
=Reaching Definitions at L0%0%d
=reaching defns for expr 0
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 1 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 2 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 3 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 4 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 5 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 8 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 8 edges done
=reaching defns done
=Reaching Definitions at Lfor.body%1%intermediateVal1
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 4 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 5 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 8 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 9 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 11 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 12 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 13 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 14 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 15 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 16 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.body%1%fcallStart
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 4 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 5 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 8 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 9 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 11 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 12 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 13 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 14 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 15 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 16 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.body%1%fcallEnd
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 4 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 5 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 8 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 9 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 11 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 12 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 13 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 14 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 15 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 16 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.body%2%d
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 4 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 5 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 8 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 9 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 11 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 12 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 13 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 14 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 15 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 16 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.cond%1%bbentry
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 4 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 5 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 8 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 9 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 11 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 12 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 13 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 14 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 15 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 16 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.cond%2%d
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 4 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 5 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 8 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 9 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 11 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 12 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 13 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 14 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 15 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 16 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at Lfor.end%1%d
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 4 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 5 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 8 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 9 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 11 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 12 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 13 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 14 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 15 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 16 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 27 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 28 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 29 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns done
=Reaching Definitions at E0%0%d
=reaching defns for expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 0 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 0 edges done
=reaching defns for expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 1 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 1 edges done
=reaching defns for expr 2
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 2 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 2 edges done
=reaching defns for expr 3
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 3 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 3 edges done
=reaching defns for expr 4
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 4 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 4 edges done
=reaching defns for expr 5
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 5 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 5 edges done
=reaching defns for expr 6
1 : input.dst.llvm-%arr : BV:32
=reaching defns for expr 6 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 6 edges done
=reaching defns for expr 7
1 : input.dst.llvm-%n : BV:32
=reaching defns for expr 7 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 7 edges done
=reaching defns for expr 8
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 8 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 8 edges done
=reaching defns for expr 9
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd : BV:32
=reaching defns for expr 9 edges
  Lfor.body%1%fcallStart=>Lfor.body%1%fcallEnd
=reaching defns for expr 9 edges done
=reaching defns for expr 10
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 10 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 10 edges done
=reaching defns for expr 11
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.0 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 11 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 11 edges done
=reaching defns for expr 12
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 12 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 12 edges done
=reaching defns for expr 13
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 13 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 13 edges done
=reaching defns for expr 14
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 14 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 14 edges done
=reaching defns for expr 15
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 15 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 15 edges done
=reaching defns for expr 16
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--arg.1 : MEMLABEL
4 : memmask(1, 2, 3) : ARRAY[BV:32 -> BV:8]
=reaching defns for expr 16 edges
  L0%0%d=>L0%0%d
=reaching defns for expr 16 edges done
=reaching defns for expr 17
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=reaching defns for expr 17 edges
  Lfor.cond%1%bbentry=>Lfor.cond%2%d
=reaching defns for expr 17 edges done
=reaching defns for expr 18
1 : input.dst.llvm-%call.Lfor.body%2%d : BV:32
=reaching defns for expr 18 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 18 edges done
=reaching defns for expr 19
1 : input.dst.llvm-%arr.Lfor.body%2%d : BV:32
=reaching defns for expr 19 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 19 edges done
=reaching defns for expr 20
1 : input.dst.llvm-%i.0.Lfor.body%2%d : BV:32
=reaching defns for expr 20 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 20 edges done
=reaching defns for expr 21
1 : input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 21 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 21 edges done
=reaching defns for expr 22
1 : input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d : BV:32
=reaching defns for expr 22 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 22 edges done
=reaching defns for expr 23
1 : input.dst.llvm-%n.Lfor.body%2%d : BV:32
=reaching defns for expr 23 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 23 edges done
=reaching defns for expr 24
1 : input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 24 edges
  L0%0%d=>Lfor.cond%1%bbentry
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 24 edges done
=reaching defns for expr 25
1 : input.dst.llvm-%l.0.Lfor.body%2%d : BV:32
=reaching defns for expr 25 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 25 edges done
=reaching defns for expr 26
1 : input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d : BV:32
=reaching defns for expr 26 edges
  Lfor.body%1%intermediateVal1=>Lfor.body%2%d
=reaching defns for expr 26 edges done
=reaching defns for expr 27
1 : input.dst.llvm-%hidden-reg.E0%0%d : BV:32
=reaching defns for expr 27 edges
  Lfor.end%1%d=>E0%0%d
=reaching defns for expr 27 edges done
=reaching defns for expr 28
1 : input.dst.llvm-%ret-reg.E0%0%d : BV:32
=reaching defns for expr 28 edges
  Lfor.end%1%d=>E0%0%d
=reaching defns for expr 28 edges done
=reaching defns for expr 29
1 : input.dst.llvm-indir_tgt.E0%0%d : BV:32
=reaching defns for expr 29 edges
  Lfor.end%1%d=>E0%0%d
=reaching defns for expr 29 edges done
=reaching defns for expr 30
1 : input.dst.llvm-%0.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 30 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 30 edges done
=reaching defns for expr 31
1 : input.dst.llvm-%1.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 31 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 31 edges done
=reaching defns for expr 32
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 32 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 32 edges done
=reaching defns for expr 33
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 33 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 33 edges done
=reaching defns for expr 34
1 : input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 34 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 34 edges done
=reaching defns for expr 35
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 35 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 35 edges done
=reaching defns for expr 36
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 36 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 36 edges done
=reaching defns for expr 37
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 37 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 37 edges done
=reaching defns for expr 38
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 38 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 38 edges done
=reaching defns for expr 39
1 : input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 39 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 39 edges done
=reaching defns for expr 40
1 : input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 40 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 40 edges done
=reaching defns for expr 41
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 41 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 41 edges done
=reaching defns for expr 42
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 42 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 42 edges done
=reaching defns for expr 43
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 43 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 43 edges done
=reaching defns for expr 44
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 44 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 44 edges done
=reaching defns for expr 45
1 : input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 45 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 45 edges done
=reaching defns for expr 46
1 : input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 46 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 46 edges done
=reaching defns for expr 47
1 : input.dst.llvm-%inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 47 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 47 edges done
=reaching defns for expr 48
1 : input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 48 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 48 edges done
=reaching defns for expr 49
1 : input.dst.llvm-%next.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 49 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 49 edges done
=reaching defns for expr 50
1 : input.dst.llvm-%val.Lfor.cond%1%bbentry : BV:32
=reaching defns for expr 50 edges
  Lfor.body%2%d=>Lfor.cond%1%bbentry
=reaching defns for expr 50 edges done
=reaching defns done
=ReachingDefinitionsForLocs done
=VarnameToLRStatus Begin:
=LR status for var input.dst.llvm-%n.Lfor.cond%1%bbentry
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=LR status for var input.dst.llvm-%arr
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%n
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=LR status for var input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
lr_status_top
=LR status for var input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
lr_status_top
=LR status for var input.dst.local_alloc_count.=L0%0%d=
lr_status_top
=LR status for var input.dst.llvm-%arr.Lfor.cond%1%bbentry
lr_status_bottom(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%hidden-reg
lr_status_top
=LR status for var input.dst.llvm-callee-save.0
lr_status_top
=LR status for var input.dst.llvm-callee-save.1
lr_status_top
=LR status for var input.dst.llvm-callee-save.2
lr_status_top
=LR status for var input.dst.llvm-callee-save.3
lr_status_top
=LR status for var input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%cmp.Lfor.cond%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.local_alloc_count.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%i.0.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%l.0.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%call.Lfor.body%1%fcallEnd
lr_status_bottom(; )
=LR status for var input.dst.llvm-%arr.Lfor.body%2%d
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%n.Lfor.body%2%d
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem-may-straddle-symbol.1-heap, memlabel-mem--arg.1, )
=LR status for var input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.local_alloc_count.Lfor.body%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%i.0.Lfor.body%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%l.0.Lfor.body%2%d
lr_status_linearly_related(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%call.Lfor.body%2%d
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-indir_tgt.E0%0%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%ret-reg.E0%0%d
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%hidden-reg.E0%0%d
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%0.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%1.Lfor.cond%1%bbentry
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, local./*___y___make_list__x__=L0%0%argnum1=/, local./*___y___make_list__x__=L0%0%argnum0=/, ; memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
lr_status_bottom(hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; memlabel-mem--arg.0, memlabel-mem-may-straddle-symbol.1-heap, )
=LR status for var input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%inc.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=LR status for var input.dst.llvm-%next.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.llvm-%val.Lfor.cond%1%bbentry
lr_status_linearly_related(hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ; )
=LR status for var input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
lr_status_linearly_related(; )
=VarnameToLRStatus End
=TFG_LLVM_done
=TFG_SSA_done
=eqcheck_info
=eqcheck
=proof_filename ind9.proof
=function_name make_list
=asm_filename NONE
=fixed_reg_mappings begin
0 : 0 : 0
0 : 4 : 4
=fixed_reg_mappings end
=rodata_map begin
=rodata_map end
=dst_iseq
=dst_iseq done
=dst_insn_pcs
=dst_insn_pcs done
=xml_output_format text-color
=use_only_relocatable_memlabels 0
=run_safety_check 0
=debug_header_pc_lsprels
=Local offsets from compile log
=Local offsets from compile log done
=done
=spec_iospecs
=SpecFuncIOSpecs
=FunctionName: make_list
=EntryPreconds
=pred 0
=Comment
pointer-implements-map
=LhsExpr
1 : $spec-arg-0 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : $llvm-arg-1 : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : $llvm-md : ARRAY[BV:32 -> BV:8]
11 : $llvm-ma : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : $llvm-arg-0 : BV:32
14 : 4 { 0x4 +1.47e129 } : BV:32
15 : bvmul(9, 14) : BV:32
16 : bvadd(13, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=predicate_set done
=EntryPreconds done
=ExitAsserts
=pred 0
=Comment
ret-pointer-implements-inductive-list
=LhsExpr
1 : $spec-ret : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : $llvm-ret : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : $llvm-md : ARRAY[BV:32 -> BV:8]
6 : $llvm-ma : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(14, 15) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=predicate_set done
=ExitAsserts done
=SpecFuncIOSpecs done
=eqcheck done
=graph_with_guessing
=Nodes: L0%0%d_L0%0%d L3%6%bbentry_Lfor.body%1%fcallStart L3%6%bbentry_Lfor.body%1%fcallEnd L3%6%bbentry_Lfor.cond%1%bbentry E0%0%d_E0%0%d
=Edges:
L0%0%d_L0%0%d => L3%6%bbentry_Lfor.cond%1%bbentry
L3%6%bbentry_Lfor.cond%1%bbentry => E0%0%d_E0%0%d
L3%6%bbentry_Lfor.cond%1%bbentry => L3%6%bbentry_Lfor.body%1%fcallStart
L3%6%bbentry_Lfor.body%1%fcallStart => L3%6%bbentry_Lfor.body%1%fcallEnd
L3%6%bbentry_Lfor.body%1%fcallEnd => L3%6%bbentry_Lfor.cond%1%bbentry
=graph done
=is_ssa_graph:
0
=StartState:
=state_end
=graph_with_var_versions done
=FunctionName: make_list
=Input: tfg-method-arg.0
=arg addr
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
=arg val
1 : input.dst.llvm-%arr : BV:32
=arg end
=Input: tfg-method-arg.1
=arg addr
1 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
=arg val
1 : input.dst.llvm-%n : BV:32
=arg end
=Node outputs: E0%0%d_E0%0%d
=Node outputs done for E0%0%d_E0%0%d
=input_outputs done
=Symbol-map:
C_SYMBOL1 : make_list : 26 : 1 : 0
=Touched symbols:
=Symbol-map done
=Locals-map:
C_LOCAL=L0%0%argnum0= : dst.llvm-%arr : 4 : 4 : 0
C_LOCAL=L0%0%argnum1= : dst.llvm-%n : 4 : 4 : 0
=Locals-map done
=Global assumes
=global assume predicate_set done
=Edge: L0%0%d_L0%0%d => L3%6%bbentry_Lfor.cond%1%bbentry
=Edge.src_tfg_full_pathset
=Edge.src_tfg_full_pathset.ec from L0%0%d to L3%6%bbentry at unroll 1 delta {1,0}
=Edge.src_tfg_full_pathset.graph_edge_composition
(L0%0%d#{0,0}=>L3%6%bbentry#{0,0})
=Edge.src_tfg_full_pathset done
=Edge.dst_tfg_full_pathset
=Edge.dst_tfg_full_pathset.ec from L0%0%d to Lfor.cond%1%bbentry at unroll 1 delta {1,0}
=Edge.dst_tfg_full_pathset.graph_edge_composition
(L0%0%d#{0,0}=>Lfor.cond%1%bbentry#{0,0})
=Edge.dst_tfg_full_pathset done
=Edge.cg_edge_assumes.Assumes.begin:
=Edge.cg_edge_assumes.Assumes.end

=Edge: L3%6%bbentry_Lfor.cond%1%bbentry => E0%0%d_E0%0%d
=Edge.src_tfg_full_pathset
=Edge.src_tfg_full_pathset.ec from L3%6%bbentry to E0%0%d at unroll 1 delta {1,0}
=Edge.src_tfg_full_pathset.graph_edge_composition
((L3%6%bbentry#{0,0}=>L3%7%d#{0,0})*((L3%7%d#{0,0}=>L3%8%bbentry#{0,0})*(L3%8%bbentry#{0,0}=>E0%0%d#{0,0})))
=Edge.src_tfg_full_pathset done
=Edge.dst_tfg_full_pathset
=Edge.dst_tfg_full_pathset.ec from Lfor.cond%1%bbentry to E0%0%d at unroll 1 delta {1,0}
=Edge.dst_tfg_full_pathset.graph_edge_composition
((Lfor.cond%1%bbentry#{0,0}=>Lfor.cond%2%d#{0,0})*((Lfor.cond%2%d#{0,0}=>Lfor.end%1%d#{0,0})*(Lfor.end%1%d#{0,0}=>E0%0%d#{0,0})))
=Edge.dst_tfg_full_pathset done
=Edge.cg_edge_assumes.Assumes.begin:
=Edge.cg_edge_assumes.Assumes.end

=Edge: L3%6%bbentry_Lfor.cond%1%bbentry => L3%6%bbentry_Lfor.body%1%fcallStart
=Edge.src_tfg_full_pathset
=Edge.src_tfg_full_pathset.ec from L3%6%bbentry to L3%6%bbentry at unroll 0 delta {0,0}
=Edge.src_tfg_full_pathset.graph_edge_composition
(epsilon)
=Edge.src_tfg_full_pathset done
=Edge.dst_tfg_full_pathset
=Edge.dst_tfg_full_pathset.ec from Lfor.cond%1%bbentry to Lfor.body%1%fcallStart at unroll 1 delta {1,0}
=Edge.dst_tfg_full_pathset.graph_edge_composition
((Lfor.cond%1%bbentry#{0,0}=>Lfor.cond%2%d#{0,0})*(Lfor.cond%2%d#{0,0}=>Lfor.body%1%fcallStart#{0,0}))
=Edge.dst_tfg_full_pathset done
=Edge.cg_edge_assumes.Assumes.begin:
=Edge.cg_edge_assumes.Assumes.end

=Edge: L3%6%bbentry_Lfor.body%1%fcallStart => L3%6%bbentry_Lfor.body%1%fcallEnd
=Edge.src_tfg_full_pathset
=Edge.src_tfg_full_pathset.ec from L3%6%bbentry to L3%6%bbentry at unroll 0 delta {0,0}
=Edge.src_tfg_full_pathset.graph_edge_composition
(epsilon)
=Edge.src_tfg_full_pathset done
=Edge.dst_tfg_full_pathset
=Edge.dst_tfg_full_pathset.ec from Lfor.body%1%fcallStart to Lfor.body%1%fcallEnd at unroll 1 delta {1,0}
=Edge.dst_tfg_full_pathset.graph_edge_composition
(Lfor.body%1%fcallStart#{0,0}=>Lfor.body%1%fcallEnd#{0,0})
=Edge.dst_tfg_full_pathset done
=Edge.cg_edge_assumes.Assumes.begin:
=Edge.cg_edge_assumes.Assumes.end

=Edge: L3%6%bbentry_Lfor.body%1%fcallEnd => L3%6%bbentry_Lfor.cond%1%bbentry
=Edge.src_tfg_full_pathset
=Edge.src_tfg_full_pathset.ec from L3%6%bbentry to L3%6%bbentry at unroll 1 delta {1,0}
=Edge.src_tfg_full_pathset.graph_edge_composition
((L3%6%bbentry#{0,0}=>L3%7%d#{0,0})*((L3%7%d#{0,0}=>L3%10%bbentry#{0,0})*(L3%10%bbentry#{0,0}=>L3%6%bbentry#{1,0})))
=Edge.src_tfg_full_pathset done
=Edge.dst_tfg_full_pathset
=Edge.dst_tfg_full_pathset.ec from Lfor.body%1%fcallEnd to Lfor.cond%1%bbentry at unroll 1 delta {1,0}
=Edge.dst_tfg_full_pathset.graph_edge_composition
((Lfor.body%1%fcallEnd#{0,0}=>Lfor.body%1%intermediateVal1#{0,0})*((Lfor.body%1%intermediateVal1#{0,0}=>Lfor.body%2%d#{0,0})*(Lfor.body%2%d#{0,0}=>Lfor.cond%1%bbentry#{0,0})))
=Edge.dst_tfg_full_pathset done
=Edge.cg_edge_assumes.Assumes.begin:
=Edge.cg_edge_assumes.Assumes.end

=graph_with_predicates_done

=start_pc_preconditions
=start_pc_precondition.0
=Comment
precond-mlasserts
=LhsExpr
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=start_pc_precondition.1
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
4 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
5 : 4 { 0x4 +1.0e1025 } : INT
6 : 0 { 0x0 } : BOOL
7 : select(1, 2, 3, 4, 5, 6) : BV:32
=RhsExpr
1 : input.dst.llvm-%n : BV:32
=predicate done
=start_pc_precondition.2
=Comment
pointer-implements-map
=LhsExpr
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=start_pc_precondition.3
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
1 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
2 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
3 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
4 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
5 : 4 { 0x4 +1.0e1025 } : INT
6 : 0 { 0x0 } : BOOL
7 : select(1, 2, 3, 4, 5, 6) : BV:32
=RhsExpr
1 : input.dst.llvm-%arr : BV:32
=predicate done
=graph_with_precondition_done

=Locs in make_list.A2.B1.C1.D1.E2
=Locs end
=Liveness in make_list.A2.B1.C1.D1.E2
=live locs at L0%0%d_L0%0%d

=live locs at L3%6%bbentry_Lfor.body%1%fcallStart

=live locs at L3%6%bbentry_Lfor.body%1%fcallEnd

=live locs at L3%6%bbentry_Lfor.cond%1%bbentry

=live locs at E0%0%d_E0%0%d


=Definedness in make_list.A2.B1.C1.D1.E2

=Branch affecting variable locs in make_list.A2.B1.C1.D1.E2

=Relevant Memlabels in make_list.A2.B1.C1.D1.E2
=relevant memlabels
=function: make_list
memlabel-mem--arg.0
memlabel-mem-may-straddle-symbol.1-heap
memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/
memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/
memlabel-mem--arg.1
=touched symbol ids

=relevant memlabels done
=graph_with_locs_done
=graph_with_edge_structures
=graph_with_edge_structures.loc_to_expr_map done
=graph_with_edge_structures done
=graph_with_ml_contiguity_info vacuous mls
=graph_with_ml_contiguity_info non-vacuous mls
=graph_with_ml_contiguity_info discontiguous mls
discontiguous mls:
=graph_with_ml_contiguity_info done
=Available expressions in make_list.A2.B1.C1.D1.E2
=avail_exprs begin
=avail_exprs end
=sprel_map in make_list.A2.B1.C1.D1.E2
=sprel_map done
=lr-status-map
=lr-status-map done
=lr-status-for-sprel-locs-map
=lr-status-for-sprel-locs-map done
=graph_with_aliasing_done
=Memlabel assertions empty
=Memlabel assertions done
=graph_with_proofs done
=global counterexamples for reason inductive-invariants
=global nodece 0
=global nodece 0 nodece z3.ce5.num_edges_traversed1
=global nodece 0 nodece_path
=global nodece 0 nodece_path.graph_edge_composition
(L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 0 nodece_cached_counterexample
=counter_example_begin z3.ce5 6b5a984e24af7398fafc16f07cbceb1e
=input.spec-%var-arr-1
1 : Lambda93 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda94 : BV:32
11 : 3 { 0x3 +1.35e129 } : BV:32
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(12, 10) : BV:32
14 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
15 : bvadd(11, 13, 14) : BV:32
16 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
17 : eq(15, 16) : BOOL
18 : 0 { 0x0 } : BV:8
19 : 1256949363 { 0x4aeb8673 +1.84004056e22 } : BV:32
20 : eq(15, 19) : BOOL
21 : 170 { 0xaa -86 } : BV:8
22 : 1728446693 { 0x670600e5 +1.4690229e79 } : BV:32
23 : eq(15, 22) : BOOL
24 : 1256949361 { 0x4aeb8671 +1.84004032e22 } : BV:32
25 : eq(15, 24) : BOOL
26 : 53 { 0x35 } : BV:8
27 : 1256949362 { 0x4aeb8672 +1.84004044e22 } : BV:32
28 : eq(15, 27) : BOOL
29 : 117 { 0x75 } : BV:8
30 : 1728446694 { 0x670600e6 +1.4690241e79 } : BV:32
31 : eq(15, 30) : BOOL
32 : 1728446695 { 0x670600e7 +1.4690253e79 } : BV:32
33 : eq(15, 32) : BOOL
34 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
35 : eq(15, 34) : BOOL
36 : 244 { 0xf4 -12 } : BV:8
37 : 5 { 0x5 } : BV:8
38 : ite(35, 36, 37) : BV:8
39 : ite(33, 18, 38) : BV:8
40 : ite(31, 18, 39) : BV:8
41 : ite(28, 29, 40) : BV:8
42 : ite(25, 26, 41) : BV:8
43 : ite(23, 18, 42) : BV:8
44 : ite(20, 21, 43) : BV:8
45 : ite(17, 18, 44) : BV:8
46 : 2 { 0x2 +1.23e129 } : BV:32
47 : bvadd(46, 13, 14) : BV:32
48 : eq(47, 16) : BOOL
49 : eq(47, 19) : BOOL
50 : eq(47, 22) : BOOL
51 : eq(47, 24) : BOOL
52 : eq(47, 27) : BOOL
53 : eq(47, 30) : BOOL
54 : eq(47, 32) : BOOL
55 : eq(47, 34) : BOOL
56 : ite(55, 36, 37) : BV:8
57 : ite(54, 18, 56) : BV:8
58 : ite(53, 18, 57) : BV:8
59 : ite(52, 29, 58) : BV:8
60 : ite(51, 26, 59) : BV:8
61 : ite(50, 18, 60) : BV:8
62 : ite(49, 21, 61) : BV:8
63 : ite(48, 18, 62) : BV:8
64 : 1 { 0x1 +1.11e129 } : BV:32
65 : bvadd(64, 13, 14) : BV:32
66 : eq(65, 16) : BOOL
67 : eq(65, 19) : BOOL
68 : eq(65, 22) : BOOL
69 : eq(65, 24) : BOOL
70 : eq(65, 27) : BOOL
71 : eq(65, 30) : BOOL
72 : eq(65, 32) : BOOL
73 : eq(65, 34) : BOOL
74 : ite(73, 36, 37) : BV:8
75 : ite(72, 18, 74) : BV:8
76 : ite(71, 18, 75) : BV:8
77 : ite(70, 29, 76) : BV:8
78 : ite(69, 26, 77) : BV:8
79 : ite(68, 18, 78) : BV:8
80 : ite(67, 21, 79) : BV:8
81 : ite(66, 18, 80) : BV:8
82 : bvadd(13, 14) : BV:32
83 : eq(82, 16) : BOOL
84 : eq(82, 19) : BOOL
85 : eq(82, 22) : BOOL
86 : eq(82, 24) : BOOL
87 : eq(82, 27) : BOOL
88 : eq(82, 30) : BOOL
89 : eq(82, 32) : BOOL
90 : eq(82, 34) : BOOL
91 : ite(90, 36, 37) : BV:8
92 : ite(89, 18, 91) : BV:8
93 : ite(88, 18, 92) : BV:8
94 : ite(87, 29, 93) : BV:8
95 : ite(86, 26, 94) : BV:8
96 : ite(85, 18, 95) : BV:8
97 : ite(84, 21, 96) : BV:8
98 : ite(83, 18, 97) : BV:8
99 : bvconcat(45, 63, 81, 98) : BV:32
100 : lambda(10, 99) : FUNCTION[BV:32 -> BV:32]
101 : map(9, 100) : MAP[BV:32 -> BV:32]
102 : sym_const(101) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda93 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda94 : BV:32
11 : 3 { 0x3 +1.35e129 } : BV:32
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(12, 10) : BV:32
14 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
15 : bvadd(11, 13, 14) : BV:32
16 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
17 : eq(15, 16) : BOOL
18 : 0 { 0x0 } : BV:8
19 : 1256949363 { 0x4aeb8673 +1.84004056e22 } : BV:32
20 : eq(15, 19) : BOOL
21 : 170 { 0xaa -86 } : BV:8
22 : 1728446693 { 0x670600e5 +1.4690229e79 } : BV:32
23 : eq(15, 22) : BOOL
24 : 1256949361 { 0x4aeb8671 +1.84004032e22 } : BV:32
25 : eq(15, 24) : BOOL
26 : 53 { 0x35 } : BV:8
27 : 1256949362 { 0x4aeb8672 +1.84004044e22 } : BV:32
28 : eq(15, 27) : BOOL
29 : 117 { 0x75 } : BV:8
30 : 1728446694 { 0x670600e6 +1.4690241e79 } : BV:32
31 : eq(15, 30) : BOOL
32 : 1728446695 { 0x670600e7 +1.4690253e79 } : BV:32
33 : eq(15, 32) : BOOL
34 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
35 : eq(15, 34) : BOOL
36 : 244 { 0xf4 -12 } : BV:8
37 : 5 { 0x5 } : BV:8
38 : ite(35, 36, 37) : BV:8
39 : ite(33, 18, 38) : BV:8
40 : ite(31, 18, 39) : BV:8
41 : ite(28, 29, 40) : BV:8
42 : ite(25, 26, 41) : BV:8
43 : ite(23, 18, 42) : BV:8
44 : ite(20, 21, 43) : BV:8
45 : ite(17, 18, 44) : BV:8
46 : 2 { 0x2 +1.23e129 } : BV:32
47 : bvadd(46, 13, 14) : BV:32
48 : eq(47, 16) : BOOL
49 : eq(47, 19) : BOOL
50 : eq(47, 22) : BOOL
51 : eq(47, 24) : BOOL
52 : eq(47, 27) : BOOL
53 : eq(47, 30) : BOOL
54 : eq(47, 32) : BOOL
55 : eq(47, 34) : BOOL
56 : ite(55, 36, 37) : BV:8
57 : ite(54, 18, 56) : BV:8
58 : ite(53, 18, 57) : BV:8
59 : ite(52, 29, 58) : BV:8
60 : ite(51, 26, 59) : BV:8
61 : ite(50, 18, 60) : BV:8
62 : ite(49, 21, 61) : BV:8
63 : ite(48, 18, 62) : BV:8
64 : 1 { 0x1 +1.11e129 } : BV:32
65 : bvadd(64, 13, 14) : BV:32
66 : eq(65, 16) : BOOL
67 : eq(65, 19) : BOOL
68 : eq(65, 22) : BOOL
69 : eq(65, 24) : BOOL
70 : eq(65, 27) : BOOL
71 : eq(65, 30) : BOOL
72 : eq(65, 32) : BOOL
73 : eq(65, 34) : BOOL
74 : ite(73, 36, 37) : BV:8
75 : ite(72, 18, 74) : BV:8
76 : ite(71, 18, 75) : BV:8
77 : ite(70, 29, 76) : BV:8
78 : ite(69, 26, 77) : BV:8
79 : ite(68, 18, 78) : BV:8
80 : ite(67, 21, 79) : BV:8
81 : ite(66, 18, 80) : BV:8
82 : bvadd(13, 14) : BV:32
83 : eq(82, 16) : BOOL
84 : eq(82, 19) : BOOL
85 : eq(82, 22) : BOOL
86 : eq(82, 24) : BOOL
87 : eq(82, 27) : BOOL
88 : eq(82, 30) : BOOL
89 : eq(82, 32) : BOOL
90 : eq(82, 34) : BOOL
91 : ite(90, 36, 37) : BV:8
92 : ite(89, 18, 91) : BV:8
93 : ite(88, 18, 92) : BV:8
94 : ite(87, 29, 93) : BV:8
95 : ite(86, 26, 94) : BV:8
96 : ite(85, 18, 95) : BV:8
97 : ite(84, 21, 96) : BV:8
98 : ite(83, 18, 97) : BV:8
99 : bvconcat(45, 63, 81, 98) : BV:32
100 : lambda(10, 99) : FUNCTION[BV:32 -> BV:32]
101 : map(9, 100) : MAP[BV:32 -> BV:32]
102 : sym_const(101) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda73 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
8 : eq(6, 7) : BOOL
9 : 0 { 0x0 } : BV:8
10 : 1256949363 { 0x4aeb8673 +1.84004056e22 } : BV:32
11 : eq(6, 10) : BOOL
12 : 170 { 0xaa -86 } : BV:8
13 : 1728446693 { 0x670600e5 +1.4690229e79 } : BV:32
14 : eq(6, 13) : BOOL
15 : 1256949361 { 0x4aeb8671 +1.84004032e22 } : BV:32
16 : eq(6, 15) : BOOL
17 : 53 { 0x35 } : BV:8
18 : 1256949362 { 0x4aeb8672 +1.84004044e22 } : BV:32
19 : eq(6, 18) : BOOL
20 : 117 { 0x75 } : BV:8
21 : 1728446694 { 0x670600e6 +1.4690241e79 } : BV:32
22 : eq(6, 21) : BOOL
23 : 1728446695 { 0x670600e7 +1.4690253e79 } : BV:32
24 : eq(6, 23) : BOOL
25 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
26 : eq(6, 25) : BOOL
27 : 244 { 0xf4 -12 } : BV:8
28 : 5 { 0x5 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 9, 29) : BV:8
31 : ite(22, 9, 30) : BV:8
32 : ite(19, 20, 31) : BV:8
33 : ite(16, 17, 32) : BV:8
34 : ite(14, 9, 33) : BV:8
35 : ite(11, 12, 34) : BV:8
36 : ite(8, 9, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 4, 5) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 10) : BOOL
41 : eq(38, 13) : BOOL
42 : eq(38, 15) : BOOL
43 : eq(38, 18) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 9, 47) : BV:8
49 : ite(44, 9, 48) : BV:8
50 : ite(43, 20, 49) : BV:8
51 : ite(42, 17, 50) : BV:8
52 : ite(41, 9, 51) : BV:8
53 : ite(40, 12, 52) : BV:8
54 : ite(39, 9, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 4, 5) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 10) : BOOL
59 : eq(56, 13) : BOOL
60 : eq(56, 15) : BOOL
61 : eq(56, 18) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 9, 65) : BV:8
67 : ite(62, 9, 66) : BV:8
68 : ite(61, 20, 67) : BV:8
69 : ite(60, 17, 68) : BV:8
70 : ite(59, 9, 69) : BV:8
71 : ite(58, 12, 70) : BV:8
72 : ite(57, 9, 71) : BV:8
73 : bvadd(4, 5) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 10) : BOOL
76 : eq(73, 13) : BOOL
77 : eq(73, 15) : BOOL
78 : eq(73, 18) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 9, 82) : BV:8
84 : ite(79, 9, 83) : BV:8
85 : ite(78, 20, 84) : BV:8
86 : ite(77, 17, 85) : BV:8
87 : ite(76, 9, 86) : BV:8
88 : ite(75, 12, 87) : BV:8
89 : ite(74, 9, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : lambda(1, 90) : FUNCTION[BV:32 -> BV:32]
92 : sym_const(91) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda74 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
8 : eq(6, 7) : BOOL
9 : 0 { 0x0 } : BV:8
10 : 1256949363 { 0x4aeb8673 +1.84004056e22 } : BV:32
11 : eq(6, 10) : BOOL
12 : 170 { 0xaa -86 } : BV:8
13 : 1728446693 { 0x670600e5 +1.4690229e79 } : BV:32
14 : eq(6, 13) : BOOL
15 : 1256949361 { 0x4aeb8671 +1.84004032e22 } : BV:32
16 : eq(6, 15) : BOOL
17 : 53 { 0x35 } : BV:8
18 : 1256949362 { 0x4aeb8672 +1.84004044e22 } : BV:32
19 : eq(6, 18) : BOOL
20 : 117 { 0x75 } : BV:8
21 : 1728446694 { 0x670600e6 +1.4690241e79 } : BV:32
22 : eq(6, 21) : BOOL
23 : 1728446695 { 0x670600e7 +1.4690253e79 } : BV:32
24 : eq(6, 23) : BOOL
25 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
26 : eq(6, 25) : BOOL
27 : 244 { 0xf4 -12 } : BV:8
28 : 5 { 0x5 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 9, 29) : BV:8
31 : ite(22, 9, 30) : BV:8
32 : ite(19, 20, 31) : BV:8
33 : ite(16, 17, 32) : BV:8
34 : ite(14, 9, 33) : BV:8
35 : ite(11, 12, 34) : BV:8
36 : ite(8, 9, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 4, 5) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 10) : BOOL
41 : eq(38, 13) : BOOL
42 : eq(38, 15) : BOOL
43 : eq(38, 18) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 9, 47) : BV:8
49 : ite(44, 9, 48) : BV:8
50 : ite(43, 20, 49) : BV:8
51 : ite(42, 17, 50) : BV:8
52 : ite(41, 9, 51) : BV:8
53 : ite(40, 12, 52) : BV:8
54 : ite(39, 9, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 4, 5) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 10) : BOOL
59 : eq(56, 13) : BOOL
60 : eq(56, 15) : BOOL
61 : eq(56, 18) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 9, 65) : BV:8
67 : ite(62, 9, 66) : BV:8
68 : ite(61, 20, 67) : BV:8
69 : ite(60, 17, 68) : BV:8
70 : ite(59, 9, 69) : BV:8
71 : ite(58, 12, 70) : BV:8
72 : ite(57, 9, 71) : BV:8
73 : bvadd(4, 5) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 10) : BOOL
76 : eq(73, 13) : BOOL
77 : eq(73, 15) : BOOL
78 : eq(73, 18) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 9, 82) : BV:8
84 : ite(79, 9, 83) : BV:8
85 : ite(78, 20, 84) : BV:8
86 : ite(77, 17, 85) : BV:8
87 : ite(76, 9, 86) : BV:8
88 : ite(75, 12, 87) : BV:8
89 : ite(74, 9, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : lambda(1, 90) : FUNCTION[BV:32 -> BV:32]
92 : sym_const(91) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
=input.dst.llvm-%n
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1256949359 ] -> 5, [ 1256949360; 1256949360 ] -> 244, [ 1256949361; 1256949361 ] -> 53, [ 1256949362; 1256949362 ] -> 117, [ 1256949363; 1256949363 ] -> 170, [ 1256949364; 1728446691 ] -> 5, [ 1728446692; 1728446695 ] -> 0, [ 1728446696; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1256949359 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1256949360; 1256949363 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1256949364; 1728446691 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1728446692; 1728446695 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1728446696; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
=input.dst.local_alloc_count.=L0%0%d=
1 : 19723702 { 0x12cf5b6 +1.35124850e131 } : COUNT
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2859808244 { 0xaa7535f4 -1435159052 -1.91570901e213 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1256949359 ] -> 5, [ 1256949360; 1256949360 ] -> 244, [ 1256949361; 1256949361 ] -> 53, [ 1256949362; 1256949362 ] -> 117, [ 1256949363; 1256949363 ] -> 170, [ 1256949364; 1728446691 ] -> 5, [ 1728446692; 1728446695 ] -> 0, [ 1728446696; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 19723702 { 0x12cf5b6 +1.35124850e131 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1256949359 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1256949360; 1256949363 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1256949364; 1728446691 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1728446692; 1728446695 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1728446696; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1728446692 { 0x670600e4 +1.4690217e79 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1728446695 { 0x670600e7 +1.4690253e79 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1256949360 { 0x4aeb8670 +1.84004020e22 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1256949363 { 0x4aeb8673 +1.84004056e22 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
834052334
=counter_example_end
=global nodece 0 num_edges_traversed 1
=global nodece 0 nodece_visted_pcs: 
L0%0%d_L0%0%d -> L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 1
=global nodece 1 nodece z3v487.ce6.num_edges_traversed0
=global nodece 1 nodece_path
=global nodece 1 nodece_path.graph_edge_composition
(epsilon)
=global nodece 1 nodece_cached_counterexample
=counter_example_begin z3v487.ce6 754d492271b2431e93fb09cf1fdb785
=input.spec-%var-arr-1
1 : Lambda107 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 67372035 { 0x4040403 +1.3137242e137 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 67372036 { 0x4040404 +1.3137254e137 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda108 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : 84215045 { 0x5050505 +1.3921568e139 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : bvule(2, 22) : BOOL
24 : 639 { 0x27f +1.7617e129 } : BV:32
25 : bvule(22, 24) : BOOL
26 : and(23, 25) : BOOL
27 : 1 { 0x1 } : BV:8
28 : 640 { 0x280 +1.7629e129 } : BV:32
29 : bvule(28, 22) : BOOL
30 : 643 { 0x283 +1.7665e129 } : BV:32
31 : bvule(22, 30) : BOOL
32 : and(29, 31) : BOOL
33 : 4 { 0x4 } : BV:8
34 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
35 : bvule(34, 22) : BOOL
36 : 556557207 { 0x212c6397 +1.34678924e195 } : BV:32
37 : bvule(22, 36) : BOOL
38 : and(35, 37) : BOOL
39 : 5 { 0x5 } : BV:8
40 : 556557208 { 0x212c6398 +1.34678936e195 } : BV:32
41 : bvule(40, 22) : BOOL
42 : bvule(22, 10) : BOOL
43 : and(41, 42) : BOOL
44 : 0 { 0x0 } : BV:8
45 : 644 { 0x284 +1.7677e129 } : BV:32
46 : bvule(45, 22) : BOOL
47 : 556557203 { 0x212c6393 +1.34678876e195 } : BV:32
48 : bvule(22, 47) : BOOL
49 : and(46, 48) : BOOL
50 : ite(49, 44, 44) : BV:8
51 : ite(43, 44, 50) : BV:8
52 : ite(38, 39, 51) : BV:8
53 : ite(32, 33, 52) : BV:8
54 : ite(26, 27, 53) : BV:8
55 : 2 { 0x2 +1.23e129 } : BV:32
56 : bvadd(55, 20, 21) : BV:32
57 : bvule(2, 56) : BOOL
58 : bvule(56, 24) : BOOL
59 : and(57, 58) : BOOL
60 : bvule(28, 56) : BOOL
61 : bvule(56, 30) : BOOL
62 : and(60, 61) : BOOL
63 : bvule(34, 56) : BOOL
64 : bvule(56, 36) : BOOL
65 : and(63, 64) : BOOL
66 : bvule(40, 56) : BOOL
67 : bvule(56, 10) : BOOL
68 : and(66, 67) : BOOL
69 : bvule(45, 56) : BOOL
70 : bvule(56, 47) : BOOL
71 : and(69, 70) : BOOL
72 : ite(71, 44, 44) : BV:8
73 : ite(68, 44, 72) : BV:8
74 : ite(65, 39, 73) : BV:8
75 : ite(62, 33, 74) : BV:8
76 : ite(59, 27, 75) : BV:8
77 : 1 { 0x1 +1.11e129 } : BV:32
78 : bvadd(77, 20, 21) : BV:32
79 : bvule(2, 78) : BOOL
80 : bvule(78, 24) : BOOL
81 : and(79, 80) : BOOL
82 : bvule(28, 78) : BOOL
83 : bvule(78, 30) : BOOL
84 : and(82, 83) : BOOL
85 : bvule(34, 78) : BOOL
86 : bvule(78, 36) : BOOL
87 : and(85, 86) : BOOL
88 : bvule(40, 78) : BOOL
89 : bvule(78, 10) : BOOL
90 : and(88, 89) : BOOL
91 : bvule(45, 78) : BOOL
92 : bvule(78, 47) : BOOL
93 : and(91, 92) : BOOL
94 : ite(93, 44, 44) : BV:8
95 : ite(90, 44, 94) : BV:8
96 : ite(87, 39, 95) : BV:8
97 : ite(84, 33, 96) : BV:8
98 : ite(81, 27, 97) : BV:8
99 : bvadd(20, 21) : BV:32
100 : bvule(2, 99) : BOOL
101 : bvule(99, 24) : BOOL
102 : and(100, 101) : BOOL
103 : bvule(28, 99) : BOOL
104 : bvule(99, 30) : BOOL
105 : and(103, 104) : BOOL
106 : bvule(34, 99) : BOOL
107 : bvule(99, 36) : BOOL
108 : and(106, 107) : BOOL
109 : bvule(40, 99) : BOOL
110 : bvule(99, 10) : BOOL
111 : and(109, 110) : BOOL
112 : bvule(45, 99) : BOOL
113 : bvule(99, 47) : BOOL
114 : and(112, 113) : BOOL
115 : ite(114, 44, 44) : BV:8
116 : ite(111, 44, 115) : BV:8
117 : ite(108, 39, 116) : BV:8
118 : ite(105, 33, 117) : BV:8
119 : ite(102, 27, 118) : BV:8
120 : bvconcat(54, 76, 98, 119) : BV:32
121 : lambda(17, 120) : FUNCTION[BV:32 -> BV:32]
122 : map(16, 121) : MAP[BV:32 -> BV:32]
123 : sym_const(122) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda110 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 67372035 { 0x4040403 +1.3137242e137 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 67372036 { 0x4040404 +1.3137254e137 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda111 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : 84215045 { 0x5050505 +1.3921568e139 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : bvule(2, 22) : BOOL
24 : 639 { 0x27f +1.7617e129 } : BV:32
25 : bvule(22, 24) : BOOL
26 : and(23, 25) : BOOL
27 : 1 { 0x1 } : BV:8
28 : 640 { 0x280 +1.7629e129 } : BV:32
29 : bvule(28, 22) : BOOL
30 : 643 { 0x283 +1.7665e129 } : BV:32
31 : bvule(22, 30) : BOOL
32 : and(29, 31) : BOOL
33 : 4 { 0x4 } : BV:8
34 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
35 : bvule(34, 22) : BOOL
36 : 556557207 { 0x212c6397 +1.34678924e195 } : BV:32
37 : bvule(22, 36) : BOOL
38 : and(35, 37) : BOOL
39 : 5 { 0x5 } : BV:8
40 : 556557208 { 0x212c6398 +1.34678936e195 } : BV:32
41 : bvule(40, 22) : BOOL
42 : bvule(22, 10) : BOOL
43 : and(41, 42) : BOOL
44 : 0 { 0x0 } : BV:8
45 : 644 { 0x284 +1.7677e129 } : BV:32
46 : bvule(45, 22) : BOOL
47 : 556557203 { 0x212c6393 +1.34678876e195 } : BV:32
48 : bvule(22, 47) : BOOL
49 : and(46, 48) : BOOL
50 : ite(49, 44, 44) : BV:8
51 : ite(43, 44, 50) : BV:8
52 : ite(38, 39, 51) : BV:8
53 : ite(32, 33, 52) : BV:8
54 : ite(26, 27, 53) : BV:8
55 : 2 { 0x2 +1.23e129 } : BV:32
56 : bvadd(55, 20, 21) : BV:32
57 : bvule(2, 56) : BOOL
58 : bvule(56, 24) : BOOL
59 : and(57, 58) : BOOL
60 : bvule(28, 56) : BOOL
61 : bvule(56, 30) : BOOL
62 : and(60, 61) : BOOL
63 : bvule(34, 56) : BOOL
64 : bvule(56, 36) : BOOL
65 : and(63, 64) : BOOL
66 : bvule(40, 56) : BOOL
67 : bvule(56, 10) : BOOL
68 : and(66, 67) : BOOL
69 : bvule(45, 56) : BOOL
70 : bvule(56, 47) : BOOL
71 : and(69, 70) : BOOL
72 : ite(71, 44, 44) : BV:8
73 : ite(68, 44, 72) : BV:8
74 : ite(65, 39, 73) : BV:8
75 : ite(62, 33, 74) : BV:8
76 : ite(59, 27, 75) : BV:8
77 : 1 { 0x1 +1.11e129 } : BV:32
78 : bvadd(77, 20, 21) : BV:32
79 : bvule(2, 78) : BOOL
80 : bvule(78, 24) : BOOL
81 : and(79, 80) : BOOL
82 : bvule(28, 78) : BOOL
83 : bvule(78, 30) : BOOL
84 : and(82, 83) : BOOL
85 : bvule(34, 78) : BOOL
86 : bvule(78, 36) : BOOL
87 : and(85, 86) : BOOL
88 : bvule(40, 78) : BOOL
89 : bvule(78, 10) : BOOL
90 : and(88, 89) : BOOL
91 : bvule(45, 78) : BOOL
92 : bvule(78, 47) : BOOL
93 : and(91, 92) : BOOL
94 : ite(93, 44, 44) : BV:8
95 : ite(90, 44, 94) : BV:8
96 : ite(87, 39, 95) : BV:8
97 : ite(84, 33, 96) : BV:8
98 : ite(81, 27, 97) : BV:8
99 : bvadd(20, 21) : BV:32
100 : bvule(2, 99) : BOOL
101 : bvule(99, 24) : BOOL
102 : and(100, 101) : BOOL
103 : bvule(28, 99) : BOOL
104 : bvule(99, 30) : BOOL
105 : and(103, 104) : BOOL
106 : bvule(34, 99) : BOOL
107 : bvule(99, 36) : BOOL
108 : and(106, 107) : BOOL
109 : bvule(40, 99) : BOOL
110 : bvule(99, 10) : BOOL
111 : and(109, 110) : BOOL
112 : bvule(45, 99) : BOOL
113 : bvule(99, 47) : BOOL
114 : and(112, 113) : BOOL
115 : ite(114, 44, 44) : BV:8
116 : ite(111, 44, 115) : BV:8
117 : ite(108, 39, 116) : BV:8
118 : ite(105, 33, 117) : BV:8
119 : ite(102, 27, 118) : BV:8
120 : bvconcat(54, 76, 98, 119) : BV:32
121 : lambda(17, 120) : FUNCTION[BV:32 -> BV:32]
122 : map(16, 121) : MAP[BV:32 -> BV:32]
123 : sym_const(122) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 67372035 ] -> true, [ 67372036; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda84 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 3 { 0x3 +1.35e129 } : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(4, 1) : BV:32
6 : 84215045 { 0x5050505 +1.3921568e139 } : BV:32
7 : bvadd(3, 5, 6) : BV:32
8 : bvule(2, 7) : BOOL
9 : 639 { 0x27f +1.7617e129 } : BV:32
10 : bvule(7, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 1 { 0x1 } : BV:8
13 : 640 { 0x280 +1.7629e129 } : BV:32
14 : bvule(13, 7) : BOOL
15 : 643 { 0x283 +1.7665e129 } : BV:32
16 : bvule(7, 15) : BOOL
17 : and(14, 16) : BOOL
18 : 4 { 0x4 } : BV:8
19 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
20 : bvule(19, 7) : BOOL
21 : 556557207 { 0x212c6397 +1.34678924e195 } : BV:32
22 : bvule(7, 21) : BOOL
23 : and(20, 22) : BOOL
24 : 5 { 0x5 } : BV:8
25 : 556557208 { 0x212c6398 +1.34678936e195 } : BV:32
26 : bvule(25, 7) : BOOL
27 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
28 : bvule(7, 27) : BOOL
29 : and(26, 28) : BOOL
30 : 0 { 0x0 } : BV:8
31 : 644 { 0x284 +1.7677e129 } : BV:32
32 : bvule(31, 7) : BOOL
33 : 556557203 { 0x212c6393 +1.34678876e195 } : BV:32
34 : bvule(7, 33) : BOOL
35 : and(32, 34) : BOOL
36 : ite(35, 30, 30) : BV:8
37 : ite(29, 30, 36) : BV:8
38 : ite(23, 24, 37) : BV:8
39 : ite(17, 18, 38) : BV:8
40 : ite(11, 12, 39) : BV:8
41 : 2 { 0x2 +1.23e129 } : BV:32
42 : bvadd(41, 5, 6) : BV:32
43 : bvule(2, 42) : BOOL
44 : bvule(42, 9) : BOOL
45 : and(43, 44) : BOOL
46 : bvule(13, 42) : BOOL
47 : bvule(42, 15) : BOOL
48 : and(46, 47) : BOOL
49 : bvule(19, 42) : BOOL
50 : bvule(42, 21) : BOOL
51 : and(49, 50) : BOOL
52 : bvule(25, 42) : BOOL
53 : bvule(42, 27) : BOOL
54 : and(52, 53) : BOOL
55 : bvule(31, 42) : BOOL
56 : bvule(42, 33) : BOOL
57 : and(55, 56) : BOOL
58 : ite(57, 30, 30) : BV:8
59 : ite(54, 30, 58) : BV:8
60 : ite(51, 24, 59) : BV:8
61 : ite(48, 18, 60) : BV:8
62 : ite(45, 12, 61) : BV:8
63 : 1 { 0x1 +1.11e129 } : BV:32
64 : bvadd(63, 5, 6) : BV:32
65 : bvule(2, 64) : BOOL
66 : bvule(64, 9) : BOOL
67 : and(65, 66) : BOOL
68 : bvule(13, 64) : BOOL
69 : bvule(64, 15) : BOOL
70 : and(68, 69) : BOOL
71 : bvule(19, 64) : BOOL
72 : bvule(64, 21) : BOOL
73 : and(71, 72) : BOOL
74 : bvule(25, 64) : BOOL
75 : bvule(64, 27) : BOOL
76 : and(74, 75) : BOOL
77 : bvule(31, 64) : BOOL
78 : bvule(64, 33) : BOOL
79 : and(77, 78) : BOOL
80 : ite(79, 30, 30) : BV:8
81 : ite(76, 30, 80) : BV:8
82 : ite(73, 24, 81) : BV:8
83 : ite(70, 18, 82) : BV:8
84 : ite(67, 12, 83) : BV:8
85 : bvadd(5, 6) : BV:32
86 : bvule(2, 85) : BOOL
87 : bvule(85, 9) : BOOL
88 : and(86, 87) : BOOL
89 : bvule(13, 85) : BOOL
90 : bvule(85, 15) : BOOL
91 : and(89, 90) : BOOL
92 : bvule(19, 85) : BOOL
93 : bvule(85, 21) : BOOL
94 : and(92, 93) : BOOL
95 : bvule(25, 85) : BOOL
96 : bvule(85, 27) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(31, 85) : BOOL
99 : bvule(85, 33) : BOOL
100 : and(98, 99) : BOOL
101 : ite(100, 30, 30) : BV:8
102 : ite(97, 30, 101) : BV:8
103 : ite(94, 24, 102) : BV:8
104 : ite(91, 18, 103) : BV:8
105 : ite(88, 12, 104) : BV:8
106 : bvconcat(40, 62, 84, 105) : BV:32
107 : lambda(1, 106) : FUNCTION[BV:32 -> BV:32]
108 : sym_const(107) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform17 : BV:32
4 : Lambda112 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda113 : BV:32
7 : 342187326 { 0x14655d3e +1.79190802e169 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 67372035 ] -> true, [ 67372036; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda85 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 3 { 0x3 +1.35e129 } : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(4, 1) : BV:32
6 : 84215045 { 0x5050505 +1.3921568e139 } : BV:32
7 : bvadd(3, 5, 6) : BV:32
8 : bvule(2, 7) : BOOL
9 : 639 { 0x27f +1.7617e129 } : BV:32
10 : bvule(7, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 1 { 0x1 } : BV:8
13 : 640 { 0x280 +1.7629e129 } : BV:32
14 : bvule(13, 7) : BOOL
15 : 643 { 0x283 +1.7665e129 } : BV:32
16 : bvule(7, 15) : BOOL
17 : and(14, 16) : BOOL
18 : 4 { 0x4 } : BV:8
19 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
20 : bvule(19, 7) : BOOL
21 : 556557207 { 0x212c6397 +1.34678924e195 } : BV:32
22 : bvule(7, 21) : BOOL
23 : and(20, 22) : BOOL
24 : 5 { 0x5 } : BV:8
25 : 556557208 { 0x212c6398 +1.34678936e195 } : BV:32
26 : bvule(25, 7) : BOOL
27 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
28 : bvule(7, 27) : BOOL
29 : and(26, 28) : BOOL
30 : 0 { 0x0 } : BV:8
31 : 644 { 0x284 +1.7677e129 } : BV:32
32 : bvule(31, 7) : BOOL
33 : 556557203 { 0x212c6393 +1.34678876e195 } : BV:32
34 : bvule(7, 33) : BOOL
35 : and(32, 34) : BOOL
36 : ite(35, 30, 30) : BV:8
37 : ite(29, 30, 36) : BV:8
38 : ite(23, 24, 37) : BV:8
39 : ite(17, 18, 38) : BV:8
40 : ite(11, 12, 39) : BV:8
41 : 2 { 0x2 +1.23e129 } : BV:32
42 : bvadd(41, 5, 6) : BV:32
43 : bvule(2, 42) : BOOL
44 : bvule(42, 9) : BOOL
45 : and(43, 44) : BOOL
46 : bvule(13, 42) : BOOL
47 : bvule(42, 15) : BOOL
48 : and(46, 47) : BOOL
49 : bvule(19, 42) : BOOL
50 : bvule(42, 21) : BOOL
51 : and(49, 50) : BOOL
52 : bvule(25, 42) : BOOL
53 : bvule(42, 27) : BOOL
54 : and(52, 53) : BOOL
55 : bvule(31, 42) : BOOL
56 : bvule(42, 33) : BOOL
57 : and(55, 56) : BOOL
58 : ite(57, 30, 30) : BV:8
59 : ite(54, 30, 58) : BV:8
60 : ite(51, 24, 59) : BV:8
61 : ite(48, 18, 60) : BV:8
62 : ite(45, 12, 61) : BV:8
63 : 1 { 0x1 +1.11e129 } : BV:32
64 : bvadd(63, 5, 6) : BV:32
65 : bvule(2, 64) : BOOL
66 : bvule(64, 9) : BOOL
67 : and(65, 66) : BOOL
68 : bvule(13, 64) : BOOL
69 : bvule(64, 15) : BOOL
70 : and(68, 69) : BOOL
71 : bvule(19, 64) : BOOL
72 : bvule(64, 21) : BOOL
73 : and(71, 72) : BOOL
74 : bvule(25, 64) : BOOL
75 : bvule(64, 27) : BOOL
76 : and(74, 75) : BOOL
77 : bvule(31, 64) : BOOL
78 : bvule(64, 33) : BOOL
79 : and(77, 78) : BOOL
80 : ite(79, 30, 30) : BV:8
81 : ite(76, 30, 80) : BV:8
82 : ite(73, 24, 81) : BV:8
83 : ite(70, 18, 82) : BV:8
84 : ite(67, 12, 83) : BV:8
85 : bvadd(5, 6) : BV:32
86 : bvule(2, 85) : BOOL
87 : bvule(85, 9) : BOOL
88 : and(86, 87) : BOOL
89 : bvule(13, 85) : BOOL
90 : bvule(85, 15) : BOOL
91 : and(89, 90) : BOOL
92 : bvule(19, 85) : BOOL
93 : bvule(85, 21) : BOOL
94 : and(92, 93) : BOOL
95 : bvule(25, 85) : BOOL
96 : bvule(85, 27) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(31, 85) : BOOL
99 : bvule(85, 33) : BOOL
100 : and(98, 99) : BOOL
101 : ite(100, 30, 30) : BV:8
102 : ite(97, 30, 101) : BV:8
103 : ite(94, 24, 102) : BV:8
104 : ite(91, 18, 103) : BV:8
105 : ite(88, 12, 104) : BV:8
106 : bvconcat(40, 62, 84, 105) : BV:32
107 : lambda(1, 106) : FUNCTION[BV:32 -> BV:32]
108 : sym_const(107) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 84215045 { 0x5050505 +1.3921568e139 } : BV:32
=input.dst.llvm-%n
1 : 67372036 { 0x4040404 +1.3137254e137 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 639 ] -> 1, [ 640; 643 ] -> 4, [ 644; 556557203 ] -> 0, [ 556557204; 556557207 ] -> 5, [ 556557208; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 639 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 640; 643 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 644; 556557203 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 556557204; 556557207 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 556557208; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 640 { 0x280 +1.7629e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 640 { 0x280 +1.7629e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 643 { 0x283 +1.7665e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 556557204 { 0x212c6394 +1.34678888e195 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 556557207 { 0x212c6397 +1.34678924e195 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
717504270
=counter_example_end
=global nodece 1 num_edges_traversed 0
=global nodece 1 nodece_visted_pcs: 
L0%0%d_L0%0%d
=global nodece 2
=global nodece 2 nodece z3.ce19.num_edges_traversed1
=global nodece 2 nodece_path
=global nodece 2 nodece_path.graph_edge_composition
(L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 2 nodece_cached_counterexample
=counter_example_begin z3.ce19 ff1ccaefebf53da59af88d47923eed41
=input.spec-%var-arr-1
1 : Lambda197 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda198 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda197 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda198 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda176 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda177 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.dst.llvm-%n
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.local_alloc_count.=L0%0%d=
1 : 318648393 { 0x12fe3049 +1.98584854e166 } : COUNT
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 318648393 { 0x12fe3049 +1.98584854e166 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1903413019 { 0x7173c71b +1.90451371e99 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
340383979
=counter_example_end
=global nodece 2 num_edges_traversed 1
=global nodece 2 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 3
=global nodece 3 nodece z3v487.ce20.num_edges_traversed1
=global nodece 3 nodece_path
=global nodece 3 nodece_path.graph_edge_composition
(L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 3 nodece_cached_counterexample
=counter_example_begin z3v487.ce20 f0e15780afe1ac4ea7f5d8b2145e4d7
=input.spec-%var-arr-1
1 : Lambda211 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda212 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda211 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda212 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda185 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda186 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%n
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.local_alloc_count.=L0%0%d=
1 : 211961543 { 0xca246c7 +1.26778495e154 } : COUNT
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 211961543 { 0xca246c7 +1.26778495e154 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 67 { 0x43 +1.798e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3721003027 { 0xddca0013 -573964269 -1.57812726e60 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
180861690
=counter_example_end
=global nodece 3 num_edges_traversed 1
=global nodece 3 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 4
=global nodece 4 nodece z3.ce41.num_edges_traversed1
=global nodece 4 nodece_path
=global nodece 4 nodece_path.graph_edge_composition
(L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 4 nodece_cached_counterexample
=counter_example_begin z3.ce41 89851cb441a5e53282bc73a1cfed333
=input.spec-%var-arr-1
1 : Lambda301 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda302 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda301 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda302 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda280 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda281 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.dst.llvm-%n
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.local_alloc_count.=L0%0%d=
1 : 961465037 { 0x394ecacd +1.61556398e243 } : COUNT
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 961465037 { 0x394ecacd +1.61556398e243 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1067701935 { 0x3fa3d6af +1.27998912e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3670926980
=counter_example_end
=global nodece 4 num_edges_traversed 1
=global nodece 4 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 5
=global nodece 5 nodece z3.ce63.num_edges_traversed1
=global nodece 5 nodece_path
=global nodece 5 nodece_path.graph_edge_composition
(L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 5 nodece_cached_counterexample
=counter_example_begin z3.ce63 4491874c3781ee616fe3370692333d5
=input.spec-%var-arr-1
1 : Lambda405 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda406 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda405 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda406 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda384 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : ite(3, 2, 128) : BV:32
130 : lambda(1, 129) : FUNCTION[BV:32 -> BV:32]
131 : sym_const(130) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda385 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : lambda(1, 128) : FUNCTION[BV:32 -> BV:32]
130 : sym_const(129) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.dst.llvm-%n
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.local_alloc_count.=L0%0%d=
1 : 1420111171 { 0x54a52d43 +1.29044377e42 } : COUNT
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1420111171 { 0x54a52d43 +1.29044377e42 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
155419542
=counter_example_end
=global nodece 5 num_edges_traversed 1
=global nodece 5 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 6
=global nodece 6 nodece z3v487.ce496.num_edges_traversed0
=global nodece 6 nodece_path
=global nodece 6 nodece_path.graph_edge_composition
(epsilon)
=global nodece 6 nodece_cached_counterexample
=counter_example_begin z3v487.ce496 ce701c3711f2bbb0f148a23142bba9a
=input.spec-%var-arr-1
1 : Lambda2296 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda2297 : BV:32
11 : 3 { 0x3 +1.35e129 } : BV:32
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(12, 10) : BV:32
14 : bvadd(11, 13) : BV:32
15 : bvule(2, 14) : BOOL
16 : 536870911 { 0x1fffffff +1.99999988e192 } : BV:32
17 : bvule(14, 16) : BOOL
18 : and(15, 17) : BOOL
19 : 1 { 0x1 } : BV:8
20 : 536870912 { 0x20000000 +1.0e193 } : BV:32
21 : bvule(20, 14) : BOOL
22 : 536870915 { 0x20000003 +1.35e193 } : BV:32
23 : bvule(14, 22) : BOOL
24 : and(21, 23) : BOOL
25 : 4 { 0x4 } : BV:8
26 : 536870916 { 0x20000004 +1.47e193 } : BV:32
27 : bvule(26, 14) : BOOL
28 : 3448586623 { 0xcd8d417f -846380673 -1.10356128e28 } : BV:32
29 : bvule(14, 28) : BOOL
30 : and(27, 29) : BOOL
31 : 0 { 0x0 } : BV:8
32 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
33 : bvule(32, 14) : BOOL
34 : 3448586627 { 0xcd8d4183 -846380669 -1.10356175e28 } : BV:32
35 : bvule(14, 34) : BOOL
36 : and(33, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : 3448586628 { 0xcd8d4184 -846380668 -1.10356187e28 } : BV:32
39 : bvule(38, 14) : BOOL
40 : bvule(14, 4) : BOOL
41 : and(39, 40) : BOOL
42 : ite(41, 31, 31) : BV:8
43 : ite(36, 37, 42) : BV:8
44 : ite(30, 31, 43) : BV:8
45 : ite(24, 25, 44) : BV:8
46 : ite(18, 19, 45) : BV:8
47 : 2 { 0x2 +1.23e129 } : BV:32
48 : bvadd(47, 13) : BV:32
49 : bvule(2, 48) : BOOL
50 : bvule(48, 16) : BOOL
51 : and(49, 50) : BOOL
52 : bvule(20, 48) : BOOL
53 : bvule(48, 22) : BOOL
54 : and(52, 53) : BOOL
55 : bvule(26, 48) : BOOL
56 : bvule(48, 28) : BOOL
57 : and(55, 56) : BOOL
58 : bvule(32, 48) : BOOL
59 : bvule(48, 34) : BOOL
60 : and(58, 59) : BOOL
61 : bvule(38, 48) : BOOL
62 : bvule(48, 4) : BOOL
63 : and(61, 62) : BOOL
64 : ite(63, 31, 31) : BV:8
65 : ite(60, 37, 64) : BV:8
66 : ite(57, 31, 65) : BV:8
67 : ite(54, 25, 66) : BV:8
68 : ite(51, 19, 67) : BV:8
69 : 1 { 0x1 +1.11e129 } : BV:32
70 : bvadd(69, 13) : BV:32
71 : bvule(2, 70) : BOOL
72 : bvule(70, 16) : BOOL
73 : and(71, 72) : BOOL
74 : bvule(20, 70) : BOOL
75 : bvule(70, 22) : BOOL
76 : and(74, 75) : BOOL
77 : bvule(26, 70) : BOOL
78 : bvule(70, 28) : BOOL
79 : and(77, 78) : BOOL
80 : bvule(32, 70) : BOOL
81 : bvule(70, 34) : BOOL
82 : and(80, 81) : BOOL
83 : bvule(38, 70) : BOOL
84 : bvule(70, 4) : BOOL
85 : and(83, 84) : BOOL
86 : ite(85, 31, 31) : BV:8
87 : ite(82, 37, 86) : BV:8
88 : ite(79, 31, 87) : BV:8
89 : ite(76, 25, 88) : BV:8
90 : ite(73, 19, 89) : BV:8
91 : bvule(2, 13) : BOOL
92 : bvule(13, 16) : BOOL
93 : and(91, 92) : BOOL
94 : bvule(20, 13) : BOOL
95 : bvule(13, 22) : BOOL
96 : and(94, 95) : BOOL
97 : bvule(26, 13) : BOOL
98 : bvule(13, 28) : BOOL
99 : and(97, 98) : BOOL
100 : bvule(32, 13) : BOOL
101 : bvule(13, 34) : BOOL
102 : and(100, 101) : BOOL
103 : bvule(38, 13) : BOOL
104 : bvule(13, 4) : BOOL
105 : and(103, 104) : BOOL
106 : ite(105, 31, 31) : BV:8
107 : ite(102, 37, 106) : BV:8
108 : ite(99, 31, 107) : BV:8
109 : ite(96, 25, 108) : BV:8
110 : ite(93, 19, 109) : BV:8
111 : bvconcat(46, 68, 90, 110) : BV:32
112 : lambda(10, 111) : FUNCTION[BV:32 -> BV:32]
113 : map(9, 112) : MAP[BV:32 -> BV:32]
114 : sym_const(113) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda2299 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda2300 : BV:32
11 : bvule(2, 10) : BOOL
12 : bvule(10, 4) : BOOL
13 : and(11, 12) : BOOL
14 : ite(13, 7, 7) : BOOL
15 : 3 { 0x3 +1.35e129 } : BV:32
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(16, 10) : BV:32
18 : bvadd(15, 17) : BV:32
19 : bvule(2, 18) : BOOL
20 : 536870911 { 0x1fffffff +1.99999988e192 } : BV:32
21 : bvule(18, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 1 { 0x1 } : BV:8
24 : 536870912 { 0x20000000 +1.0e193 } : BV:32
25 : bvule(24, 18) : BOOL
26 : 536870915 { 0x20000003 +1.35e193 } : BV:32
27 : bvule(18, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 4 { 0x4 } : BV:8
30 : 536870916 { 0x20000004 +1.47e193 } : BV:32
31 : bvule(30, 18) : BOOL
32 : 3448586623 { 0xcd8d417f -846380673 -1.10356128e28 } : BV:32
33 : bvule(18, 32) : BOOL
34 : and(31, 33) : BOOL
35 : 0 { 0x0 } : BV:8
36 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
37 : bvule(36, 18) : BOOL
38 : 3448586627 { 0xcd8d4183 -846380669 -1.10356175e28 } : BV:32
39 : bvule(18, 38) : BOOL
40 : and(37, 39) : BOOL
41 : 5 { 0x5 } : BV:8
42 : 3448586628 { 0xcd8d4184 -846380668 -1.10356187e28 } : BV:32
43 : bvule(42, 18) : BOOL
44 : bvule(18, 4) : BOOL
45 : and(43, 44) : BOOL
46 : ite(45, 35, 35) : BV:8
47 : ite(40, 41, 46) : BV:8
48 : ite(34, 35, 47) : BV:8
49 : ite(28, 29, 48) : BV:8
50 : ite(22, 23, 49) : BV:8
51 : 2 { 0x2 +1.23e129 } : BV:32
52 : bvadd(51, 17) : BV:32
53 : bvule(2, 52) : BOOL
54 : bvule(52, 20) : BOOL
55 : and(53, 54) : BOOL
56 : bvule(24, 52) : BOOL
57 : bvule(52, 26) : BOOL
58 : and(56, 57) : BOOL
59 : bvule(30, 52) : BOOL
60 : bvule(52, 32) : BOOL
61 : and(59, 60) : BOOL
62 : bvule(36, 52) : BOOL
63 : bvule(52, 38) : BOOL
64 : and(62, 63) : BOOL
65 : bvule(42, 52) : BOOL
66 : bvule(52, 4) : BOOL
67 : and(65, 66) : BOOL
68 : ite(67, 35, 35) : BV:8
69 : ite(64, 41, 68) : BV:8
70 : ite(61, 35, 69) : BV:8
71 : ite(58, 29, 70) : BV:8
72 : ite(55, 23, 71) : BV:8
73 : 1 { 0x1 +1.11e129 } : BV:32
74 : bvadd(73, 17) : BV:32
75 : bvule(2, 74) : BOOL
76 : bvule(74, 20) : BOOL
77 : and(75, 76) : BOOL
78 : bvule(24, 74) : BOOL
79 : bvule(74, 26) : BOOL
80 : and(78, 79) : BOOL
81 : bvule(30, 74) : BOOL
82 : bvule(74, 32) : BOOL
83 : and(81, 82) : BOOL
84 : bvule(36, 74) : BOOL
85 : bvule(74, 38) : BOOL
86 : and(84, 85) : BOOL
87 : bvule(42, 74) : BOOL
88 : bvule(74, 4) : BOOL
89 : and(87, 88) : BOOL
90 : ite(89, 35, 35) : BV:8
91 : ite(86, 41, 90) : BV:8
92 : ite(83, 35, 91) : BV:8
93 : ite(80, 29, 92) : BV:8
94 : ite(77, 23, 93) : BV:8
95 : bvule(2, 17) : BOOL
96 : bvule(17, 20) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(24, 17) : BOOL
99 : bvule(17, 26) : BOOL
100 : and(98, 99) : BOOL
101 : bvule(30, 17) : BOOL
102 : bvule(17, 32) : BOOL
103 : and(101, 102) : BOOL
104 : bvule(36, 17) : BOOL
105 : bvule(17, 38) : BOOL
106 : and(104, 105) : BOOL
107 : bvule(42, 17) : BOOL
108 : bvule(17, 4) : BOOL
109 : and(107, 108) : BOOL
110 : ite(109, 35, 35) : BV:8
111 : ite(106, 41, 110) : BV:8
112 : ite(103, 35, 111) : BV:8
113 : ite(100, 29, 112) : BV:8
114 : ite(97, 23, 113) : BV:8
115 : bvconcat(50, 72, 94, 114) : BV:32
116 : ite(14, 115, 115) : BV:32
117 : lambda(10, 116) : FUNCTION[BV:32 -> BV:32]
118 : map(9, 117) : MAP[BV:32 -> BV:32]
119 : sym_const(118) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda2274 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : 3 { 0x3 +1.35e129 } : BV:32
10 : 4 { 0x4 +1.47e129 } : BV:32
11 : bvmul(10, 1) : BV:32
12 : bvadd(9, 11) : BV:32
13 : bvule(2, 12) : BOOL
14 : 536870911 { 0x1fffffff +1.99999988e192 } : BV:32
15 : bvule(12, 14) : BOOL
16 : and(13, 15) : BOOL
17 : 1 { 0x1 } : BV:8
18 : 536870912 { 0x20000000 +1.0e193 } : BV:32
19 : bvule(18, 12) : BOOL
20 : 536870915 { 0x20000003 +1.35e193 } : BV:32
21 : bvule(12, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 4 { 0x4 } : BV:8
24 : 536870916 { 0x20000004 +1.47e193 } : BV:32
25 : bvule(24, 12) : BOOL
26 : 3448586623 { 0xcd8d417f -846380673 -1.10356128e28 } : BV:32
27 : bvule(12, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 0 { 0x0 } : BV:8
30 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
31 : bvule(30, 12) : BOOL
32 : 3448586627 { 0xcd8d4183 -846380669 -1.10356175e28 } : BV:32
33 : bvule(12, 32) : BOOL
34 : and(31, 33) : BOOL
35 : 5 { 0x5 } : BV:8
36 : 3448586628 { 0xcd8d4184 -846380668 -1.10356187e28 } : BV:32
37 : bvule(36, 12) : BOOL
38 : bvule(12, 4) : BOOL
39 : and(37, 38) : BOOL
40 : ite(39, 29, 29) : BV:8
41 : ite(34, 35, 40) : BV:8
42 : ite(28, 29, 41) : BV:8
43 : ite(22, 23, 42) : BV:8
44 : ite(16, 17, 43) : BV:8
45 : 2 { 0x2 +1.23e129 } : BV:32
46 : bvadd(45, 11) : BV:32
47 : bvule(2, 46) : BOOL
48 : bvule(46, 14) : BOOL
49 : and(47, 48) : BOOL
50 : bvule(18, 46) : BOOL
51 : bvule(46, 20) : BOOL
52 : and(50, 51) : BOOL
53 : bvule(24, 46) : BOOL
54 : bvule(46, 26) : BOOL
55 : and(53, 54) : BOOL
56 : bvule(30, 46) : BOOL
57 : bvule(46, 32) : BOOL
58 : and(56, 57) : BOOL
59 : bvule(36, 46) : BOOL
60 : bvule(46, 4) : BOOL
61 : and(59, 60) : BOOL
62 : ite(61, 29, 29) : BV:8
63 : ite(58, 35, 62) : BV:8
64 : ite(55, 29, 63) : BV:8
65 : ite(52, 23, 64) : BV:8
66 : ite(49, 17, 65) : BV:8
67 : 1 { 0x1 +1.11e129 } : BV:32
68 : bvadd(67, 11) : BV:32
69 : bvule(2, 68) : BOOL
70 : bvule(68, 14) : BOOL
71 : and(69, 70) : BOOL
72 : bvule(18, 68) : BOOL
73 : bvule(68, 20) : BOOL
74 : and(72, 73) : BOOL
75 : bvule(24, 68) : BOOL
76 : bvule(68, 26) : BOOL
77 : and(75, 76) : BOOL
78 : bvule(30, 68) : BOOL
79 : bvule(68, 32) : BOOL
80 : and(78, 79) : BOOL
81 : bvule(36, 68) : BOOL
82 : bvule(68, 4) : BOOL
83 : and(81, 82) : BOOL
84 : ite(83, 29, 29) : BV:8
85 : ite(80, 35, 84) : BV:8
86 : ite(77, 29, 85) : BV:8
87 : ite(74, 23, 86) : BV:8
88 : ite(71, 17, 87) : BV:8
89 : bvule(2, 11) : BOOL
90 : bvule(11, 14) : BOOL
91 : and(89, 90) : BOOL
92 : bvule(18, 11) : BOOL
93 : bvule(11, 20) : BOOL
94 : and(92, 93) : BOOL
95 : bvule(24, 11) : BOOL
96 : bvule(11, 26) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(30, 11) : BOOL
99 : bvule(11, 32) : BOOL
100 : and(98, 99) : BOOL
101 : bvule(36, 11) : BOOL
102 : bvule(11, 4) : BOOL
103 : and(101, 102) : BOOL
104 : ite(103, 29, 29) : BV:8
105 : ite(100, 35, 104) : BV:8
106 : ite(97, 29, 105) : BV:8
107 : ite(94, 23, 106) : BV:8
108 : ite(91, 17, 107) : BV:8
109 : bvconcat(44, 66, 88, 108) : BV:32
110 : ite(8, 109, 109) : BV:32
111 : lambda(1, 110) : FUNCTION[BV:32 -> BV:32]
112 : sym_const(111) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform203 : BV:32
4 : Lambda2303 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2304 : BV:32
7 : 1996640683 { 0x770251ab +1.1811730e111 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda2278 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 3 { 0x3 +1.35e129 } : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(4, 1) : BV:32
6 : bvadd(3, 5) : BV:32
7 : bvule(2, 6) : BOOL
8 : 536870911 { 0x1fffffff +1.99999988e192 } : BV:32
9 : bvule(6, 8) : BOOL
10 : and(7, 9) : BOOL
11 : 1 { 0x1 } : BV:8
12 : 536870912 { 0x20000000 +1.0e193 } : BV:32
13 : bvule(12, 6) : BOOL
14 : 536870915 { 0x20000003 +1.35e193 } : BV:32
15 : bvule(6, 14) : BOOL
16 : and(13, 15) : BOOL
17 : 4 { 0x4 } : BV:8
18 : 536870916 { 0x20000004 +1.47e193 } : BV:32
19 : bvule(18, 6) : BOOL
20 : 3448586623 { 0xcd8d417f -846380673 -1.10356128e28 } : BV:32
21 : bvule(6, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
25 : bvule(24, 6) : BOOL
26 : 3448586627 { 0xcd8d4183 -846380669 -1.10356175e28 } : BV:32
27 : bvule(6, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 5 { 0x5 } : BV:8
30 : 3448586628 { 0xcd8d4184 -846380668 -1.10356187e28 } : BV:32
31 : bvule(30, 6) : BOOL
32 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
33 : bvule(6, 32) : BOOL
34 : and(31, 33) : BOOL
35 : ite(34, 23, 23) : BV:8
36 : ite(28, 29, 35) : BV:8
37 : ite(22, 23, 36) : BV:8
38 : ite(16, 17, 37) : BV:8
39 : ite(10, 11, 38) : BV:8
40 : 2 { 0x2 +1.23e129 } : BV:32
41 : bvadd(40, 5) : BV:32
42 : bvule(2, 41) : BOOL
43 : bvule(41, 8) : BOOL
44 : and(42, 43) : BOOL
45 : bvule(12, 41) : BOOL
46 : bvule(41, 14) : BOOL
47 : and(45, 46) : BOOL
48 : bvule(18, 41) : BOOL
49 : bvule(41, 20) : BOOL
50 : and(48, 49) : BOOL
51 : bvule(24, 41) : BOOL
52 : bvule(41, 26) : BOOL
53 : and(51, 52) : BOOL
54 : bvule(30, 41) : BOOL
55 : bvule(41, 32) : BOOL
56 : and(54, 55) : BOOL
57 : ite(56, 23, 23) : BV:8
58 : ite(53, 29, 57) : BV:8
59 : ite(50, 23, 58) : BV:8
60 : ite(47, 17, 59) : BV:8
61 : ite(44, 11, 60) : BV:8
62 : 1 { 0x1 +1.11e129 } : BV:32
63 : bvadd(62, 5) : BV:32
64 : bvule(2, 63) : BOOL
65 : bvule(63, 8) : BOOL
66 : and(64, 65) : BOOL
67 : bvule(12, 63) : BOOL
68 : bvule(63, 14) : BOOL
69 : and(67, 68) : BOOL
70 : bvule(18, 63) : BOOL
71 : bvule(63, 20) : BOOL
72 : and(70, 71) : BOOL
73 : bvule(24, 63) : BOOL
74 : bvule(63, 26) : BOOL
75 : and(73, 74) : BOOL
76 : bvule(30, 63) : BOOL
77 : bvule(63, 32) : BOOL
78 : and(76, 77) : BOOL
79 : ite(78, 23, 23) : BV:8
80 : ite(75, 29, 79) : BV:8
81 : ite(72, 23, 80) : BV:8
82 : ite(69, 17, 81) : BV:8
83 : ite(66, 11, 82) : BV:8
84 : bvule(2, 5) : BOOL
85 : bvule(5, 8) : BOOL
86 : and(84, 85) : BOOL
87 : bvule(12, 5) : BOOL
88 : bvule(5, 14) : BOOL
89 : and(87, 88) : BOOL
90 : bvule(18, 5) : BOOL
91 : bvule(5, 20) : BOOL
92 : and(90, 91) : BOOL
93 : bvule(24, 5) : BOOL
94 : bvule(5, 26) : BOOL
95 : and(93, 94) : BOOL
96 : bvule(30, 5) : BOOL
97 : bvule(5, 32) : BOOL
98 : and(96, 97) : BOOL
99 : ite(98, 23, 23) : BV:8
100 : ite(95, 29, 99) : BV:8
101 : ite(92, 23, 100) : BV:8
102 : ite(89, 17, 101) : BV:8
103 : ite(86, 11, 102) : BV:8
104 : bvconcat(39, 61, 83, 103) : BV:32
105 : lambda(1, 104) : FUNCTION[BV:32 -> BV:32]
106 : sym_const(105) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform202 : BV:32
4 : Lambda2301 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2302 : BV:32
7 : 811667208 { 0x30610f08 +1.75827121e225 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 536870911 ] -> 1, [ 536870912; 536870915 ] -> 4, [ 536870916; 3448586623 ] -> 0, [ 3448586624; 3448586627 ] -> 5, [ 3448586628; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 536870911 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 536870912; 536870915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 536870916; 3448586623 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3448586624; 3448586627 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3448586628; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 536870912 { 0x20000000 +1.0e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 536870915 { 0x20000003 +1.35e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3448586624 { 0xcd8d4180 -846380672 -1.10356140e28 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3448586627 { 0xcd8d4183 -846380669 -1.10356175e28 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2621616107
=counter_example_end
=global nodece 6 num_edges_traversed 0
=global nodece 6 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 7
=global nodece 7 nodece z3.ce497.num_edges_traversed0
=global nodece 7 nodece_path
=global nodece 7 nodece_path.graph_edge_composition
(epsilon)
=global nodece 7 nodece_cached_counterexample
=counter_example_begin z3.ce497 1c6b236b79b86f83736cdcc44efae0e5
=input.spec-%var-arr-1
1 : Lambda2314 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda2315 : BV:32
11 : bvule(2, 10) : BOOL
12 : bvule(10, 4) : BOOL
13 : and(11, 12) : BOOL
14 : ite(13, 7, 7) : BOOL
15 : 3 { 0x3 +1.35e129 } : BV:32
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(16, 10) : BV:32
18 : bvadd(15, 17) : BV:32
19 : bvule(2, 18) : BOOL
20 : 1703603503 { 0x658aed2f +1.8536326e76 } : BV:32
21 : bvule(18, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 1 { 0x1 } : BV:8
24 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
25 : bvule(24, 18) : BOOL
26 : 1703603507 { 0x658aed33 +1.8536374e76 } : BV:32
27 : bvule(18, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 4 { 0x4 } : BV:8
30 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
31 : bvule(30, 18) : BOOL
32 : 3726783631 { 0xde22348f -568183665 -1.26722896e61 } : BV:32
33 : bvule(18, 32) : BOOL
34 : and(31, 33) : BOOL
35 : 5 { 0x5 } : BV:8
36 : 1703603508 { 0x658aed34 +1.8536386e76 } : BV:32
37 : bvule(36, 18) : BOOL
38 : 3726783627 { 0xde22348b -568183669 -1.26722848e61 } : BV:32
39 : bvule(18, 38) : BOOL
40 : and(37, 39) : BOOL
41 : 0 { 0x0 } : BV:8
42 : 3726783632 { 0xde223490 -568183664 -1.26722908e61 } : BV:32
43 : bvule(42, 18) : BOOL
44 : bvule(18, 4) : BOOL
45 : and(43, 44) : BOOL
46 : ite(45, 41, 41) : BV:8
47 : ite(40, 41, 46) : BV:8
48 : ite(34, 35, 47) : BV:8
49 : ite(28, 29, 48) : BV:8
50 : ite(22, 23, 49) : BV:8
51 : 2 { 0x2 +1.23e129 } : BV:32
52 : bvadd(51, 17) : BV:32
53 : bvule(2, 52) : BOOL
54 : bvule(52, 20) : BOOL
55 : and(53, 54) : BOOL
56 : bvule(24, 52) : BOOL
57 : bvule(52, 26) : BOOL
58 : and(56, 57) : BOOL
59 : bvule(30, 52) : BOOL
60 : bvule(52, 32) : BOOL
61 : and(59, 60) : BOOL
62 : bvule(36, 52) : BOOL
63 : bvule(52, 38) : BOOL
64 : and(62, 63) : BOOL
65 : bvule(42, 52) : BOOL
66 : bvule(52, 4) : BOOL
67 : and(65, 66) : BOOL
68 : ite(67, 41, 41) : BV:8
69 : ite(64, 41, 68) : BV:8
70 : ite(61, 35, 69) : BV:8
71 : ite(58, 29, 70) : BV:8
72 : ite(55, 23, 71) : BV:8
73 : 1 { 0x1 +1.11e129 } : BV:32
74 : bvadd(73, 17) : BV:32
75 : bvule(2, 74) : BOOL
76 : bvule(74, 20) : BOOL
77 : and(75, 76) : BOOL
78 : bvule(24, 74) : BOOL
79 : bvule(74, 26) : BOOL
80 : and(78, 79) : BOOL
81 : bvule(30, 74) : BOOL
82 : bvule(74, 32) : BOOL
83 : and(81, 82) : BOOL
84 : bvule(36, 74) : BOOL
85 : bvule(74, 38) : BOOL
86 : and(84, 85) : BOOL
87 : bvule(42, 74) : BOOL
88 : bvule(74, 4) : BOOL
89 : and(87, 88) : BOOL
90 : ite(89, 41, 41) : BV:8
91 : ite(86, 41, 90) : BV:8
92 : ite(83, 35, 91) : BV:8
93 : ite(80, 29, 92) : BV:8
94 : ite(77, 23, 93) : BV:8
95 : bvule(2, 17) : BOOL
96 : bvule(17, 20) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(24, 17) : BOOL
99 : bvule(17, 26) : BOOL
100 : and(98, 99) : BOOL
101 : bvule(30, 17) : BOOL
102 : bvule(17, 32) : BOOL
103 : and(101, 102) : BOOL
104 : bvule(36, 17) : BOOL
105 : bvule(17, 38) : BOOL
106 : and(104, 105) : BOOL
107 : bvule(42, 17) : BOOL
108 : bvule(17, 4) : BOOL
109 : and(107, 108) : BOOL
110 : ite(109, 41, 41) : BV:8
111 : ite(106, 41, 110) : BV:8
112 : ite(103, 35, 111) : BV:8
113 : ite(100, 29, 112) : BV:8
114 : ite(97, 23, 113) : BV:8
115 : bvconcat(50, 72, 94, 114) : BV:32
116 : ite(14, 115, 115) : BV:32
117 : lambda(10, 116) : FUNCTION[BV:32 -> BV:32]
118 : map(9, 117) : MAP[BV:32 -> BV:32]
119 : sym_const(118) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda2317 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : lambda(1, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda2318 : BV:32
11 : 3 { 0x3 +1.35e129 } : BV:32
12 : 4 { 0x4 +1.47e129 } : BV:32
13 : bvmul(12, 10) : BV:32
14 : bvadd(11, 13) : BV:32
15 : bvule(2, 14) : BOOL
16 : 1703603503 { 0x658aed2f +1.8536326e76 } : BV:32
17 : bvule(14, 16) : BOOL
18 : and(15, 17) : BOOL
19 : 1 { 0x1 } : BV:8
20 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
21 : bvule(20, 14) : BOOL
22 : 1703603507 { 0x658aed33 +1.8536374e76 } : BV:32
23 : bvule(14, 22) : BOOL
24 : and(21, 23) : BOOL
25 : 4 { 0x4 } : BV:8
26 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
27 : bvule(26, 14) : BOOL
28 : 3726783631 { 0xde22348f -568183665 -1.26722896e61 } : BV:32
29 : bvule(14, 28) : BOOL
30 : and(27, 29) : BOOL
31 : 5 { 0x5 } : BV:8
32 : 1703603508 { 0x658aed34 +1.8536386e76 } : BV:32
33 : bvule(32, 14) : BOOL
34 : 3726783627 { 0xde22348b -568183669 -1.26722848e61 } : BV:32
35 : bvule(14, 34) : BOOL
36 : and(33, 35) : BOOL
37 : 0 { 0x0 } : BV:8
38 : 3726783632 { 0xde223490 -568183664 -1.26722908e61 } : BV:32
39 : bvule(38, 14) : BOOL
40 : bvule(14, 4) : BOOL
41 : and(39, 40) : BOOL
42 : ite(41, 37, 37) : BV:8
43 : ite(36, 37, 42) : BV:8
44 : ite(30, 31, 43) : BV:8
45 : ite(24, 25, 44) : BV:8
46 : ite(18, 19, 45) : BV:8
47 : 2 { 0x2 +1.23e129 } : BV:32
48 : bvadd(47, 13) : BV:32
49 : bvule(2, 48) : BOOL
50 : bvule(48, 16) : BOOL
51 : and(49, 50) : BOOL
52 : bvule(20, 48) : BOOL
53 : bvule(48, 22) : BOOL
54 : and(52, 53) : BOOL
55 : bvule(26, 48) : BOOL
56 : bvule(48, 28) : BOOL
57 : and(55, 56) : BOOL
58 : bvule(32, 48) : BOOL
59 : bvule(48, 34) : BOOL
60 : and(58, 59) : BOOL
61 : bvule(38, 48) : BOOL
62 : bvule(48, 4) : BOOL
63 : and(61, 62) : BOOL
64 : ite(63, 37, 37) : BV:8
65 : ite(60, 37, 64) : BV:8
66 : ite(57, 31, 65) : BV:8
67 : ite(54, 25, 66) : BV:8
68 : ite(51, 19, 67) : BV:8
69 : 1 { 0x1 +1.11e129 } : BV:32
70 : bvadd(69, 13) : BV:32
71 : bvule(2, 70) : BOOL
72 : bvule(70, 16) : BOOL
73 : and(71, 72) : BOOL
74 : bvule(20, 70) : BOOL
75 : bvule(70, 22) : BOOL
76 : and(74, 75) : BOOL
77 : bvule(26, 70) : BOOL
78 : bvule(70, 28) : BOOL
79 : and(77, 78) : BOOL
80 : bvule(32, 70) : BOOL
81 : bvule(70, 34) : BOOL
82 : and(80, 81) : BOOL
83 : bvule(38, 70) : BOOL
84 : bvule(70, 4) : BOOL
85 : and(83, 84) : BOOL
86 : ite(85, 37, 37) : BV:8
87 : ite(82, 37, 86) : BV:8
88 : ite(79, 31, 87) : BV:8
89 : ite(76, 25, 88) : BV:8
90 : ite(73, 19, 89) : BV:8
91 : bvule(2, 13) : BOOL
92 : bvule(13, 16) : BOOL
93 : and(91, 92) : BOOL
94 : bvule(20, 13) : BOOL
95 : bvule(13, 22) : BOOL
96 : and(94, 95) : BOOL
97 : bvule(26, 13) : BOOL
98 : bvule(13, 28) : BOOL
99 : and(97, 98) : BOOL
100 : bvule(32, 13) : BOOL
101 : bvule(13, 34) : BOOL
102 : and(100, 101) : BOOL
103 : bvule(38, 13) : BOOL
104 : bvule(13, 4) : BOOL
105 : and(103, 104) : BOOL
106 : ite(105, 37, 37) : BV:8
107 : ite(102, 37, 106) : BV:8
108 : ite(99, 31, 107) : BV:8
109 : ite(96, 25, 108) : BV:8
110 : ite(93, 19, 109) : BV:8
111 : bvconcat(46, 68, 90, 110) : BV:32
112 : lambda(10, 111) : FUNCTION[BV:32 -> BV:32]
113 : map(9, 112) : MAP[BV:32 -> BV:32]
114 : sym_const(113) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda2281 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : 3 { 0x3 +1.35e129 } : BV:32
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : bvmul(4, 1) : BV:32
6 : bvadd(3, 5) : BV:32
7 : bvule(2, 6) : BOOL
8 : 1703603503 { 0x658aed2f +1.8536326e76 } : BV:32
9 : bvule(6, 8) : BOOL
10 : and(7, 9) : BOOL
11 : 1 { 0x1 } : BV:8
12 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
13 : bvule(12, 6) : BOOL
14 : 1703603507 { 0x658aed33 +1.8536374e76 } : BV:32
15 : bvule(6, 14) : BOOL
16 : and(13, 15) : BOOL
17 : 4 { 0x4 } : BV:8
18 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
19 : bvule(18, 6) : BOOL
20 : 3726783631 { 0xde22348f -568183665 -1.26722896e61 } : BV:32
21 : bvule(6, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 5 { 0x5 } : BV:8
24 : 1703603508 { 0x658aed34 +1.8536386e76 } : BV:32
25 : bvule(24, 6) : BOOL
26 : 3726783627 { 0xde22348b -568183669 -1.26722848e61 } : BV:32
27 : bvule(6, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 0 { 0x0 } : BV:8
30 : 3726783632 { 0xde223490 -568183664 -1.26722908e61 } : BV:32
31 : bvule(30, 6) : BOOL
32 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
33 : bvule(6, 32) : BOOL
34 : and(31, 33) : BOOL
35 : ite(34, 29, 29) : BV:8
36 : ite(28, 29, 35) : BV:8
37 : ite(22, 23, 36) : BV:8
38 : ite(16, 17, 37) : BV:8
39 : ite(10, 11, 38) : BV:8
40 : 2 { 0x2 +1.23e129 } : BV:32
41 : bvadd(40, 5) : BV:32
42 : bvule(2, 41) : BOOL
43 : bvule(41, 8) : BOOL
44 : and(42, 43) : BOOL
45 : bvule(12, 41) : BOOL
46 : bvule(41, 14) : BOOL
47 : and(45, 46) : BOOL
48 : bvule(18, 41) : BOOL
49 : bvule(41, 20) : BOOL
50 : and(48, 49) : BOOL
51 : bvule(24, 41) : BOOL
52 : bvule(41, 26) : BOOL
53 : and(51, 52) : BOOL
54 : bvule(30, 41) : BOOL
55 : bvule(41, 32) : BOOL
56 : and(54, 55) : BOOL
57 : ite(56, 29, 29) : BV:8
58 : ite(53, 29, 57) : BV:8
59 : ite(50, 23, 58) : BV:8
60 : ite(47, 17, 59) : BV:8
61 : ite(44, 11, 60) : BV:8
62 : 1 { 0x1 +1.11e129 } : BV:32
63 : bvadd(62, 5) : BV:32
64 : bvule(2, 63) : BOOL
65 : bvule(63, 8) : BOOL
66 : and(64, 65) : BOOL
67 : bvule(12, 63) : BOOL
68 : bvule(63, 14) : BOOL
69 : and(67, 68) : BOOL
70 : bvule(18, 63) : BOOL
71 : bvule(63, 20) : BOOL
72 : and(70, 71) : BOOL
73 : bvule(24, 63) : BOOL
74 : bvule(63, 26) : BOOL
75 : and(73, 74) : BOOL
76 : bvule(30, 63) : BOOL
77 : bvule(63, 32) : BOOL
78 : and(76, 77) : BOOL
79 : ite(78, 29, 29) : BV:8
80 : ite(75, 29, 79) : BV:8
81 : ite(72, 23, 80) : BV:8
82 : ite(69, 17, 81) : BV:8
83 : ite(66, 11, 82) : BV:8
84 : bvule(2, 5) : BOOL
85 : bvule(5, 8) : BOOL
86 : and(84, 85) : BOOL
87 : bvule(12, 5) : BOOL
88 : bvule(5, 14) : BOOL
89 : and(87, 88) : BOOL
90 : bvule(18, 5) : BOOL
91 : bvule(5, 20) : BOOL
92 : and(90, 91) : BOOL
93 : bvule(24, 5) : BOOL
94 : bvule(5, 26) : BOOL
95 : and(93, 94) : BOOL
96 : bvule(30, 5) : BOOL
97 : bvule(5, 32) : BOOL
98 : and(96, 97) : BOOL
99 : ite(98, 29, 29) : BV:8
100 : ite(95, 29, 99) : BV:8
101 : ite(92, 23, 100) : BV:8
102 : ite(89, 17, 101) : BV:8
103 : ite(86, 11, 102) : BV:8
104 : bvconcat(39, 61, 83, 103) : BV:32
105 : lambda(1, 104) : FUNCTION[BV:32 -> BV:32]
106 : sym_const(105) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform207 : BV:32
4 : Lambda2321 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2322 : BV:32
7 : 1013178964 { 0x3c63e254 +1.78034448e249 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda2286 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 0 { 0x0 } : BOOL
8 : ite(6, 7, 7) : BOOL
9 : 3 { 0x3 +1.35e129 } : BV:32
10 : 4 { 0x4 +1.47e129 } : BV:32
11 : bvmul(10, 1) : BV:32
12 : bvadd(9, 11) : BV:32
13 : bvule(2, 12) : BOOL
14 : 1703603503 { 0x658aed2f +1.8536326e76 } : BV:32
15 : bvule(12, 14) : BOOL
16 : and(13, 15) : BOOL
17 : 1 { 0x1 } : BV:8
18 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
19 : bvule(18, 12) : BOOL
20 : 1703603507 { 0x658aed33 +1.8536374e76 } : BV:32
21 : bvule(12, 20) : BOOL
22 : and(19, 21) : BOOL
23 : 4 { 0x4 } : BV:8
24 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
25 : bvule(24, 12) : BOOL
26 : 3726783631 { 0xde22348f -568183665 -1.26722896e61 } : BV:32
27 : bvule(12, 26) : BOOL
28 : and(25, 27) : BOOL
29 : 5 { 0x5 } : BV:8
30 : 1703603508 { 0x658aed34 +1.8536386e76 } : BV:32
31 : bvule(30, 12) : BOOL
32 : 3726783627 { 0xde22348b -568183669 -1.26722848e61 } : BV:32
33 : bvule(12, 32) : BOOL
34 : and(31, 33) : BOOL
35 : 0 { 0x0 } : BV:8
36 : 3726783632 { 0xde223490 -568183664 -1.26722908e61 } : BV:32
37 : bvule(36, 12) : BOOL
38 : bvule(12, 4) : BOOL
39 : and(37, 38) : BOOL
40 : ite(39, 35, 35) : BV:8
41 : ite(34, 35, 40) : BV:8
42 : ite(28, 29, 41) : BV:8
43 : ite(22, 23, 42) : BV:8
44 : ite(16, 17, 43) : BV:8
45 : 2 { 0x2 +1.23e129 } : BV:32
46 : bvadd(45, 11) : BV:32
47 : bvule(2, 46) : BOOL
48 : bvule(46, 14) : BOOL
49 : and(47, 48) : BOOL
50 : bvule(18, 46) : BOOL
51 : bvule(46, 20) : BOOL
52 : and(50, 51) : BOOL
53 : bvule(24, 46) : BOOL
54 : bvule(46, 26) : BOOL
55 : and(53, 54) : BOOL
56 : bvule(30, 46) : BOOL
57 : bvule(46, 32) : BOOL
58 : and(56, 57) : BOOL
59 : bvule(36, 46) : BOOL
60 : bvule(46, 4) : BOOL
61 : and(59, 60) : BOOL
62 : ite(61, 35, 35) : BV:8
63 : ite(58, 35, 62) : BV:8
64 : ite(55, 29, 63) : BV:8
65 : ite(52, 23, 64) : BV:8
66 : ite(49, 17, 65) : BV:8
67 : 1 { 0x1 +1.11e129 } : BV:32
68 : bvadd(67, 11) : BV:32
69 : bvule(2, 68) : BOOL
70 : bvule(68, 14) : BOOL
71 : and(69, 70) : BOOL
72 : bvule(18, 68) : BOOL
73 : bvule(68, 20) : BOOL
74 : and(72, 73) : BOOL
75 : bvule(24, 68) : BOOL
76 : bvule(68, 26) : BOOL
77 : and(75, 76) : BOOL
78 : bvule(30, 68) : BOOL
79 : bvule(68, 32) : BOOL
80 : and(78, 79) : BOOL
81 : bvule(36, 68) : BOOL
82 : bvule(68, 4) : BOOL
83 : and(81, 82) : BOOL
84 : ite(83, 35, 35) : BV:8
85 : ite(80, 35, 84) : BV:8
86 : ite(77, 29, 85) : BV:8
87 : ite(74, 23, 86) : BV:8
88 : ite(71, 17, 87) : BV:8
89 : bvule(2, 11) : BOOL
90 : bvule(11, 14) : BOOL
91 : and(89, 90) : BOOL
92 : bvule(18, 11) : BOOL
93 : bvule(11, 20) : BOOL
94 : and(92, 93) : BOOL
95 : bvule(24, 11) : BOOL
96 : bvule(11, 26) : BOOL
97 : and(95, 96) : BOOL
98 : bvule(30, 11) : BOOL
99 : bvule(11, 32) : BOOL
100 : and(98, 99) : BOOL
101 : bvule(36, 11) : BOOL
102 : bvule(11, 4) : BOOL
103 : and(101, 102) : BOOL
104 : ite(103, 35, 35) : BV:8
105 : ite(100, 35, 104) : BV:8
106 : ite(97, 29, 105) : BV:8
107 : ite(94, 23, 106) : BV:8
108 : ite(91, 17, 107) : BV:8
109 : bvconcat(44, 66, 88, 108) : BV:32
110 : ite(8, 109, 109) : BV:32
111 : lambda(1, 110) : FUNCTION[BV:32 -> BV:32]
112 : sym_const(111) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform206 : BV:32
4 : Lambda2319 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2320 : BV:32
7 : 31754427 { 0x1e488bb +1.78542268e132 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1703603503 ] -> 1, [ 1703603504; 1703603507 ] -> 4, [ 1703603508; 3726783627 ] -> 0, [ 3726783628; 3726783631 ] -> 5, [ 3726783632; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1703603503 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1703603504; 1703603507 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1703603508; 3726783627 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3726783628; 3726783631 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3726783632; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1703603504 { 0x658aed30 +1.8536338e76 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1703603507 { 0x658aed33 +1.8536374e76 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3726783628 { 0xde22348c -568183668 -1.26722860e61 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3726783631 { 0xde22348f -568183665 -1.26722896e61 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1507624908
=counter_example_end
=global nodece 7 num_edges_traversed 0
=global nodece 7 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 8
=global nodece 8 nodece z3v487.ce575.num_edges_traversed0
=global nodece 8 nodece_path
=global nodece 8 nodece_path.graph_edge_composition
(epsilon)
=global nodece 8 nodece_cached_counterexample
=counter_example_begin z3v487.ce575 c786afe612e3ee25108b58c1ce676710
=input.spec-%var-arr-1
1 : Lambda2427 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 127 { 0x7f +1.1513e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 128 { 0x80 +1.1525e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2428 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 128 { 0x80 +1.1525e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda2430 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 127 { 0x7f +1.1513e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 128 { 0x80 +1.1525e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2431 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 127 ] -> true, [ 128; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda2398 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 127 { 0x7f +1.1513e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 128 { 0x80 +1.1525e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform219 : BV:32
4 : Lambda2434 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2435 : BV:32
7 : 566221269 { 0x21bfd9d5 +1.49883520e196 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 127 ] -> true, [ 128; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073780824 { 0x40009858 +1.464916e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform218 : BV:32
4 : Lambda2432 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2433 : BV:32
7 : 1848230130 { 0x6e29c0f2 +1.32620072e93 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 1073780823 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073780824; 1073780827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073780828; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073780824 { 0x40009858 +1.464916e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073780827 { 0x4000985b +1.464951e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
774058481
=counter_example_end
=global nodece 8 num_edges_traversed 0
=global nodece 8 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 9
=global nodece 9 nodece z3.ce576.num_edges_traversed0
=global nodece 9 nodece_path
=global nodece 9 nodece_path.graph_edge_composition
(epsilon)
=global nodece 9 nodece_cached_counterexample
=counter_example_begin z3.ce576 9ebaec6d5f8aaae65d4a39b3cc9673e9
=input.spec-%var-arr-1
1 : Lambda2445 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2446 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda2449 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2450 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform223 : BV:32
4 : Lambda2453 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2454 : BV:32
7 : 711309692 { 0x2a65b97c +1.79472303e213 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda2413 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1 { 0x1 +1.11e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2 { 0x2 +1.23e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3422326488 { 0xcbfc8ed8 -872640808 -1.97310924e24 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2361600584 { 0x8cc32a48 -1933366712 -1.52472782e154 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform222 : BV:32
4 : Lambda2451 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2452 : BV:32
7 : 1915188718 { 0x722775ee +1.30828642e101 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 2361600583 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2361600584; 2361600587 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2361600588; 3422326487 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3422326488; 3422326491 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3422326492; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2361600584 { 0x8cc32a48 -1933366712 -1.52472782e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2361600587 { 0x8cc32a4b -1933366709 -1.52472817e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3422326488 { 0xcbfc8ed8 -872640808 -1.97310924e24 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3422326491 { 0xcbfc8edb -872640805 -1.97310960e24 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
4203459817
=counter_example_end
=global nodece 9 num_edges_traversed 0
=global nodece 9 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 10
=global nodece 10 nodece z3.ce626.num_edges_traversed2
=global nodece 10 nodece_path
=global nodece 10 nodece_path.graph_edge_composition
(epsilon)
=global nodece 10 nodece_cached_counterexample
=counter_example_begin z3.ce626 e424b70d81e20813fa26777b324b176
=input.spec-%var-arr-1
1 : Lambda197 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda198 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda197 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda198 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda176 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda177 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.dst.llvm-%n
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 318648393 { 0x12fe3049 +1.98584854e166 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1903413019 { 0x7173c71b +1.90451371e99 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
340383979
=counter_example_end
=global nodece 10 num_edges_traversed 2
=global nodece 10 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 11
=global nodece 11 nodece z3v487.ce622.num_edges_traversed2
=global nodece 11 nodece_path
=global nodece 11 nodece_path.graph_edge_composition
(epsilon)
=global nodece 11 nodece_cached_counterexample
=counter_example_begin z3v487.ce622 af0ea799eb12e8afeb23e4de7e5414d
=input.spec-%var-arr-1
1 : Lambda211 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda212 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda211 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda212 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda185 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda186 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%n
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 211961543 { 0xca246c7 +1.26778495e154 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 67 { 0x43 +1.798e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3721003027 { 0xddca0013 -573964269 -1.57812726e60 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
180861690
=counter_example_end
=global nodece 11 num_edges_traversed 2
=global nodece 11 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 12
=global nodece 12 nodece z3.ce618.num_edges_traversed2
=global nodece 12 nodece_path
=global nodece 12 nodece_path.graph_edge_composition
(epsilon)
=global nodece 12 nodece_cached_counterexample
=counter_example_begin z3.ce618 2f42f5ddaf7c6fd76b7b5ae3cd04c8e
=input.spec-%var-arr-1
1 : Lambda301 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda302 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda301 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda302 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda280 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda281 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.dst.llvm-%n
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 961465037 { 0x394ecacd +1.61556398e243 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1067701935 { 0x3fa3d6af +1.27998912e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3670926980
=counter_example_end
=global nodece 12 num_edges_traversed 2
=global nodece 12 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 13
=global nodece 13 nodece z3.ce614.num_edges_traversed2
=global nodece 13 nodece_path
=global nodece 13 nodece_path.graph_edge_composition
(epsilon)
=global nodece 13 nodece_cached_counterexample
=counter_example_begin z3.ce614 a850b4b094c19a2d794398a552152982
=input.spec-%var-arr-1
1 : Lambda405 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda406 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda405 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda406 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda384 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : ite(3, 2, 128) : BV:32
130 : lambda(1, 129) : FUNCTION[BV:32 -> BV:32]
131 : sym_const(130) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda385 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : lambda(1, 128) : FUNCTION[BV:32 -> BV:32]
130 : sym_const(129) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.dst.llvm-%n
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1420111171 { 0x54a52d43 +1.29044377e42 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
155419542
=counter_example_end
=global nodece 13 num_edges_traversed 2
=global nodece 13 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 14
=global nodece 14 nodece z3v487.ce606.num_edges_traversed1
=global nodece 14 nodece_path
=global nodece 14 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 14 nodece_cached_counterexample
=counter_example_begin z3v487.ce606 cc3f69df8f16afc59b3fbcaba5e7aa
=input.spec-%var-arr-1
1 : Lambda2427 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 127 { 0x7f +1.1513e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 128 { 0x80 +1.1525e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2428 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 128 { 0x80 +1.1525e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda2430 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 127 { 0x7f +1.1513e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 128 { 0x80 +1.1525e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2431 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 127 ] -> true, [ 128; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda2398 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 127 { 0x7f +1.1513e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 128 { 0x80 +1.1525e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform219 : BV:32
4 : Lambda2434 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2435 : BV:32
7 : 566221269 { 0x21bfd9d5 +1.49883520e196 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 127 ] -> true, [ 128; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073780824 { 0x40009858 +1.464916e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform218 : BV:32
4 : Lambda2432 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2433 : BV:32
7 : 1848230130 { 0x6e29c0f2 +1.32620072e93 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 1073780823 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073780824; 1073780827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073780828; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073780824 { 0x40009858 +1.464916e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073780827 { 0x4000985b +1.464951e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
774058481
=counter_example_end
=global nodece 14 num_edges_traversed 1
=global nodece 14 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 15
=global nodece 15 nodece z3.ce602.num_edges_traversed1
=global nodece 15 nodece_path
=global nodece 15 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 15 nodece_cached_counterexample
=counter_example_begin z3.ce602 21d97c1a53f7f0fbf0b82e8edaf318b3
=input.spec-%var-arr-1
1 : Lambda2445 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2446 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda2449 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2450 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform223 : BV:32
4 : Lambda2453 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2454 : BV:32
7 : 711309692 { 0x2a65b97c +1.79472303e213 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda2413 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1 { 0x1 +1.11e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2 { 0x2 +1.23e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3422326488 { 0xcbfc8ed8 -872640808 -1.97310924e24 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2361600584 { 0x8cc32a48 -1933366712 -1.52472782e154 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform222 : BV:32
4 : Lambda2451 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2452 : BV:32
7 : 1915188718 { 0x722775ee +1.30828642e101 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 2361600583 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2361600584; 2361600587 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2361600588; 3422326487 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3422326488; 3422326491 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3422326492; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2361600584 { 0x8cc32a48 -1933366712 -1.52472782e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2361600587 { 0x8cc32a4b -1933366709 -1.52472817e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3422326488 { 0xcbfc8ed8 -872640808 -1.97310924e24 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3422326491 { 0xcbfc8edb -872640805 -1.97310960e24 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
4203459817
=counter_example_end
=global nodece 15 num_edges_traversed 1
=global nodece 15 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 16
=global nodece 16 nodece z3.ce845.num_edges_traversed1
=global nodece 16 nodece_path
=global nodece 16 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 16 nodece_cached_counterexample
=counter_example_begin z3.ce845 328db923aefd81d8cb8ffcbe25c28
=input.spec-%var-arr-1
1 : Lambda3645 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda3646 : BV:32
17 : eq(16, 2) : BOOL
18 : bvule(2, 16) : BOOL
19 : bvule(16, 2) : BOOL
20 : and(18, 19) : BOOL
21 : bvule(7, 16) : BOOL
22 : bvule(16, 9) : BOOL
23 : and(21, 22) : BOOL
24 : ite(23, 12, 12) : BOOL
25 : ite(20, 6, 24) : BOOL
26 : and(18, 22) : BOOL
27 : ite(26, 2, 2) : BV:32
28 : ite(25, 2, 27) : BV:32
29 : ite(17, 2, 28) : BV:32
30 : lambda(16, 29) : FUNCTION[BV:32 -> BV:32]
31 : map(15, 30) : MAP[BV:32 -> BV:32]
32 : sym_const(31) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda3649 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda3650 : BV:32
17 : bvule(2, 16) : BOOL
18 : bvule(16, 9) : BOOL
19 : and(17, 18) : BOOL
20 : ite(19, 2, 2) : BV:32
21 : lambda(16, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(15, 21) : MAP[BV:32 -> BV:32]
23 : sym_const(22) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform323 : BV:32
4 : Lambda3653 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3654 : BV:32
7 : 1420389612 { 0x54a96cec +1.32363653e42 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda3621 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : bvule(1, 2) : BOOL
6 : and(4, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1 { 0x1 +1.11e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : and(4, 11) : BOOL
17 : ite(16, 2, 2) : BV:32
18 : ite(15, 2, 17) : BV:32
19 : ite(3, 2, 18) : BV:32
20 : lambda(1, 19) : FUNCTION[BV:32 -> BV:32]
21 : sym_const(20) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1573751912 { 0x5dcd8c68 +1.60584735e60 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2429225352 { 0x90cb0988 -1865741944 -1.58622837e162 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform322 : BV:32
4 : Lambda3651 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3652 : BV:32
7 : 902062917 { 0x35c46345 +1.53427946e236 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1573751911 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1573751912; 1573751915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1573751916; 2147483641 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483642; 2429225351 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2429225352; 2429225355 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2429225356; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2147483642 { 0x7ffffffa +1.99999928e128 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2429225352 { 0x90cb0988 -1865741944 -1.58622837e162 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2429225355 { 0x90cb098b -1865741941 -1.58622872e162 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1573751912 { 0x5dcd8c68 +1.60584735e60 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1573751915 { 0x5dcd8c6b +1.60584771e60 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1061171499
=counter_example_end
=global nodece 16 num_edges_traversed 1
=global nodece 16 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 17
=global nodece 17 nodece z3.ce867.num_edges_traversed1
=global nodece 17 nodece_path
=global nodece 17 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 17 nodece_cached_counterexample
=counter_example_begin z3.ce867 b5d2a77de08d29cc8ffc96292fb87a9
=input.spec-%var-arr-1
1 : Lambda3773 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3774 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda3777 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3778 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform339 : BV:32
4 : Lambda3781 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3782 : BV:32
7 : 2027212428 { 0x78d4ce8c +1.66255331e114 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda3749 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 547649092 { 0x20a47644 +1.28485918e194 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1929044644 { 0x72fae2a4 +1.96004152e102 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform338 : BV:32
4 : Lambda3779 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3780 : BV:32
7 : 1775239482 { 0x69d0013a +1.62503743e84 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 547649091 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 547649092; 547649095 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 547649096; 1929044643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1929044644; 1929044647 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1929044648; 3992977400 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3992977401; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 3992977401 { 0xedfffff9 -301989895 -1.99999916e92 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1929044644 { 0x72fae2a4 +1.96004152e102 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1929044647 { 0x72fae2a7 +1.96004188e102 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 547649092 { 0x20a47644 +1.28485918e194 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 547649095 { 0x20a47647 +1.28485953e194 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1461632622
=counter_example_end
=global nodece 17 num_edges_traversed 1
=global nodece 17 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 18
=global nodece 18 nodece z3v487.ce889.num_edges_traversed1
=global nodece 18 nodece_path
=global nodece 18 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 18 nodece_cached_counterexample
=counter_example_begin z3v487.ce889 a05054f03bbc13591d724cbd66f1a52
=input.spec-%var-arr-1
1 : Lambda3902 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3903 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda3905 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3906 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda3873 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform355 : BV:32
4 : Lambda3909 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3910 : BV:32
7 : 1392596878 { 0x5301578e +1.1048445e39 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 33558532 { 0x2001004 +1.48875e133 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform354 : BV:32
4 : Lambda3907 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3908 : BV:32
7 : 1110086872 { 0x422a94d8 +1.33266735e5 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 33558531 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 33558532; 33558535 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 33558536; 268440063 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268440064; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 268440064 { 0x10001200 +1.54931e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 33558532 { 0x2001004 +1.48875e133 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 33558535 { 0x2001007 +1.48911e133 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
807284317
=counter_example_end
=global nodece 18 num_edges_traversed 1
=global nodece 18 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 19
=global nodece 19 nodece z3v487.ce911.num_edges_traversed1
=global nodece 19 nodece_path
=global nodece 19 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 19 nodece_cached_counterexample
=counter_example_begin z3v487.ce911 3ebe68b6e359d509ba6b2b61efe2c90
=input.spec-%var-arr-1
1 : Lambda4030 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4031 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4033 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4034 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda4001 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform371 : BV:32
4 : Lambda4037 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4038 : BV:32
7 : 1425493977 { 0x54f74fd9 +1.93212425e42 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 33558532 { 0x2001004 +1.48875e133 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform370 : BV:32
4 : Lambda4035 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4036 : BV:32
7 : 66777319 { 0x3faf0e7 +1.96047675e136 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 33558531 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 33558532; 33558535 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 33558536; 268440063 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268440064; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 268440064 { 0x10001200 +1.54931e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 33558532 { 0x2001004 +1.48875e133 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 33558535 { 0x2001007 +1.48911e133 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
143029951
=counter_example_end
=global nodece 19 num_edges_traversed 1
=global nodece 19 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 20
=global nodece 20 nodece z3v487.ce933.num_edges_traversed1
=global nodece 20 nodece_path
=global nodece 20 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 20 nodece_cached_counterexample
=counter_example_begin z3v487.ce933 f77760a87286d2bba044ddf1e3b19cd
=input.spec-%var-arr-1
1 : Lambda4158 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4159 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4161 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4162 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda4129 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 262144 { 0x40000 +1.3125000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform387 : BV:32
4 : Lambda4165 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4166 : BV:32
7 : 726752389 { 0x2b515c85 +1.63563597e215 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 286925600 { 0x111a2320 +1.20419692e163 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform386 : BV:32
4 : Lambda4163 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4164 : BV:32
7 : 830619005 { 0x31823d7d +1.1750147e228 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 286925599 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 286925600; 286925603 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 286925604; 1073741817 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073741818; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1073741818 { 0x3ffffffa +1.99999928e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 286925600 { 0x111a2320 +1.20419692e163 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 286925603 { 0x111a2323 +1.20419728e163 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1870033691
=counter_example_end
=global nodece 20 num_edges_traversed 1
=global nodece 20 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 21
=global nodece 21 nodece z3.ce955.num_edges_traversed1
=global nodece 21 nodece_path
=global nodece 21 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 21 nodece_cached_counterexample
=counter_example_begin z3.ce955 3444e2c7f557e121d2785d9bd6e84bf3
=input.spec-%var-arr-1
1 : Lambda4285 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda4286 : BV:32
17 : eq(16, 2) : BOOL
18 : bvule(2, 16) : BOOL
19 : bvule(16, 4) : BOOL
20 : and(18, 19) : BOOL
21 : bvule(8, 16) : BOOL
22 : bvule(16, 8) : BOOL
23 : and(21, 22) : BOOL
24 : ite(23, 12, 12) : BOOL
25 : ite(20, 7, 24) : BOOL
26 : and(18, 22) : BOOL
27 : ite(26, 2, 2) : BV:32
28 : ite(25, 2, 27) : BV:32
29 : ite(17, 2, 28) : BV:32
30 : lambda(16, 29) : FUNCTION[BV:32 -> BV:32]
31 : map(15, 30) : MAP[BV:32 -> BV:32]
32 : sym_const(31) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4289 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda4290 : BV:32
17 : bvule(2, 16) : BOOL
18 : bvule(16, 8) : BOOL
19 : and(17, 18) : BOOL
20 : ite(19, 2, 2) : BV:32
21 : lambda(16, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(15, 21) : MAP[BV:32 -> BV:32]
23 : sym_const(22) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform403 : BV:32
4 : Lambda4293 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4294 : BV:32
7 : 1478519149 { 0x5820696d +1.25321733e49 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda4261 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(9, 1) : BOOL
11 : bvule(1, 9) : BOOL
12 : and(10, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(7, 8, 14) : BOOL
16 : and(4, 11) : BOOL
17 : ite(16, 2, 2) : BV:32
18 : ite(15, 2, 17) : BV:32
19 : ite(3, 2, 18) : BV:32
20 : lambda(1, 19) : FUNCTION[BV:32 -> BV:32]
21 : sym_const(20) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1201995804 { 0x47a5001c +1.28906583e16 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2122317824 { 0x7e800000 +1.0e126 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform402 : BV:32
4 : Lambda4291 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4292 : BV:32
7 : 1300700231 { 0x4d871c47 +1.5555045e28 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1201995803 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1201995804; 1201995807 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1201995808; 2122317823 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2122317824; 2122317827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2122317828; 2147483640 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483641; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 2147483641 { 0x7ffffff9 +1.99999916e128 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2122317824 { 0x7e800000 +1.0e126 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2122317827 { 0x7e800003 +1.35e126 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1201995804 { 0x47a5001c +1.28906583e16 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1201995807 { 0x47a5001f +1.28906619e16 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1501824498
=counter_example_end
=global nodece 21 num_edges_traversed 1
=global nodece 21 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 22
=global nodece 22 nodece z3v487.ce1219.num_edges_traversed0
=global nodece 22 nodece_path
=global nodece 22 nodece_path.graph_edge_composition
(epsilon)
=global nodece 22 nodece_cached_counterexample
=counter_example_begin z3v487.ce1219 d620e920b0f92969a4bb15119ff667db
=input.spec-%var-arr-1
1 : Lambda6276 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6277 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6279 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6280 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda6247 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform655 : BV:32
4 : Lambda6283 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6284 : BV:32
7 : 1465597879 { 0x575b3fb7 +1.71288192e47 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 670240 { 0xa3a20 +1.7989883e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform654 : BV:32
4 : Lambda6281 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6282 : BV:32
7 : 575060166 { 0x2246b8c6 +1.55251383e197 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 670239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 670240; 670243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 670244; 2147483647 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 670240 { 0xa3a20 +1.7989883e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 670243 { 0xa3a23 +1.7989919e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2853395271
=counter_example_end
=global nodece 22 num_edges_traversed 0
=global nodece 22 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 23
=global nodece 23 nodece z3.ce1220.num_edges_traversed0
=global nodece 23 nodece_path
=global nodece 23 nodece_path.graph_edge_composition
(epsilon)
=global nodece 23 nodece_cached_counterexample
=counter_example_begin z3.ce1220 e31a288c3b29aaa26d4dc7a917a7ad3
=input.spec-%var-arr-1
1 : Lambda6294 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6295 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda6298 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda6299 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1073741823 ] -> true, [ 1073741824; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform659 : BV:32
4 : Lambda6302 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6303 : BV:32
7 : 359241205 { 0x156995f5 +1.82488882e171 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1073741823 ] -> true, [ 1073741824; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda6262 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3746770640 { 0xdf532ed0 -548196656 -1.64986610e63 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3938124852 { 0xeabb0434 -356842444 -1.46106576e86 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4096 { 0x1000 +1.48828e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform658 : BV:32
4 : Lambda6300 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda6301 : BV:32
7 : 137573699 { 0x8333543 +1.40006291e145 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3746770639 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3746770640; 3746770643 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3746770644; 3938124851 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3938124852; 3938124855 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3938124856; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3938124852 { 0xeabb0434 -356842444 -1.46106576e86 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3938124855 { 0xeabb0437 -356842441 -1.46106612e86 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3746770640 { 0xdf532ed0 -548196656 -1.64986610e63 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3746770643 { 0xdf532ed3 -548196653 -1.64986646e63 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3253571006
=counter_example_end
=global nodece 23 num_edges_traversed 0
=global nodece 23 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 24
=global nodece 24 nodece z3.ce1262.num_edges_traversed3
=global nodece 24 nodece_path
=global nodece 24 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 24 nodece_cached_counterexample
=counter_example_begin z3.ce1262 44584e4a018913cb244b73148fc66b
=nextpc_const.1
1 : 1152738630 { 0x44b56546 +1.41715312e10 } : BV:32
=input.spec-%var-arr-1
1 : Lambda197 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda198 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda197 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 150402805 { 0x8f6f6f5 +1.92941153e146 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda198 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
27 : eq(23, 26) : BOOL
28 : 251 { 0xfb -5 } : BV:8
29 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
30 : eq(23, 29) : BOOL
31 : 189 { 0xbd -67 } : BV:8
32 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
33 : eq(23, 32) : BOOL
34 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
35 : eq(23, 34) : BOOL
36 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
37 : eq(23, 36) : BOOL
38 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
39 : eq(23, 38) : BOOL
40 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
41 : eq(23, 40) : BOOL
42 : 8 { 0x8 } : BV:8
43 : 246 { 0xf6 -10 } : BV:8
44 : ite(41, 42, 43) : BV:8
45 : ite(39, 25, 44) : BV:8
46 : ite(37, 25, 45) : BV:8
47 : ite(35, 25, 46) : BV:8
48 : ite(33, 25, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 34) : BOOL
59 : eq(53, 36) : BOOL
60 : eq(53, 38) : BOOL
61 : eq(53, 40) : BOOL
62 : ite(61, 42, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 25, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 34) : BOOL
77 : eq(71, 36) : BOOL
78 : eq(71, 38) : BOOL
79 : eq(71, 40) : BOOL
80 : ite(79, 42, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 25, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 34) : BOOL
94 : eq(88, 36) : BOOL
95 : eq(88, 38) : BOOL
96 : eq(88, 40) : BOOL
97 : ite(96, 42, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 25, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda176 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 150402805 ] -> true, [ 150402806; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda177 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1903413017 { 0x7173c719 +1.90451347e99 } : BV:32
12 : eq(8, 11) : BOOL
13 : 251 { 0xfb -5 } : BV:8
14 : 1903413018 { 0x7173c71a +1.90451359e99 } : BV:32
15 : eq(8, 14) : BOOL
16 : 189 { 0xbd -67 } : BV:8
17 : 4139645699 { 0xf6bdfb03 -155321597 -1.48422276e110 } : BV:32
18 : eq(8, 17) : BOOL
19 : 4139645698 { 0xf6bdfb02 -155321598 -1.48422265e110 } : BV:32
20 : eq(8, 19) : BOOL
21 : 4139645697 { 0xf6bdfb01 -155321599 -1.48422253e110 } : BV:32
22 : eq(8, 21) : BOOL
23 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
24 : eq(8, 23) : BOOL
25 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
26 : eq(8, 25) : BOOL
27 : 8 { 0x8 } : BV:8
28 : 246 { 0xf6 -10 } : BV:8
29 : ite(26, 27, 28) : BV:8
30 : ite(24, 10, 29) : BV:8
31 : ite(22, 10, 30) : BV:8
32 : ite(20, 10, 31) : BV:8
33 : ite(18, 10, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 19) : BOOL
44 : eq(38, 21) : BOOL
45 : eq(38, 23) : BOOL
46 : eq(38, 25) : BOOL
47 : ite(46, 27, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 10, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 19) : BOOL
62 : eq(56, 21) : BOOL
63 : eq(56, 23) : BOOL
64 : eq(56, 25) : BOOL
65 : ite(64, 27, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 10, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 19) : BOOL
79 : eq(73, 21) : BOOL
80 : eq(73, 23) : BOOL
81 : eq(73, 25) : BOOL
82 : ite(81, 27, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 10, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.dst.llvm-%n
1 : 150402806 { 0x8f6f6f6 +1.92941164e146 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4139645696 { 0xf6bdfb00 -155321600 -1.48422241e110 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 123 , m_adder -> 42), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1152738630 , 1000 , 8 ) -> 44611973, () -> 1256379572, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 318648393 { 0x12fe3049 +1.98584854e166 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1903413015 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1903413016; 1903413019 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1903413020; 3537734447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3537734448; 3537734451 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3537734452; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1903413015 ] -> 246, [ 1903413016; 1903413016 ] -> 0, [ 1903413017; 1903413017 ] -> 251, [ 1903413018; 1903413018 ] -> 189, [ 1903413019; 3537734450 ] -> 246, [ 3537734451; 3537734451 ] -> 8, [ 3537734452; 4139645695 ] -> 246, [ 4139645696; 4139645699 ] -> 0, [ 4139645700; 4294967295 ] -> 246, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 44611973 { 0x2a8b985 +1.31816160e134 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3537734448 { 0xd2dd8b30 -757232848 -1.73081016e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3537734451 { 0xd2dd8b33 -757232845 -1.73081052e38 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1903413016 { 0x7173c718 +1.90451335e99 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1903413019 { 0x7173c71b +1.90451371e99 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 123 , m_adder -> 42), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2543366799
=counter_example_end
=global nodece 24 num_edges_traversed 3
=global nodece 24 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 25
=global nodece 25 nodece z3v487.ce1259.num_edges_traversed3
=global nodece 25 nodece_path
=global nodece 25 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 25 nodece_cached_counterexample
=counter_example_begin z3v487.ce1259 b585facf906c497c4aa68e2e6b81a25
=nextpc_const.1
1 : 367123356 { 0x15e1db9c +1.76451444e172 } : BV:32
=input.spec-%var-arr-1
1 : Lambda211 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda212 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda211 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda212 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 17) : BV:32
21 : bvadd(18, 20, 2) : BV:32
22 : 66 { 0x42 +1.786e129 } : BV:32
23 : eq(21, 22) : BOOL
24 : 4 { 0x4 } : BV:8
25 : 0 { 0x0 } : BV:8
26 : ite(23, 24, 25) : BV:8
27 : 2 { 0x2 +1.23e129 } : BV:32
28 : bvadd(27, 20, 2) : BV:32
29 : eq(28, 22) : BOOL
30 : ite(29, 24, 25) : BV:8
31 : 1 { 0x1 +1.11e129 } : BV:32
32 : bvadd(31, 20, 2) : BV:32
33 : eq(32, 22) : BOOL
34 : ite(33, 24, 25) : BV:8
35 : bvadd(20, 2) : BV:32
36 : eq(35, 22) : BOOL
37 : ite(36, 24, 25) : BV:8
38 : bvconcat(26, 30, 34, 37) : BV:32
39 : lambda(17, 38) : FUNCTION[BV:32 -> BV:32]
40 : map(16, 39) : MAP[BV:32 -> BV:32]
41 : sym_const(40) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda185 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda186 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : 4 { 0x4 +1.47e129 } : BV:32
4 : bvmul(3, 1) : BV:32
5 : 0 { 0x0 +1.0e129 } : BV:32
6 : bvadd(2, 4, 5) : BV:32
7 : 66 { 0x42 +1.786e129 } : BV:32
8 : eq(6, 7) : BOOL
9 : 4 { 0x4 } : BV:8
10 : 0 { 0x0 } : BV:8
11 : ite(8, 9, 10) : BV:8
12 : 2 { 0x2 +1.23e129 } : BV:32
13 : bvadd(12, 4, 5) : BV:32
14 : eq(13, 7) : BOOL
15 : ite(14, 9, 10) : BV:8
16 : 1 { 0x1 +1.11e129 } : BV:32
17 : bvadd(16, 4, 5) : BV:32
18 : eq(17, 7) : BOOL
19 : ite(18, 9, 10) : BV:8
20 : bvadd(4, 5) : BV:32
21 : eq(20, 7) : BOOL
22 : ite(21, 9, 10) : BV:8
23 : bvconcat(11, 15, 19, 22) : BV:32
24 : lambda(1, 23) : FUNCTION[BV:32 -> BV:32]
25 : sym_const(24) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%n
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 67 , m_adder -> 72), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 367123356 , 1000 , 8 ) -> 1441260588, () -> 1296167743, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 211961543 { 0xca246c7 +1.26778495e154 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 63 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 64; 67 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 68; 3721003023 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3721003024; 3721003027 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3721003028; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 65 ] -> 0, [ 66; 66 ] -> 4, [ 67; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1441260588 { 0x55e7e42c +1.81165075e44 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 67 { 0x43 +1.798e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3721003024 { 0xddca0010 -573964272 -1.57812690e60 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3721003027 { 0xddca0013 -573964269 -1.57812726e60 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 67 , m_adder -> 72), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2976315566
=counter_example_end
=global nodece 25 num_edges_traversed 3
=global nodece 25 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 26
=global nodece 26 nodece z3.ce1256.num_edges_traversed3
=global nodece 26 nodece_path
=global nodece 26 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 26 nodece_cached_counterexample
=counter_example_begin z3.ce1256 b25e7746a231ac9dcfc2caa99545a55c
=nextpc_const.1
1 : 1073352277 { 0x3ffa0e55 +1.95356237e0 } : BV:32
=input.spec-%var-arr-1
1 : Lambda301 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda302 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda301 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4076007936 { 0xf2f2f200 -218959360 -1.89801025e102 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda302 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
23 : bvadd(19, 21, 22) : BV:32
24 : eq(23, 22) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
27 : eq(23, 26) : BOOL
28 : 1 { 0x1 } : BV:8
29 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
30 : eq(23, 29) : BOOL
31 : 255 { 0xff -1 } : BV:8
32 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
33 : eq(23, 32) : BOOL
34 : 158 { 0x9e -98 } : BV:8
35 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
36 : eq(23, 35) : BOOL
37 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
38 : eq(23, 37) : BOOL
39 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
40 : eq(23, 39) : BOOL
41 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
42 : eq(23, 41) : BOOL
43 : 242 { 0xf2 -14 } : BV:8
44 : ite(42, 25, 43) : BV:8
45 : ite(40, 25, 44) : BV:8
46 : ite(38, 25, 45) : BV:8
47 : ite(36, 25, 46) : BV:8
48 : ite(33, 34, 47) : BV:8
49 : ite(30, 31, 48) : BV:8
50 : ite(27, 28, 49) : BV:8
51 : ite(24, 25, 50) : BV:8
52 : 2 { 0x2 +1.23e129 } : BV:32
53 : bvadd(52, 21, 22) : BV:32
54 : eq(53, 22) : BOOL
55 : eq(53, 26) : BOOL
56 : eq(53, 29) : BOOL
57 : eq(53, 32) : BOOL
58 : eq(53, 35) : BOOL
59 : eq(53, 37) : BOOL
60 : eq(53, 39) : BOOL
61 : eq(53, 41) : BOOL
62 : ite(61, 25, 43) : BV:8
63 : ite(60, 25, 62) : BV:8
64 : ite(59, 25, 63) : BV:8
65 : ite(58, 25, 64) : BV:8
66 : ite(57, 34, 65) : BV:8
67 : ite(56, 31, 66) : BV:8
68 : ite(55, 28, 67) : BV:8
69 : ite(54, 25, 68) : BV:8
70 : 1 { 0x1 +1.11e129 } : BV:32
71 : bvadd(70, 21, 22) : BV:32
72 : eq(71, 22) : BOOL
73 : eq(71, 26) : BOOL
74 : eq(71, 29) : BOOL
75 : eq(71, 32) : BOOL
76 : eq(71, 35) : BOOL
77 : eq(71, 37) : BOOL
78 : eq(71, 39) : BOOL
79 : eq(71, 41) : BOOL
80 : ite(79, 25, 43) : BV:8
81 : ite(78, 25, 80) : BV:8
82 : ite(77, 25, 81) : BV:8
83 : ite(76, 25, 82) : BV:8
84 : ite(75, 34, 83) : BV:8
85 : ite(74, 31, 84) : BV:8
86 : ite(73, 28, 85) : BV:8
87 : ite(72, 25, 86) : BV:8
88 : bvadd(21, 22) : BV:32
89 : eq(88, 22) : BOOL
90 : eq(88, 26) : BOOL
91 : eq(88, 29) : BOOL
92 : eq(88, 32) : BOOL
93 : eq(88, 35) : BOOL
94 : eq(88, 37) : BOOL
95 : eq(88, 39) : BOOL
96 : eq(88, 41) : BOOL
97 : ite(96, 25, 43) : BV:8
98 : ite(95, 25, 97) : BV:8
99 : ite(94, 25, 98) : BV:8
100 : ite(93, 25, 99) : BV:8
101 : ite(92, 34, 100) : BV:8
102 : ite(91, 31, 101) : BV:8
103 : ite(90, 28, 102) : BV:8
104 : ite(89, 25, 103) : BV:8
105 : bvconcat(51, 69, 87, 104) : BV:32
106 : ite(18, 2, 105) : BV:32
107 : lambda(17, 106) : FUNCTION[BV:32 -> BV:32]
108 : map(16, 107) : MAP[BV:32 -> BV:32]
109 : sym_const(108) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda280 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : ite(3, 2, 91) : BV:32
93 : lambda(1, 92) : FUNCTION[BV:32 -> BV:32]
94 : sym_const(93) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4076007936 ] -> true, [ 4076007937; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda281 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
12 : eq(8, 11) : BOOL
13 : 1 { 0x1 } : BV:8
14 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
15 : eq(8, 14) : BOOL
16 : 255 { 0xff -1 } : BV:8
17 : 1597390393 { 0x5f363e39 +1.42377388e63 } : BV:32
18 : eq(8, 17) : BOOL
19 : 158 { 0x9e -98 } : BV:8
20 : 4294090243 { 0xfff29e03 -877053 -1.89544713e128 } : BV:32
21 : eq(8, 20) : BOOL
22 : 4294090242 { 0xfff29e02 -877054 -1.89544701e128 } : BV:32
23 : eq(8, 22) : BOOL
24 : 4294090241 { 0xfff29e01 -877055 -1.89544689e128 } : BV:32
25 : eq(8, 24) : BOOL
26 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
27 : eq(8, 26) : BOOL
28 : 242 { 0xf2 -14 } : BV:8
29 : ite(27, 10, 28) : BV:8
30 : ite(25, 10, 29) : BV:8
31 : ite(23, 10, 30) : BV:8
32 : ite(21, 10, 31) : BV:8
33 : ite(18, 19, 32) : BV:8
34 : ite(15, 16, 33) : BV:8
35 : ite(12, 13, 34) : BV:8
36 : ite(9, 10, 35) : BV:8
37 : 2 { 0x2 +1.23e129 } : BV:32
38 : bvadd(37, 6, 7) : BV:32
39 : eq(38, 7) : BOOL
40 : eq(38, 11) : BOOL
41 : eq(38, 14) : BOOL
42 : eq(38, 17) : BOOL
43 : eq(38, 20) : BOOL
44 : eq(38, 22) : BOOL
45 : eq(38, 24) : BOOL
46 : eq(38, 26) : BOOL
47 : ite(46, 10, 28) : BV:8
48 : ite(45, 10, 47) : BV:8
49 : ite(44, 10, 48) : BV:8
50 : ite(43, 10, 49) : BV:8
51 : ite(42, 19, 50) : BV:8
52 : ite(41, 16, 51) : BV:8
53 : ite(40, 13, 52) : BV:8
54 : ite(39, 10, 53) : BV:8
55 : 1 { 0x1 +1.11e129 } : BV:32
56 : bvadd(55, 6, 7) : BV:32
57 : eq(56, 7) : BOOL
58 : eq(56, 11) : BOOL
59 : eq(56, 14) : BOOL
60 : eq(56, 17) : BOOL
61 : eq(56, 20) : BOOL
62 : eq(56, 22) : BOOL
63 : eq(56, 24) : BOOL
64 : eq(56, 26) : BOOL
65 : ite(64, 10, 28) : BV:8
66 : ite(63, 10, 65) : BV:8
67 : ite(62, 10, 66) : BV:8
68 : ite(61, 10, 67) : BV:8
69 : ite(60, 19, 68) : BV:8
70 : ite(59, 16, 69) : BV:8
71 : ite(58, 13, 70) : BV:8
72 : ite(57, 10, 71) : BV:8
73 : bvadd(6, 7) : BV:32
74 : eq(73, 7) : BOOL
75 : eq(73, 11) : BOOL
76 : eq(73, 14) : BOOL
77 : eq(73, 17) : BOOL
78 : eq(73, 20) : BOOL
79 : eq(73, 22) : BOOL
80 : eq(73, 24) : BOOL
81 : eq(73, 26) : BOOL
82 : ite(81, 10, 28) : BV:8
83 : ite(80, 10, 82) : BV:8
84 : ite(79, 10, 83) : BV:8
85 : ite(78, 10, 84) : BV:8
86 : ite(77, 19, 85) : BV:8
87 : ite(76, 16, 86) : BV:8
88 : ite(75, 13, 87) : BV:8
89 : ite(74, 10, 88) : BV:8
90 : bvconcat(36, 54, 72, 89) : BV:32
91 : ite(3, 2, 90) : BV:32
92 : lambda(1, 91) : FUNCTION[BV:32 -> BV:32]
93 : sym_const(92) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.dst.llvm-%n
1 : 4076007937 { 0xf2f2f201 -218959359 -1.89801037e102 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4294090240 { 0xfff29e00 -877056 -1.89544677e128 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 19 , m_adder -> 184), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1073352277 , 1000 , 8 ) -> 1081939524, () -> 880111664, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 961465037 { 0x394ecacd +1.61556398e243 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1067701931 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1067701932; 1067701935 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1067701936; 1597390391 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1597390392; 1597390395 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1597390396; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1067701931 ] -> 242, [ 1067701932; 1067701932 ] -> 1, [ 1067701933; 1597390391 ] -> 242, [ 1597390392; 1597390392 ] -> 0, [ 1597390393; 1597390393 ] -> 158, [ 1597390394; 1597390394 ] -> 242, [ 1597390395; 1597390395 ] -> 255, [ 1597390396; 4294090239 ] -> 242, [ 4294090240; 4294090243 ] -> 0, [ 4294090244; 4294967295 ] -> 242, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1081939524 { 0x407d1644 +1.97724199e1 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1067701932 { 0x3fa3d6ac +1.27998876e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1067701935 { 0x3fa3d6af +1.27998912e0 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1597390392 { 0x5f363e38 +1.42377376e63 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1597390395 { 0x5f363e3b +1.42377412e63 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 19 , m_adder -> 184), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
427727256
=counter_example_end
=global nodece 26 num_edges_traversed 3
=global nodece 26 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 27
=global nodece 27 nodece z3.ce1253.num_edges_traversed3
=global nodece 27 nodece_path
=global nodece 27 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 27 nodece_cached_counterexample
=counter_example_begin z3.ce1253 8891f6324ec5caf84806298ae4f396
=nextpc_const.1
1 : 2108327072 { 0x7daa84a0 +1.33217239e124 } : BV:32
=input.spec-%var-arr-1
1 : Lambda405 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda406 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda405 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda406 : BV:32
17 : eq(16, 2) : BOOL
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : 4 { 0x4 +1.47e129 } : BV:32
20 : bvmul(19, 16) : BV:32
21 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
22 : bvadd(18, 20, 21) : BV:32
23 : eq(22, 21) : BOOL
24 : 0 { 0x0 } : BV:8
25 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
26 : eq(22, 25) : BOOL
27 : 255 { 0xff -1 } : BV:8
28 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
29 : eq(22, 28) : BOOL
30 : 237 { 0xed -19 } : BV:8
31 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
32 : eq(22, 31) : BOOL
33 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
34 : eq(22, 33) : BOOL
35 : 94 { 0x5e } : BV:8
36 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
37 : eq(22, 36) : BOOL
38 : 131 { 0x83 -125 } : BV:8
39 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
40 : eq(22, 39) : BOOL
41 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
42 : eq(22, 41) : BOOL
43 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
44 : eq(22, 43) : BOOL
45 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
46 : eq(22, 45) : BOOL
47 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
48 : eq(22, 47) : BOOL
49 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
50 : eq(22, 49) : BOOL
51 : 5 { 0x5 } : BV:8
52 : ite(50, 27, 51) : BV:8
53 : ite(48, 24, 52) : BV:8
54 : ite(46, 24, 53) : BV:8
55 : ite(44, 24, 54) : BV:8
56 : ite(42, 27, 55) : BV:8
57 : ite(40, 24, 56) : BV:8
58 : ite(37, 38, 57) : BV:8
59 : ite(34, 35, 58) : BV:8
60 : ite(32, 27, 59) : BV:8
61 : ite(29, 30, 60) : BV:8
62 : ite(26, 27, 61) : BV:8
63 : ite(23, 24, 62) : BV:8
64 : 2 { 0x2 +1.23e129 } : BV:32
65 : bvadd(64, 20, 21) : BV:32
66 : eq(65, 21) : BOOL
67 : eq(65, 25) : BOOL
68 : eq(65, 28) : BOOL
69 : eq(65, 31) : BOOL
70 : eq(65, 33) : BOOL
71 : eq(65, 36) : BOOL
72 : eq(65, 39) : BOOL
73 : eq(65, 41) : BOOL
74 : eq(65, 43) : BOOL
75 : eq(65, 45) : BOOL
76 : eq(65, 47) : BOOL
77 : eq(65, 49) : BOOL
78 : ite(77, 27, 51) : BV:8
79 : ite(76, 24, 78) : BV:8
80 : ite(75, 24, 79) : BV:8
81 : ite(74, 24, 80) : BV:8
82 : ite(73, 27, 81) : BV:8
83 : ite(72, 24, 82) : BV:8
84 : ite(71, 38, 83) : BV:8
85 : ite(70, 35, 84) : BV:8
86 : ite(69, 27, 85) : BV:8
87 : ite(68, 30, 86) : BV:8
88 : ite(67, 27, 87) : BV:8
89 : ite(66, 24, 88) : BV:8
90 : 1 { 0x1 +1.11e129 } : BV:32
91 : bvadd(90, 20, 21) : BV:32
92 : eq(91, 21) : BOOL
93 : eq(91, 25) : BOOL
94 : eq(91, 28) : BOOL
95 : eq(91, 31) : BOOL
96 : eq(91, 33) : BOOL
97 : eq(91, 36) : BOOL
98 : eq(91, 39) : BOOL
99 : eq(91, 41) : BOOL
100 : eq(91, 43) : BOOL
101 : eq(91, 45) : BOOL
102 : eq(91, 47) : BOOL
103 : eq(91, 49) : BOOL
104 : ite(103, 27, 51) : BV:8
105 : ite(102, 24, 104) : BV:8
106 : ite(101, 24, 105) : BV:8
107 : ite(100, 24, 106) : BV:8
108 : ite(99, 27, 107) : BV:8
109 : ite(98, 24, 108) : BV:8
110 : ite(97, 38, 109) : BV:8
111 : ite(96, 35, 110) : BV:8
112 : ite(95, 27, 111) : BV:8
113 : ite(94, 30, 112) : BV:8
114 : ite(93, 27, 113) : BV:8
115 : ite(92, 24, 114) : BV:8
116 : bvadd(20, 21) : BV:32
117 : eq(116, 21) : BOOL
118 : eq(116, 25) : BOOL
119 : eq(116, 28) : BOOL
120 : eq(116, 31) : BOOL
121 : eq(116, 33) : BOOL
122 : eq(116, 36) : BOOL
123 : eq(116, 39) : BOOL
124 : eq(116, 41) : BOOL
125 : eq(116, 43) : BOOL
126 : eq(116, 45) : BOOL
127 : eq(116, 47) : BOOL
128 : eq(116, 49) : BOOL
129 : ite(128, 27, 51) : BV:8
130 : ite(127, 24, 129) : BV:8
131 : ite(126, 24, 130) : BV:8
132 : ite(125, 24, 131) : BV:8
133 : ite(124, 27, 132) : BV:8
134 : ite(123, 24, 133) : BV:8
135 : ite(122, 38, 134) : BV:8
136 : ite(121, 35, 135) : BV:8
137 : ite(120, 27, 136) : BV:8
138 : ite(119, 30, 137) : BV:8
139 : ite(118, 27, 138) : BV:8
140 : ite(117, 24, 139) : BV:8
141 : bvconcat(63, 89, 115, 140) : BV:32
142 : ite(17, 2, 141) : BV:32
143 : lambda(16, 142) : FUNCTION[BV:32 -> BV:32]
144 : map(15, 143) : MAP[BV:32 -> BV:32]
145 : sym_const(144) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda384 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : ite(3, 2, 128) : BV:32
130 : lambda(1, 129) : FUNCTION[BV:32 -> BV:32]
131 : sym_const(130) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda385 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
8 : bvadd(4, 6, 7) : BV:32
9 : eq(8, 7) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
12 : eq(8, 11) : BOOL
13 : 255 { 0xff -1 } : BV:8
14 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
15 : eq(8, 14) : BOOL
16 : 237 { 0xed -19 } : BV:8
17 : 1036948241 { 0x3dce9311 +1.61386311e252 } : BV:32
18 : eq(8, 17) : BOOL
19 : 3486526234 { 0xcfd02b1a -808441062 -1.62631535e32 } : BV:32
20 : eq(8, 19) : BOOL
21 : 94 { 0x5e } : BV:8
22 : 3486526233 { 0xcfd02b19 -808441063 -1.62631523e32 } : BV:32
23 : eq(8, 22) : BOOL
24 : 131 { 0x83 -125 } : BV:8
25 : 3982394115 { 0xed5e8303 -312573181 -1.73837316e91 } : BV:32
26 : eq(8, 25) : BOOL
27 : 1036948242 { 0x3dce9312 +1.61386322e252 } : BV:32
28 : eq(8, 27) : BOOL
29 : 3982394114 { 0xed5e8302 -312573182 -1.73837304e91 } : BV:32
30 : eq(8, 29) : BOOL
31 : 3982394113 { 0xed5e8301 -312573183 -1.73837292e91 } : BV:32
32 : eq(8, 31) : BOOL
33 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
34 : eq(8, 33) : BOOL
35 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
36 : eq(8, 35) : BOOL
37 : 5 { 0x5 } : BV:8
38 : ite(36, 13, 37) : BV:8
39 : ite(34, 10, 38) : BV:8
40 : ite(32, 10, 39) : BV:8
41 : ite(30, 10, 40) : BV:8
42 : ite(28, 13, 41) : BV:8
43 : ite(26, 10, 42) : BV:8
44 : ite(23, 24, 43) : BV:8
45 : ite(20, 21, 44) : BV:8
46 : ite(18, 13, 45) : BV:8
47 : ite(15, 16, 46) : BV:8
48 : ite(12, 13, 47) : BV:8
49 : ite(9, 10, 48) : BV:8
50 : 2 { 0x2 +1.23e129 } : BV:32
51 : bvadd(50, 6, 7) : BV:32
52 : eq(51, 7) : BOOL
53 : eq(51, 11) : BOOL
54 : eq(51, 14) : BOOL
55 : eq(51, 17) : BOOL
56 : eq(51, 19) : BOOL
57 : eq(51, 22) : BOOL
58 : eq(51, 25) : BOOL
59 : eq(51, 27) : BOOL
60 : eq(51, 29) : BOOL
61 : eq(51, 31) : BOOL
62 : eq(51, 33) : BOOL
63 : eq(51, 35) : BOOL
64 : ite(63, 13, 37) : BV:8
65 : ite(62, 10, 64) : BV:8
66 : ite(61, 10, 65) : BV:8
67 : ite(60, 10, 66) : BV:8
68 : ite(59, 13, 67) : BV:8
69 : ite(58, 10, 68) : BV:8
70 : ite(57, 24, 69) : BV:8
71 : ite(56, 21, 70) : BV:8
72 : ite(55, 13, 71) : BV:8
73 : ite(54, 16, 72) : BV:8
74 : ite(53, 13, 73) : BV:8
75 : ite(52, 10, 74) : BV:8
76 : 1 { 0x1 +1.11e129 } : BV:32
77 : bvadd(76, 6, 7) : BV:32
78 : eq(77, 7) : BOOL
79 : eq(77, 11) : BOOL
80 : eq(77, 14) : BOOL
81 : eq(77, 17) : BOOL
82 : eq(77, 19) : BOOL
83 : eq(77, 22) : BOOL
84 : eq(77, 25) : BOOL
85 : eq(77, 27) : BOOL
86 : eq(77, 29) : BOOL
87 : eq(77, 31) : BOOL
88 : eq(77, 33) : BOOL
89 : eq(77, 35) : BOOL
90 : ite(89, 13, 37) : BV:8
91 : ite(88, 10, 90) : BV:8
92 : ite(87, 10, 91) : BV:8
93 : ite(86, 10, 92) : BV:8
94 : ite(85, 13, 93) : BV:8
95 : ite(84, 10, 94) : BV:8
96 : ite(83, 24, 95) : BV:8
97 : ite(82, 21, 96) : BV:8
98 : ite(81, 13, 97) : BV:8
99 : ite(80, 16, 98) : BV:8
100 : ite(79, 13, 99) : BV:8
101 : ite(78, 10, 100) : BV:8
102 : bvadd(6, 7) : BV:32
103 : eq(102, 7) : BOOL
104 : eq(102, 11) : BOOL
105 : eq(102, 14) : BOOL
106 : eq(102, 17) : BOOL
107 : eq(102, 19) : BOOL
108 : eq(102, 22) : BOOL
109 : eq(102, 25) : BOOL
110 : eq(102, 27) : BOOL
111 : eq(102, 29) : BOOL
112 : eq(102, 31) : BOOL
113 : eq(102, 33) : BOOL
114 : eq(102, 35) : BOOL
115 : ite(114, 13, 37) : BV:8
116 : ite(113, 10, 115) : BV:8
117 : ite(112, 10, 116) : BV:8
118 : ite(111, 10, 117) : BV:8
119 : ite(110, 13, 118) : BV:8
120 : ite(109, 10, 119) : BV:8
121 : ite(108, 24, 120) : BV:8
122 : ite(107, 21, 121) : BV:8
123 : ite(106, 13, 122) : BV:8
124 : ite(105, 16, 123) : BV:8
125 : ite(104, 13, 124) : BV:8
126 : ite(103, 10, 125) : BV:8
127 : bvconcat(49, 75, 101, 126) : BV:32
128 : ite(3, 2, 127) : BV:32
129 : lambda(1, 128) : FUNCTION[BV:32 -> BV:32]
130 : sym_const(129) : FUNCTION[BV:32 -> BV:32]
=input.dst.llvm-%arr
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.dst.llvm-%n
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.dst.llvm-mem
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3982394112 { 0xed5e8300 -312573184 -1.73837280e91 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 162 , m_adder -> 65), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 2108327072 , 1000 , 8 ) -> 1049355574, () -> 437850325, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform9 : BV:32
4 : Lambda18 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda19 : BV:32
7 : sum(1, 2, 3) : SUM[UNIT,BV:32]
8 : prod(1, 7) : PROD[BV:32,SUM[UNIT,BV:32]]
9 : lambda(6, 8) : FUNCTION[BV:32 -> PROD[BV:32,SUM[UNIT,BV:32]]]
10 : ind(1, 3, 5, 9) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
11 : sum(1, 2, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : sym_const(11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1420111171 { 0x54a52d43 +1.29044377e42 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1036948239 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1036948240; 1036948243 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1036948244; 3486526231 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3486526232; 3486526235 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3486526236; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1036948239 ] -> 5, [ 1036948240; 1036948243 ] -> 255, [ 1036948244; 3486526231 ] -> 5, [ 3486526232; 3486526232 ] -> 0, [ 3486526233; 3486526233 ] -> 131, [ 3486526234; 3486526234 ] -> 94, [ 3486526235; 3486526235 ] -> 237, [ 3486526236; 3982394111 ] -> 5, [ 3982394112; 3982394115 ] -> 0, [ 3982394116; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1049355574 { 0x3e8be536 +1.9293246e254 } : BV:32
=input.dst.cur_rounding_mode.Lfor.cond%1%bbentry
1 : ROUND_to_nearest_ties_to_even : ROUNDING_MODE
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1036948240 { 0x3dce9310 +1.61386299e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1036948243 { 0x3dce9313 +1.61386334e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3486526232 { 0xcfd02b18 -808441064 -1.62631511e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3486526235 { 0xcfd02b1b -808441061 -1.62631547e32 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 162 , m_adder -> 65), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1399876490
=counter_example_end
=global nodece 27 num_edges_traversed 3
=global nodece 27 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 28
=global nodece 28 nodece z3v487.ce1250.num_edges_traversed2
=global nodece 28 nodece_path
=global nodece 28 nodece_path.graph_edge_composition
(epsilon)
=global nodece 28 nodece_cached_counterexample
=counter_example_begin z3v487.ce1250 ff8f4b7d184a77d996fada934ab6d31
=nextpc_const.1
1 : 2039701824 { 0x79936140 +1.15140533e116 } : BV:32
=input.spec-%var-arr-1
1 : Lambda2427 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 127 { 0x7f +1.1513e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 128 { 0x80 +1.1525e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2428 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 128 { 0x80 +1.1525e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda2430 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 127 { 0x7f +1.1513e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 128 { 0x80 +1.1525e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2431 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 127 ] -> true, [ 128; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda2398 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 127 { 0x7f +1.1513e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 128 { 0x80 +1.1525e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform219 : BV:32
4 : Lambda2434 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2435 : BV:32
7 : 566221269 { 0x21bfd9d5 +1.49883520e196 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 127 ] -> true, [ 128; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073780824 { 0x40009858 +1.464916e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 193 , m_adder -> 43), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 2039701824 , 1000 , 8 ) -> 1003424660, () -> 537619960, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform218 : BV:32
4 : Lambda2432 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2433 : BV:32
7 : 1848230130 { 0x6e29c0f2 +1.32620072e93 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 1073780823 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073780824; 1073780827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073780828; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1003424660 { 0x3bcf0b94 +1.61754083e248 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073780824 { 0x40009858 +1.464916e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073780827 { 0x4000985b +1.464951e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 193 , m_adder -> 43), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
709655861
=counter_example_end
=global nodece 28 num_edges_traversed 2
=global nodece 28 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 29
=global nodece 29 nodece z3.ce1247.num_edges_traversed2
=global nodece 29 nodece_path
=global nodece 29 nodece_path.graph_edge_composition
(epsilon)
=global nodece 29 nodece_cached_counterexample
=counter_example_begin z3.ce1247 5ec3e3983eb9430fbff10a8558b6f52
=nextpc_const.1
1 : 1025359467 { 0x3d1dbe6b +1.23237359e251 } : BV:32
=input.spec-%var-arr-1
1 : Lambda2445 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2446 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda2449 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1 { 0x1 +1.11e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2 { 0x2 +1.23e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda2450 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform223 : BV:32
4 : Lambda2453 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2454 : BV:32
7 : 711309692 { 0x2a65b97c +1.79472303e213 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1 ] -> true, [ 2; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda2413 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1 { 0x1 +1.11e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2 { 0x2 +1.23e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 3422326488 { 0xcbfc8ed8 -872640808 -1.97310924e24 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2361600584 { 0x8cc32a48 -1933366712 -1.52472782e154 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 55 , m_adder -> 161), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1025359467 , 1000 , 8 ) -> 1175392782, () -> 441560677, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform222 : BV:32
4 : Lambda2451 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda2452 : BV:32
7 : 1915188718 { 0x722775ee +1.30828642e101 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 2361600583 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2361600584; 2361600587 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2361600588; 3422326487 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3422326488; 3422326491 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 3422326492; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1175392782 { 0x460f120e +1.11773848e13 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2361600584 { 0x8cc32a48 -1933366712 -1.52472782e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2361600587 { 0x8cc32a4b -1933366709 -1.52472817e154 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 3422326488 { 0xcbfc8ed8 -872640808 -1.97310924e24 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 3422326491 { 0xcbfc8edb -872640805 -1.97310960e24 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 55 , m_adder -> 161), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1490843821
=counter_example_end
=global nodece 29 num_edges_traversed 2
=global nodece 29 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 30
=global nodece 30 nodece z3.ce1244.num_edges_traversed2
=global nodece 30 nodece_path
=global nodece 30 nodece_path.graph_edge_composition
(epsilon)
=global nodece 30 nodece_cached_counterexample
=counter_example_begin z3.ce1244 3467568d40de7e564bd58b9d76733f0
=nextpc_const.1
1 : 2032658817 { 0x7927e981 +1.31181347e115 } : BV:32
=input.spec-%var-arr-1
1 : Lambda3645 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda3646 : BV:32
17 : eq(16, 2) : BOOL
18 : bvule(2, 16) : BOOL
19 : bvule(16, 2) : BOOL
20 : and(18, 19) : BOOL
21 : bvule(7, 16) : BOOL
22 : bvule(16, 9) : BOOL
23 : and(21, 22) : BOOL
24 : ite(23, 12, 12) : BOOL
25 : ite(20, 6, 24) : BOOL
26 : and(18, 22) : BOOL
27 : ite(26, 2, 2) : BV:32
28 : ite(25, 2, 27) : BV:32
29 : ite(17, 2, 28) : BV:32
30 : lambda(16, 29) : FUNCTION[BV:32 -> BV:32]
31 : map(15, 30) : MAP[BV:32 -> BV:32]
32 : sym_const(31) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda3649 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda3650 : BV:32
17 : bvule(2, 16) : BOOL
18 : bvule(16, 9) : BOOL
19 : and(17, 18) : BOOL
20 : ite(19, 2, 2) : BV:32
21 : lambda(16, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(15, 21) : MAP[BV:32 -> BV:32]
23 : sym_const(22) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform323 : BV:32
4 : Lambda3653 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3654 : BV:32
7 : 1420389612 { 0x54a96cec +1.32363653e42 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda3621 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : bvule(1, 2) : BOOL
6 : and(4, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1 { 0x1 +1.11e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : and(4, 11) : BOOL
17 : ite(16, 2, 2) : BV:32
18 : ite(15, 2, 17) : BV:32
19 : ite(3, 2, 18) : BV:32
20 : lambda(1, 19) : FUNCTION[BV:32 -> BV:32]
21 : sym_const(20) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1573751912 { 0x5dcd8c68 +1.60584735e60 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2429225352 { 0x90cb0988 -1865741944 -1.58622837e162 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 132 , m_adder -> 69), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 2032658817 , 1000 , 8 ) -> 1190672455, () -> 1887788183, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform322 : BV:32
4 : Lambda3651 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3652 : BV:32
7 : 902062917 { 0x35c46345 +1.53427946e236 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1573751911 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1573751912; 1573751915 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1573751916; 2147483641 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483642; 2429225351 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2429225352; 2429225355 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2429225356; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1190672455 { 0x46f83847 +1.93921744e14 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2429225352 { 0x90cb0988 -1865741944 -1.58622837e162 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2429225355 { 0x90cb098b -1865741941 -1.58622872e162 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1573751912 { 0x5dcd8c68 +1.60584735e60 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1573751915 { 0x5dcd8c6b +1.60584771e60 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 132 , m_adder -> 69), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
4269557455
=counter_example_end
=global nodece 30 num_edges_traversed 2
=global nodece 30 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 31
=global nodece 31 nodece z3.ce1241.num_edges_traversed2
=global nodece 31 nodece_path
=global nodece 31 nodece_path.graph_edge_composition
(epsilon)
=global nodece 31 nodece_cached_counterexample
=counter_example_begin z3.ce1241 8643e123dcc19332c3dec8ba780cdd1
=nextpc_const.1
1 : 1393462095 { 0x530e8b4f +1.11362636e39 } : BV:32
=input.spec-%var-arr-1
1 : Lambda3773 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3774 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda3777 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3778 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform339 : BV:32
4 : Lambda3781 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3782 : BV:32
7 : 2027212428 { 0x78d4ce8c +1.66255331e114 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda3749 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 547649092 { 0x20a47644 +1.28485918e194 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1929044644 { 0x72fae2a4 +1.96004152e102 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 92 , m_adder -> 117), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1393462095 , 1000 , 8 ) -> 255197840, () -> 305679533, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform338 : BV:32
4 : Lambda3779 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3780 : BV:32
7 : 1775239482 { 0x69d0013a +1.62503743e84 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 547649091 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 547649092; 547649095 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 547649096; 1929044643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1929044644; 1929044647 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1929044648; 3992977400 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3992977401; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 255197840 { 0xf360290 +1.42195320e159 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1929044644 { 0x72fae2a4 +1.96004152e102 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1929044647 { 0x72fae2a7 +1.96004188e102 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 547649092 { 0x20a47644 +1.28485918e194 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 547649095 { 0x20a47647 +1.28485953e194 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 92 , m_adder -> 117), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3555344610
=counter_example_end
=global nodece 31 num_edges_traversed 2
=global nodece 31 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 32
=global nodece 32 nodece z3v487.ce1238.num_edges_traversed2
=global nodece 32 nodece_path
=global nodece 32 nodece_path.graph_edge_composition
(epsilon)
=global nodece 32 nodece_cached_counterexample
=counter_example_begin z3v487.ce1238 aece7299f8d616bdcbe8d7198e58d63
=nextpc_const.1
1 : 2122575312 { 0x7e83edd0 +1.3069496e126 } : BV:32
=input.spec-%var-arr-1
1 : Lambda3902 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3903 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda3905 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3906 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda3873 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform355 : BV:32
4 : Lambda3909 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3910 : BV:32
7 : 1392596878 { 0x5301578e +1.1048445e39 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 33558532 { 0x2001004 +1.48875e133 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 64 { 0x40 +1.762e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 10 , m_adder -> 150), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 2122575312 , 1000 , 8 ) -> 1675553835, () -> 56964861, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform354 : BV:32
4 : Lambda3907 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3908 : BV:32
7 : 1110086872 { 0x422a94d8 +1.33266735e5 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 33558531 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 33558532; 33558535 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 33558536; 268440063 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268440064; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1675553835 { 0x63deec2b +1.74158227e72 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 33558532 { 0x2001004 +1.48875e133 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 33558535 { 0x2001007 +1.48911e133 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 10 , m_adder -> 150), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2847266529
=counter_example_end
=global nodece 32 num_edges_traversed 2
=global nodece 32 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 33
=global nodece 33 nodece z3v487.ce1235.num_edges_traversed2
=global nodece 33 nodece_path
=global nodece 33 nodece_path.graph_edge_composition
(epsilon)
=global nodece 33 nodece_cached_counterexample
=counter_example_begin z3v487.ce1235 83f9ea2c92c08819a158b4c61a3961f1
=nextpc_const.1
1 : 42286221 { 0x2853c8d +1.4091036e134 } : BV:32
=input.spec-%var-arr-1
1 : Lambda4030 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4031 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4033 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4034 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda4001 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform371 : BV:32
4 : Lambda4037 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4038 : BV:32
7 : 1425493977 { 0x54f74fd9 +1.93212425e42 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 33558532 { 0x2001004 +1.48875e133 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 240 , m_adder -> 134), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 42286221 , 1000 , 8 ) -> 1914804967, () -> 1295596075, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform370 : BV:32
4 : Lambda4035 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4036 : BV:32
7 : 66777319 { 0x3faf0e7 +1.96047675e136 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 33558531 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 33558532; 33558535 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 33558536; 268440063 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 268440064; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1914804967 { 0x72219ae7 +1.26253974e101 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 33558532 { 0x2001004 +1.48875e133 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 33558535 { 0x2001007 +1.48911e133 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 240 , m_adder -> 134), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3763736355
=counter_example_end
=global nodece 33 num_edges_traversed 2
=global nodece 33 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 34
=global nodece 34 nodece z3v487.ce1232.num_edges_traversed2
=global nodece 34 nodece_path
=global nodece 34 nodece_path.graph_edge_composition
(epsilon)
=global nodece 34 nodece_cached_counterexample
=counter_example_begin z3v487.ce1232 36af5f8b72c1acfa4bf9dcf21a67f93
=nextpc_const.1
1 : 1714886266 { 0x6637167a +1.43037343e77 } : BV:32
=input.spec-%var-arr-1
1 : Lambda4158 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4159 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 262144 { 0x40000 +1.3125000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4161 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 262144 { 0x40000 +1.3125000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda4162 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda4129 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 262143 { 0x3ffff +1.3124988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 262144 { 0x40000 +1.3125000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform387 : BV:32
4 : Lambda4165 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4166 : BV:32
7 : 726752389 { 0x2b515c85 +1.63563597e215 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 262143 ] -> true, [ 262144; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 286925600 { 0x111a2320 +1.20419692e163 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 166 , m_adder -> 184), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1714886266 , 1000 , 8 ) -> 1488923960, () -> 2122892133, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform386 : BV:32
4 : Lambda4163 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4164 : BV:32
7 : 830619005 { 0x31823d7d +1.1750147e228 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 286925599 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 286925600; 286925603 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 286925604; 1073741817 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073741818; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1488923960 { 0x58bf2d38 +1.49356746e50 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 286925600 { 0x111a2320 +1.20419692e163 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 286925603 { 0x111a2323 +1.20419728e163 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 166 , m_adder -> 184), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1438759359
=counter_example_end
=global nodece 34 num_edges_traversed 2
=global nodece 34 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 35
=global nodece 35 nodece z3.ce1229.num_edges_traversed2
=global nodece 35 nodece_path
=global nodece 35 nodece_path.graph_edge_composition
(epsilon)
=global nodece 35 nodece_cached_counterexample
=counter_example_begin z3.ce1229 4bbcefeee9cdea273ce548147db6ca37
=nextpc_const.1
1 : 589752548 { 0x2326e8e4 +1.30398225e199 } : BV:32
=input.spec-%var-arr-1
1 : Lambda4285 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda4286 : BV:32
17 : eq(16, 2) : BOOL
18 : bvule(2, 16) : BOOL
19 : bvule(16, 4) : BOOL
20 : and(18, 19) : BOOL
21 : bvule(8, 16) : BOOL
22 : bvule(16, 8) : BOOL
23 : and(21, 22) : BOOL
24 : ite(23, 12, 12) : BOOL
25 : ite(20, 7, 24) : BOOL
26 : and(18, 22) : BOOL
27 : ite(26, 2, 2) : BV:32
28 : ite(25, 2, 27) : BV:32
29 : ite(17, 2, 28) : BV:32
30 : lambda(16, 29) : FUNCTION[BV:32 -> BV:32]
31 : map(15, 30) : MAP[BV:32 -> BV:32]
32 : sym_const(31) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda4289 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
9 : bvule(8, 1) : BOOL
10 : bvule(1, 8) : BOOL
11 : and(9, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(6, 7, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda4290 : BV:32
17 : bvule(2, 16) : BOOL
18 : bvule(16, 8) : BOOL
19 : and(17, 18) : BOOL
20 : ite(19, 2, 2) : BV:32
21 : lambda(16, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(15, 21) : MAP[BV:32 -> BV:32]
23 : sym_const(22) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform403 : BV:32
4 : Lambda4293 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4294 : BV:32
7 : 1478519149 { 0x5820696d +1.25321733e49 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 4294967294 ] -> true, [ 4294967295; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda4261 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(9, 1) : BOOL
11 : bvule(1, 9) : BOOL
12 : and(10, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(7, 8, 14) : BOOL
16 : and(4, 11) : BOOL
17 : ite(16, 2, 2) : BV:32
18 : ite(15, 2, 17) : BV:32
19 : ite(3, 2, 18) : BV:32
20 : lambda(1, 19) : FUNCTION[BV:32 -> BV:32]
21 : sym_const(20) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1201995804 { 0x47a5001c +1.28906583e16 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2122317824 { 0x7e800000 +1.0e126 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 35 , m_adder -> 174), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 589752548 , 1000 , 8 ) -> 1120433665, () -> 844076219, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform402 : BV:32
4 : Lambda4291 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda4292 : BV:32
7 : 1300700231 { 0x4d871c47 +1.5555045e28 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1201995803 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1201995804; 1201995807 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1201995808; 2122317823 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2122317824; 2122317827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2122317828; 2147483640 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483641; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1120433665 { 0x42c87601 +1.56610119e6 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2122317824 { 0x7e800000 +1.0e126 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2122317827 { 0x7e800003 +1.35e126 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1201995804 { 0x47a5001c +1.28906583e16 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1201995807 { 0x47a5001f +1.28906619e16 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 35 , m_adder -> 174), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
530988070
=counter_example_end
=global nodece 35 num_edges_traversed 2
=global nodece 35 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 36
=global nodece 36 nodece z3v487.ce1613.num_edges_traversed1
=global nodece 36 nodece_path
=global nodece 36 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 36 nodece_cached_counterexample
=counter_example_begin z3v487.ce1613 a9527fda266fbba4fcf807992763f59
=nextpc_const.1
1 : 1158702727 { 0x45106687 +1.12812888e11 } : BV:32
=input.spec-%var-arr-1
1 : Lambda7233 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7234 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda7236 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7237 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1073741823 ] -> true, [ 1073741824; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda7204 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1073741823 { 0x3fffffff +1.99999988e0 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform739 : BV:32
4 : Lambda7240 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7241 : BV:32
7 : 252330870 { 0xf0a4376 +1.8018374e159 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1073741823 ] -> true, [ 1073741824; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 128 { 0x80 +1.1525e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 1 , m_adder -> 235), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1158702727 , 1000 , 8 ) -> 1258173929, () -> 1280523, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform738 : BV:32
4 : Lambda7238 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7239 : BV:32
7 : 1260755147 { 0x4b2598cb +1.29372537e23 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 642367 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 642368; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1258173929 { 0x4afe35e9 +1.98602020e22 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 1 , m_adder -> 235), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
249762489
=counter_example_end
=global nodece 36 num_edges_traversed 1
=global nodece 36 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 37
=global nodece 37 nodece z3.ce1614.num_edges_traversed1
=global nodece 37 nodece_path
=global nodece 37 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 37 nodece_cached_counterexample
=counter_example_begin z3.ce1614 34e06f22d663989d666882753dadeb1
=nextpc_const.1
1 : 399616787 { 0x17d1ab13 +1.63803327e176 } : BV:32
=input.spec-%var-arr-1
1 : Lambda7251 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 511 { 0x1ff +1.6091e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 512 { 0x200 +1.6103e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7252 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 512 { 0x200 +1.6103e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda7255 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 511 { 0x1ff +1.6091e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 512 { 0x200 +1.6103e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7256 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 511 ] -> true, [ 512; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform743 : BV:32
4 : Lambda7259 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7260 : BV:32
7 : 1385382022 { 0x52934086 +1.15040659e38 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 511 ] -> true, [ 512; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda7219 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 511 { 0x1ff +1.6091e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 512 { 0x200 +1.6103e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1039940972 { 0x3dfc3d6c +1.97062444e252 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 79309544 { 0x4ba2ae8 +1.45443439e138 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 59 , m_adder -> 138), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 399616787 , 1000 , 8 ) -> 1503266444, () -> 318883397, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform742 : BV:32
4 : Lambda7257 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7258 : BV:32
7 : 1364860540 { 0x515a1e7c +1.70405530e35 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 79309543 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 79309544; 79309547 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 79309548; 1039940971 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1039940972; 1039940975 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1039940976; 1098907643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1098907644; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1503266444 { 0x599a068c +1.20332479e52 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 79309544 { 0x4ba2ae8 +1.45443439e138 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 79309547 { 0x4ba2aeb +1.45443475e138 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1039940972 { 0x3dfc3d6c +1.97062444e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1039940975 { 0x3dfc3d6f +1.97062480e252 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 59 , m_adder -> 138), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3084562710
=counter_example_end
=global nodece 37 num_edges_traversed 1
=global nodece 37 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 38
=global nodece 38 nodece z3.ce1633.num_edges_traversed1
=global nodece 38 nodece_path
=global nodece 38 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 38 nodece_cached_counterexample
=counter_example_begin z3.ce1633 cbe56fbbb4d75367946cf0e9e1c4f97
=nextpc_const.1
1 : 874041545 { 0x3418d0c9 +1.19387161e233 } : BV:32
=input.spec-%var-arr-1
1 : Lambda7360 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7361 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda7364 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7365 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform755 : BV:32
4 : Lambda7368 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7369 : BV:32
7 : 557496952 { 0x213aba78 +1.45881557e195 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda7336 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 31 { 0x1f +1.369e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 32 { 0x20 +1.381e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2086285276 { 0x7c5a2fdc +1.70458555e121 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2470018044 { 0x93397bfc -1824949252 -1.44909620e167 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 86 , m_adder -> 168), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 874041545 , 1000 , 8 ) -> 1283148321, () -> 1996573154, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform754 : BV:32
4 : Lambda7366 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7367 : BV:32
7 : 1378381590 { 0x52286f16 +1.31589007e37 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 2086285275 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2086285276; 2086285279 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2086285280; 2470018043 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2470018044; 2470018047 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2470018048; 3221225464 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3221225465; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1283148321 { 0x4c7b4a21 +1.96319973e25 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2470018044 { 0x93397bfc -1824949252 -1.44909620e167 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2470018047 { 0x93397bff -1824949249 -1.44909656e167 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2086285276 { 0x7c5a2fdc +1.70458555e121 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2086285279 { 0x7c5a2fdf +1.70458590e121 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 86 , m_adder -> 168), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1850587670
=counter_example_end
=global nodece 38 num_edges_traversed 1
=global nodece 38 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 39
=global nodece 39 nodece z3.ce1653.num_edges_traversed1
=global nodece 39 nodece_path
=global nodece 39 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 39 nodece_cached_counterexample
=counter_example_begin z3.ce1653 881f9d2121d6f6246ddd241904a7798
=nextpc_const.1
1 : 1886392614 { 0x70701126 +1.87552332e97 } : BV:32
=input.spec-%var-arr-1
1 : Lambda7488 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7489 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda7492 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7493 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform771 : BV:32
4 : Lambda7496 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7497 : BV:32
7 : 1344961804 { 0x502a7d0c +1.33194112e33 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda7464 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 3 { 0x3 +1.35e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 4 { 0x4 +1.47e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2963525188 { 0xb0a3ce44 -1331442108 -1.27973222e226 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 683322228 { 0x28baab74 +1.45835733e210 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 5 , m_adder -> 77), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1886392614 , 1000 , 8 ) -> 196822121, () -> 1160145080, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform770 : BV:32
4 : Lambda7494 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7495 : BV:32
7 : 1270380380 { 0x4bb8775c +1.44114255e24 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 683322227 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 683322228; 683322231 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 683322232; 2147483640 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483641; 2963525187 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2963525188; 2963525191 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2963525192; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 196822121 { 0xbbb4469 +1.46302521e152 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 683322228 { 0x28baab74 +1.45835733e210 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 683322231 { 0x28baab77 +1.45835769e210 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2963525188 { 0xb0a3ce44 -1331442108 -1.27973222e226 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2963525191 { 0xb0a3ce47 -1331442105 -1.27973258e226 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 5 , m_adder -> 77), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2139543194
=counter_example_end
=global nodece 39 num_edges_traversed 1
=global nodece 39 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 40
=global nodece 40 nodece z3v487.ce1654.num_edges_traversed1
=global nodece 40 nodece_path
=global nodece 40 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 40 nodece_cached_counterexample
=counter_example_begin z3v487.ce1654 4764c2c22b7c192276f8c381183299c
=nextpc_const.1
1 : 65203105 { 0x3e2eba1 +1.77281582e136 } : BV:32
=input.spec-%var-arr-1
1 : Lambda7508 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda7509 : BV:32
17 : bvule(2, 16) : BOOL
18 : bvule(16, 9) : BOOL
19 : and(17, 18) : BOOL
20 : ite(19, 2, 2) : BV:32
21 : lambda(16, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(15, 21) : MAP[BV:32 -> BV:32]
23 : sym_const(22) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda7511 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : bvule(1, 2) : BOOL
5 : and(3, 4) : BOOL
6 : 1 { 0x1 } : BOOL
7 : 1 { 0x1 +1.11e129 } : BV:32
8 : bvule(7, 1) : BOOL
9 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
10 : bvule(1, 9) : BOOL
11 : and(8, 10) : BOOL
12 : 0 { 0x0 } : BOOL
13 : ite(11, 12, 12) : BOOL
14 : ite(5, 6, 13) : BOOL
15 : lambda(1, 14) : FUNCTION[BV:32 -> BOOL]
16 : Lambda7512 : BV:32
17 : eq(16, 2) : BOOL
18 : bvule(2, 16) : BOOL
19 : bvule(16, 2) : BOOL
20 : and(18, 19) : BOOL
21 : bvule(7, 16) : BOOL
22 : bvule(16, 9) : BOOL
23 : and(21, 22) : BOOL
24 : ite(23, 12, 12) : BOOL
25 : ite(20, 6, 24) : BOOL
26 : and(18, 22) : BOOL
27 : ite(26, 2, 2) : BV:32
28 : ite(25, 2, 27) : BV:32
29 : ite(17, 2, 28) : BV:32
30 : lambda(16, 29) : FUNCTION[BV:32 -> BV:32]
31 : map(15, 30) : MAP[BV:32 -> BV:32]
32 : sym_const(31) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda7471 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : bvule(1, 2) : BOOL
6 : and(4, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1 { 0x1 +1.11e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : and(4, 11) : BOOL
17 : ite(16, 2, 2) : BV:32
18 : ite(15, 2, 17) : BV:32
19 : ite(3, 2, 18) : BV:32
20 : lambda(1, 19) : FUNCTION[BV:32 -> BV:32]
21 : sym_const(20) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform775 : BV:32
4 : Lambda7515 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7516 : BV:32
7 : 804139083 { 0x2fee304b +1.86084878e224 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 0 ] -> true, [ 1; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 141 , m_adder -> 135), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 65203105 , 1000 , 8 ) -> 1828042454, () -> 2102607268, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform774 : BV:32
4 : Lambda7513 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7514 : BV:32
7 : 1775200535 { 0x69cf6917 +1.62039458e84 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 571895807 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 571895808; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147483652; 4294967295 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1828042454 { 0x6cf5b6d6 +1.91964221e90 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 141 , m_adder -> 135), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1468107290
=counter_example_end
=global nodece 40 num_edges_traversed 1
=global nodece 40 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 41
=global nodece 41 nodece z3.ce1836.num_edges_traversed0
=global nodece 41 nodece_path
=global nodece 41 nodece_path.graph_edge_composition
(epsilon)
=global nodece 41 nodece_cached_counterexample
=counter_example_begin z3.ce1836 e5fd202b94477822d156ece71249d19f
=input.spec-%var-arr-1
1 : Lambda9612 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 524288 { 0x80000 +1.6250000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9613 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
32 : eq(30, 31) : BOOL
33 : 0 { 0x0 } : BV:8
34 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
35 : eq(30, 34) : BOOL
36 : eq(30, 27) : BOOL
37 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
38 : eq(30, 37) : BOOL
39 : 3 { 0x3 } : BV:8
40 : ite(38, 33, 39) : BV:8
41 : ite(36, 33, 40) : BV:8
42 : ite(35, 33, 41) : BV:8
43 : ite(32, 33, 42) : BV:8
44 : bvadd(31, 29) : BV:32
45 : eq(44, 31) : BOOL
46 : eq(44, 34) : BOOL
47 : eq(44, 27) : BOOL
48 : eq(44, 37) : BOOL
49 : ite(48, 33, 39) : BV:8
50 : ite(47, 33, 49) : BV:8
51 : ite(46, 33, 50) : BV:8
52 : ite(45, 33, 51) : BV:8
53 : bvadd(37, 29) : BV:32
54 : eq(53, 31) : BOOL
55 : eq(53, 34) : BOOL
56 : eq(53, 27) : BOOL
57 : eq(53, 37) : BOOL
58 : ite(57, 33, 39) : BV:8
59 : ite(56, 33, 58) : BV:8
60 : ite(55, 33, 59) : BV:8
61 : ite(54, 33, 60) : BV:8
62 : bvadd(34, 29) : BV:32
63 : eq(62, 31) : BOOL
64 : eq(62, 34) : BOOL
65 : eq(62, 27) : BOOL
66 : eq(62, 37) : BOOL
67 : ite(66, 33, 39) : BV:8
68 : ite(65, 33, 67) : BV:8
69 : ite(64, 33, 68) : BV:8
70 : ite(63, 33, 69) : BV:8
71 : bvconcat(43, 52, 61, 70) : BV:32
72 : ite(18, 2, 71) : BV:32
73 : ite(26, 71, 72) : BV:32
74 : ite(18, 2, 73) : BV:32
75 : lambda(17, 74) : FUNCTION[BV:32 -> BV:32]
76 : map(16, 75) : MAP[BV:32 -> BV:32]
77 : sym_const(76) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda9615 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 524288 { 0x80000 +1.6250000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9616 : BV:32
18 : eq(17, 2) : BOOL
19 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
24 : eq(22, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
27 : eq(22, 26) : BOOL
28 : eq(22, 19) : BOOL
29 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
30 : eq(22, 29) : BOOL
31 : 3 { 0x3 } : BV:8
32 : ite(30, 25, 31) : BV:8
33 : ite(28, 25, 32) : BV:8
34 : ite(27, 25, 33) : BV:8
35 : ite(24, 25, 34) : BV:8
36 : bvadd(23, 21) : BV:32
37 : eq(36, 23) : BOOL
38 : eq(36, 26) : BOOL
39 : eq(36, 19) : BOOL
40 : eq(36, 29) : BOOL
41 : ite(40, 25, 31) : BV:8
42 : ite(39, 25, 41) : BV:8
43 : ite(38, 25, 42) : BV:8
44 : ite(37, 25, 43) : BV:8
45 : bvadd(29, 21) : BV:32
46 : eq(45, 23) : BOOL
47 : eq(45, 26) : BOOL
48 : eq(45, 19) : BOOL
49 : eq(45, 29) : BOOL
50 : ite(49, 25, 31) : BV:8
51 : ite(48, 25, 50) : BV:8
52 : ite(47, 25, 51) : BV:8
53 : ite(46, 25, 52) : BV:8
54 : bvadd(26, 21) : BV:32
55 : eq(54, 23) : BOOL
56 : eq(54, 26) : BOOL
57 : eq(54, 19) : BOOL
58 : eq(54, 29) : BOOL
59 : ite(58, 25, 31) : BV:8
60 : ite(57, 25, 59) : BV:8
61 : ite(56, 25, 60) : BV:8
62 : ite(55, 25, 61) : BV:8
63 : bvconcat(35, 44, 53, 62) : BV:32
64 : ite(18, 2, 63) : BV:32
65 : lambda(17, 64) : FUNCTION[BV:32 -> BV:32]
66 : map(16, 65) : MAP[BV:32 -> BV:32]
67 : sym_const(66) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 524287 ] -> true, [ 524288; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda9588 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
9 : eq(7, 8) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
12 : eq(7, 11) : BOOL
13 : eq(7, 4) : BOOL
14 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
15 : eq(7, 14) : BOOL
16 : 3 { 0x3 } : BV:8
17 : ite(15, 10, 16) : BV:8
18 : ite(13, 10, 17) : BV:8
19 : ite(12, 10, 18) : BV:8
20 : ite(9, 10, 19) : BV:8
21 : bvadd(8, 6) : BV:32
22 : eq(21, 8) : BOOL
23 : eq(21, 11) : BOOL
24 : eq(21, 4) : BOOL
25 : eq(21, 14) : BOOL
26 : ite(25, 10, 16) : BV:8
27 : ite(24, 10, 26) : BV:8
28 : ite(23, 10, 27) : BV:8
29 : ite(22, 10, 28) : BV:8
30 : bvadd(14, 6) : BV:32
31 : eq(30, 8) : BOOL
32 : eq(30, 11) : BOOL
33 : eq(30, 4) : BOOL
34 : eq(30, 14) : BOOL
35 : ite(34, 10, 16) : BV:8
36 : ite(33, 10, 35) : BV:8
37 : ite(32, 10, 36) : BV:8
38 : ite(31, 10, 37) : BV:8
39 : bvadd(11, 6) : BV:32
40 : eq(39, 8) : BOOL
41 : eq(39, 11) : BOOL
42 : eq(39, 4) : BOOL
43 : eq(39, 14) : BOOL
44 : ite(43, 10, 16) : BV:8
45 : ite(42, 10, 44) : BV:8
46 : ite(41, 10, 45) : BV:8
47 : ite(40, 10, 46) : BV:8
48 : bvconcat(20, 29, 38, 47) : BV:32
49 : ite(3, 2, 48) : BV:32
50 : lambda(1, 49) : FUNCTION[BV:32 -> BV:32]
51 : sym_const(50) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1043 : BV:32
4 : Lambda9619 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda9620 : BV:32
7 : 1976985272 { 0x75d666b8 +1.67500972e108 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 524287 ] -> true, [ 524288; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda9592 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 524288 { 0x80000 +1.6250000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
22 : eq(20, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
25 : eq(20, 24) : BOOL
26 : eq(20, 17) : BOOL
27 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
28 : eq(20, 27) : BOOL
29 : 3 { 0x3 } : BV:8
30 : ite(28, 23, 29) : BV:8
31 : ite(26, 23, 30) : BV:8
32 : ite(25, 23, 31) : BV:8
33 : ite(22, 23, 32) : BV:8
34 : bvadd(21, 19) : BV:32
35 : eq(34, 21) : BOOL
36 : eq(34, 24) : BOOL
37 : eq(34, 17) : BOOL
38 : eq(34, 27) : BOOL
39 : ite(38, 23, 29) : BV:8
40 : ite(37, 23, 39) : BV:8
41 : ite(36, 23, 40) : BV:8
42 : ite(35, 23, 41) : BV:8
43 : bvadd(27, 19) : BV:32
44 : eq(43, 21) : BOOL
45 : eq(43, 24) : BOOL
46 : eq(43, 17) : BOOL
47 : eq(43, 27) : BOOL
48 : ite(47, 23, 29) : BV:8
49 : ite(46, 23, 48) : BV:8
50 : ite(45, 23, 49) : BV:8
51 : ite(44, 23, 50) : BV:8
52 : bvadd(24, 19) : BV:32
53 : eq(52, 21) : BOOL
54 : eq(52, 24) : BOOL
55 : eq(52, 17) : BOOL
56 : eq(52, 27) : BOOL
57 : ite(56, 23, 29) : BV:8
58 : ite(55, 23, 57) : BV:8
59 : ite(54, 23, 58) : BV:8
60 : ite(53, 23, 59) : BV:8
61 : bvconcat(33, 42, 51, 60) : BV:32
62 : ite(3, 2, 61) : BV:32
63 : ite(16, 61, 62) : BV:32
64 : ite(3, 2, 63) : BV:32
65 : lambda(1, 64) : FUNCTION[BV:32 -> BV:32]
66 : sym_const(65) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2428895236 { 0x90c60004 -1866072060 -1.54687547e162 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3202203688 { 0xbeddc028 -1092763608 -1.73242664e254 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1042 : BV:32
4 : Lambda9617 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda9618 : BV:32
7 : 1667814087 { 0x6368d2c7 +1.81893241e71 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1088712247 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1088712248; 1088712251 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1088712252; 2428895235 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2428895236; 2428895239 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2428895240; 3202203687 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3202203688; 3202203691 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3202203692; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1088712247 ] -> 3, [ 1088712248; 1088712251 ] -> 0, [ 1088712252; 4294967295 ] -> 3, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 4294959104 { 0xffffe000 -8192 -1.99902343e128 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3202203688 { 0xbeddc028 -1092763608 -1.73242664e254 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3202203691 { 0xbeddc02b -1092763605 -1.73242700e254 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2428895236 { 0x90c60004 -1866072060 -1.54687547e162 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2428895239 { 0x90c60007 -1866072057 -1.54687583e162 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
973735634
=counter_example_end
=global nodece 41 num_edges_traversed 0
=global nodece 41 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 42
=global nodece 42 nodece z3v487.ce1837.num_edges_traversed0
=global nodece 42 nodece_path
=global nodece 42 nodece_path.graph_edge_composition
(epsilon)
=global nodece 42 nodece_cached_counterexample
=counter_example_begin z3v487.ce1837 b2ed558a653ee07d48c29892895d2a6
=input.spec-%var-arr-1
1 : Lambda9630 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9631 : BV:32
18 : eq(17, 2) : BOOL
19 : 184593447 { 0xb00ac27 +1.525367e151 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : 184593444 { 0xb00ac24 +1.525331e151 } : BV:32
24 : eq(22, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 184593445 { 0xb00ac25 +1.525343e151 } : BV:32
27 : eq(22, 26) : BOOL
28 : 184593446 { 0xb00ac26 +1.525355e151 } : BV:32
29 : eq(22, 28) : BOOL
30 : eq(22, 19) : BOOL
31 : 5 { 0x5 } : BV:8
32 : ite(30, 25, 31) : BV:8
33 : ite(29, 25, 32) : BV:8
34 : ite(27, 25, 33) : BV:8
35 : ite(24, 25, 34) : BV:8
36 : bvadd(28, 21) : BV:32
37 : eq(36, 23) : BOOL
38 : eq(36, 26) : BOOL
39 : eq(36, 28) : BOOL
40 : eq(36, 19) : BOOL
41 : ite(40, 25, 31) : BV:8
42 : ite(39, 25, 41) : BV:8
43 : ite(38, 25, 42) : BV:8
44 : ite(37, 25, 43) : BV:8
45 : bvadd(26, 21) : BV:32
46 : eq(45, 23) : BOOL
47 : eq(45, 26) : BOOL
48 : eq(45, 28) : BOOL
49 : eq(45, 19) : BOOL
50 : ite(49, 25, 31) : BV:8
51 : ite(48, 25, 50) : BV:8
52 : ite(47, 25, 51) : BV:8
53 : ite(46, 25, 52) : BV:8
54 : bvadd(23, 21) : BV:32
55 : eq(54, 23) : BOOL
56 : eq(54, 26) : BOOL
57 : eq(54, 28) : BOOL
58 : eq(54, 19) : BOOL
59 : ite(58, 25, 31) : BV:8
60 : ite(57, 25, 59) : BV:8
61 : ite(56, 25, 60) : BV:8
62 : ite(55, 25, 61) : BV:8
63 : bvconcat(35, 44, 53, 62) : BV:32
64 : ite(18, 2, 63) : BV:32
65 : lambda(17, 64) : FUNCTION[BV:32 -> BV:32]
66 : map(16, 65) : MAP[BV:32 -> BV:32]
67 : sym_const(66) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda9633 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9634 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 184593447 { 0xb00ac27 +1.525367e151 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : 184593444 { 0xb00ac24 +1.525331e151 } : BV:32
32 : eq(30, 31) : BOOL
33 : 0 { 0x0 } : BV:8
34 : 184593445 { 0xb00ac25 +1.525343e151 } : BV:32
35 : eq(30, 34) : BOOL
36 : 184593446 { 0xb00ac26 +1.525355e151 } : BV:32
37 : eq(30, 36) : BOOL
38 : eq(30, 27) : BOOL
39 : 5 { 0x5 } : BV:8
40 : ite(38, 33, 39) : BV:8
41 : ite(37, 33, 40) : BV:8
42 : ite(35, 33, 41) : BV:8
43 : ite(32, 33, 42) : BV:8
44 : bvadd(36, 29) : BV:32
45 : eq(44, 31) : BOOL
46 : eq(44, 34) : BOOL
47 : eq(44, 36) : BOOL
48 : eq(44, 27) : BOOL
49 : ite(48, 33, 39) : BV:8
50 : ite(47, 33, 49) : BV:8
51 : ite(46, 33, 50) : BV:8
52 : ite(45, 33, 51) : BV:8
53 : bvadd(34, 29) : BV:32
54 : eq(53, 31) : BOOL
55 : eq(53, 34) : BOOL
56 : eq(53, 36) : BOOL
57 : eq(53, 27) : BOOL
58 : ite(57, 33, 39) : BV:8
59 : ite(56, 33, 58) : BV:8
60 : ite(55, 33, 59) : BV:8
61 : ite(54, 33, 60) : BV:8
62 : bvadd(31, 29) : BV:32
63 : eq(62, 31) : BOOL
64 : eq(62, 34) : BOOL
65 : eq(62, 36) : BOOL
66 : eq(62, 27) : BOOL
67 : ite(66, 33, 39) : BV:8
68 : ite(65, 33, 67) : BV:8
69 : ite(64, 33, 68) : BV:8
70 : ite(63, 33, 69) : BV:8
71 : bvconcat(43, 52, 61, 70) : BV:32
72 : ite(18, 2, 71) : BV:32
73 : ite(26, 71, 72) : BV:32
74 : ite(18, 2, 73) : BV:32
75 : lambda(17, 74) : FUNCTION[BV:32 -> BV:32]
76 : map(16, 75) : MAP[BV:32 -> BV:32]
77 : sym_const(76) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda9597 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 184593447 { 0xb00ac27 +1.525367e151 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : 184593444 { 0xb00ac24 +1.525331e151 } : BV:32
22 : eq(20, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 184593445 { 0xb00ac25 +1.525343e151 } : BV:32
25 : eq(20, 24) : BOOL
26 : 184593446 { 0xb00ac26 +1.525355e151 } : BV:32
27 : eq(20, 26) : BOOL
28 : eq(20, 17) : BOOL
29 : 5 { 0x5 } : BV:8
30 : ite(28, 23, 29) : BV:8
31 : ite(27, 23, 30) : BV:8
32 : ite(25, 23, 31) : BV:8
33 : ite(22, 23, 32) : BV:8
34 : bvadd(26, 19) : BV:32
35 : eq(34, 21) : BOOL
36 : eq(34, 24) : BOOL
37 : eq(34, 26) : BOOL
38 : eq(34, 17) : BOOL
39 : ite(38, 23, 29) : BV:8
40 : ite(37, 23, 39) : BV:8
41 : ite(36, 23, 40) : BV:8
42 : ite(35, 23, 41) : BV:8
43 : bvadd(24, 19) : BV:32
44 : eq(43, 21) : BOOL
45 : eq(43, 24) : BOOL
46 : eq(43, 26) : BOOL
47 : eq(43, 17) : BOOL
48 : ite(47, 23, 29) : BV:8
49 : ite(46, 23, 48) : BV:8
50 : ite(45, 23, 49) : BV:8
51 : ite(44, 23, 50) : BV:8
52 : bvadd(21, 19) : BV:32
53 : eq(52, 21) : BOOL
54 : eq(52, 24) : BOOL
55 : eq(52, 26) : BOOL
56 : eq(52, 17) : BOOL
57 : ite(56, 23, 29) : BV:8
58 : ite(55, 23, 57) : BV:8
59 : ite(54, 23, 58) : BV:8
60 : ite(53, 23, 59) : BV:8
61 : bvconcat(33, 42, 51, 60) : BV:32
62 : ite(3, 2, 61) : BV:32
63 : ite(16, 61, 62) : BV:32
64 : ite(3, 2, 63) : BV:32
65 : lambda(1, 64) : FUNCTION[BV:32 -> BV:32]
66 : sym_const(65) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1047 : BV:32
4 : Lambda9637 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda9638 : BV:32
7 : 14449987 { 0xdc7d43 +1.72257268e130 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda9599 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 184593447 { 0xb00ac27 +1.525367e151 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : 184593444 { 0xb00ac24 +1.525331e151 } : BV:32
9 : eq(7, 8) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 184593445 { 0xb00ac25 +1.525343e151 } : BV:32
12 : eq(7, 11) : BOOL
13 : 184593446 { 0xb00ac26 +1.525355e151 } : BV:32
14 : eq(7, 13) : BOOL
15 : eq(7, 4) : BOOL
16 : 5 { 0x5 } : BV:8
17 : ite(15, 10, 16) : BV:8
18 : ite(14, 10, 17) : BV:8
19 : ite(12, 10, 18) : BV:8
20 : ite(9, 10, 19) : BV:8
21 : bvadd(13, 6) : BV:32
22 : eq(21, 8) : BOOL
23 : eq(21, 11) : BOOL
24 : eq(21, 13) : BOOL
25 : eq(21, 4) : BOOL
26 : ite(25, 10, 16) : BV:8
27 : ite(24, 10, 26) : BV:8
28 : ite(23, 10, 27) : BV:8
29 : ite(22, 10, 28) : BV:8
30 : bvadd(11, 6) : BV:32
31 : eq(30, 8) : BOOL
32 : eq(30, 11) : BOOL
33 : eq(30, 13) : BOOL
34 : eq(30, 4) : BOOL
35 : ite(34, 10, 16) : BV:8
36 : ite(33, 10, 35) : BV:8
37 : ite(32, 10, 36) : BV:8
38 : ite(31, 10, 37) : BV:8
39 : bvadd(8, 6) : BV:32
40 : eq(39, 8) : BOOL
41 : eq(39, 11) : BOOL
42 : eq(39, 13) : BOOL
43 : eq(39, 4) : BOOL
44 : ite(43, 10, 16) : BV:8
45 : ite(42, 10, 44) : BV:8
46 : ite(41, 10, 45) : BV:8
47 : ite(40, 10, 46) : BV:8
48 : bvconcat(20, 29, 38, 47) : BV:32
49 : ite(3, 2, 48) : BV:32
50 : lambda(1, 49) : FUNCTION[BV:32 -> BV:32]
51 : sym_const(50) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 184593444 { 0xb00ac24 +1.525331e151 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1046 : BV:32
4 : Lambda9635 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda9636 : BV:32
7 : 714042082 { 0x2a8f6ae2 +1.12044930e214 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 184593443 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 184593444; 184593447 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 184593448; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1073741828; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 184593443 ] -> 5, [ 184593444; 184593447 ] -> 0, [ 184593448; 4294967295 ] -> 5, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 67108864 { 0x4000000 +1.0e137 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1073741827 { 0x40000003 +1.35e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
839679475
=counter_example_end
=global nodece 42 num_edges_traversed 0
=global nodece 42 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 43
=global nodece 43 nodece z3.ce1918.num_edges_traversed3
=global nodece 43 nodece_path
=global nodece 43 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 43 nodece_cached_counterexample
=counter_example_begin z3.ce1918 50a843fbde9f3aa7723d06fdf2cf9ec
=nextpc_const.1
1 : 1393462095 { 0x530e8b4f +1.11362636e39 } : BV:32
=input.spec-%var-arr-1
1 : Lambda3773 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3774 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda3777 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3778 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform339 : BV:32
4 : Lambda3781 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3782 : BV:32
7 : 2027212428 { 0x78d4ce8c +1.66255331e114 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda3749 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 547649092 { 0x20a47644 +1.28485918e194 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1929044644 { 0x72fae2a4 +1.96004152e102 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 92 , m_adder -> 117), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1393462095 , 1000 , 8 ) -> 255197840, () -> 305679533, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1103 : BV:32
5 : Lambda9749 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda9750 : BV:32
8 : 1775239482 { 0x69d0013a +1.62503743e84 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 764162410 { 0x2d8c316a +1.9525799e220 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 255197839 ] -> 0, [ 255197840; 255197840 ] -> 0, [ 255197841; 255197841 ] -> 0, [ 255197842; 255197842 ] -> 0, [ 255197843; 255197843 ] -> 0, [ 255197844; 255197844 ] -> 0, [ 255197845; 255197845 ] -> 0, [ 255197846; 255197846 ] -> 0, [ 255197847; 255197847 ] -> 0, [ 255197848; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1873790124 { 0x6fafc4ac +1.37318944e96 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 255197839 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 255197840; 255197847 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 255197848; 547649091 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 547649092; 547649095 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 547649096; 1929044643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1929044644; 1929044647 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1929044648; 3992977400 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3992977401; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 887353763 { 0x34e3f1a3 +1.78081166e234 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1317203936 { 0x4e82efe0 +1.2294540e30 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 255197840 { 0xf360290 +1.42195320e159 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 141001227 { 0x867820b +1.80865609e145 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1929044644 { 0x72fae2a4 +1.96004152e102 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1929044647 { 0x72fae2a7 +1.96004188e102 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 547649092 { 0x20a47644 +1.28485918e194 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 547649095 { 0x20a47647 +1.28485953e194 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 92 , m_adder -> 117), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2000757753
=counter_example_end
=global nodece 43 num_edges_traversed 3
=global nodece 43 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 44
=global nodece 44 nodece z3.ce1971.num_edges_traversed4
=global nodece 44 nodece_path
=global nodece 44 nodece_path.graph_edge_composition
(epsilon)
=global nodece 44 nodece_cached_counterexample
=counter_example_begin z3.ce1971 233751a58fed6bb5bb65f8883d9d1
=nextpc_const.1
1 : 1393462095 { 0x530e8b4f +1.11362636e39 } : BV:32
=input.spec-%var-arr-1
1 : Lambda3773 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3774 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda3777 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3778 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform339 : BV:32
4 : Lambda3781 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3782 : BV:32
7 : 2027212428 { 0x78d4ce8c +1.66255331e114 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda3749 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 547649092 { 0x20a47644 +1.28485918e194 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1929044644 { 0x72fae2a4 +1.96004152e102 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 92 , m_adder -> 117), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1393462095 , 1000 , 8 ) -> 255197840, () -> 305679533, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1103 : BV:32
5 : Lambda9749 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda9750 : BV:32
8 : 1775239482 { 0x69d0013a +1.62503743e84 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 764162410 { 0x2d8c316a +1.9525799e220 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 255197839 ] -> 0, [ 255197840; 255197840 ] -> 0, [ 255197841; 255197841 ] -> 0, [ 255197842; 255197842 ] -> 0, [ 255197843; 255197843 ] -> 0, [ 255197844; 255197844 ] -> 0, [ 255197845; 255197845 ] -> 0, [ 255197846; 255197846 ] -> 0, [ 255197847; 255197847 ] -> 0, [ 255197848; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1873790124 { 0x6fafc4ac +1.37318944e96 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 255197839 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 255197840; 255197847 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 255197848; 547649091 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 547649092; 547649095 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 547649096; 1929044643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1929044644; 1929044647 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1929044648; 3992977400 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3992977401; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 887353763 { 0x34e3f1a3 +1.78081166e234 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1317203936 { 0x4e82efe0 +1.2294540e30 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 255197840 { 0xf360290 +1.42195320e159 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 141001227 { 0x867820b +1.80865609e145 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1929044644 { 0x72fae2a4 +1.96004152e102 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1929044647 { 0x72fae2a7 +1.96004188e102 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 547649092 { 0x20a47644 +1.28485918e194 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 547649095 { 0x20a47647 +1.28485953e194 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 92 , m_adder -> 117), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2000757753
=counter_example_end
=global nodece 44 num_edges_traversed 4
=global nodece 44 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 45
=global nodece 45 nodece z3.ce1975.num_edges_traversed5
=global nodece 45 nodece_path
=global nodece 45 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 45 nodece_cached_counterexample
=counter_example_begin z3.ce1975 184a3744bb9959ce81241d6f5f70df58
=nextpc_const.1
1 : 1393462095 { 0x530e8b4f +1.11362636e39 } : BV:32
=input.spec-%var-arr-1
1 : Lambda3773 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3774 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda3777 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda3778 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform339 : BV:32
4 : Lambda3781 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda3782 : BV:32
7 : 2027212428 { 0x78d4ce8c +1.66255331e114 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 1048575 ] -> true, [ 1048576; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda3749 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 1048575 { 0xfffff +1.12499988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 1048576 { 0x100000 +1.12500000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 547649092 { 0x20a47644 +1.28485918e194 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 1929044644 { 0x72fae2a4 +1.96004152e102 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4194304 { 0x400000 +1.50000000e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 92 , m_adder -> 117), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1393462095 , 1000 , 8 ) -> 255197840, () -> 305679533, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1103 : BV:32
5 : Lambda9749 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda9750 : BV:32
8 : 1775239482 { 0x69d0013a +1.62503743e84 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 764162410 { 0x2d8c316a +1.9525799e220 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 255197839 ] -> 0, [ 255197840; 255197840 ] -> 0, [ 255197841; 255197841 ] -> 0, [ 255197842; 255197842 ] -> 0, [ 255197843; 255197843 ] -> 0, [ 255197844; 255197844 ] -> 0, [ 255197845; 255197845 ] -> 0, [ 255197846; 255197846 ] -> 0, [ 255197847; 255197847 ] -> 0, [ 255197848; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1873790124 { 0x6fafc4ac +1.37318944e96 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 255197839 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 255197840; 255197847 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 255197848; 547649091 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 547649092; 547649095 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 547649096; 1929044643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1929044644; 1929044647 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 1929044648; 3992977400 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3992977401; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 887353763 { 0x34e3f1a3 +1.78081166e234 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 255197839 ] -> 0, [ 255197840; 255197840 ] -> 0, [ 255197841; 255197841 ] -> 0, [ 255197842; 255197842 ] -> 0, [ 255197843; 255197843 ] -> 0, [ 255197844; 255197844 ] -> 0, [ 255197845; 255197845 ] -> 0, [ 255197846; 255197846 ] -> 0, [ 255197847; 255197847 ] -> 0, [ 255197848; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1317203936 { 0x4e82efe0 +1.2294540e30 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 255197840 { 0xf360290 +1.42195320e159 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 141001227 { 0x867820b +1.80865609e145 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 255197840 { 0xf360290 +1.42195320e159 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 1929044644 { 0x72fae2a4 +1.96004152e102 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 1929044647 { 0x72fae2a7 +1.96004188e102 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 547649092 { 0x20a47644 +1.28485918e194 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 547649095 { 0x20a47647 +1.28485953e194 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 92 , m_adder -> 117), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2000757753
=counter_example_end
=global nodece 45 num_edges_traversed 5
=global nodece 45 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 46
=global nodece 46 nodece z3.ce1882.num_edges_traversed2
=global nodece 46 nodece_path
=global nodece 46 nodece_path.graph_edge_composition
(epsilon)
=global nodece 46 nodece_cached_counterexample
=counter_example_begin z3.ce1882 5cd117acaae1d4255a31f8d499d222b
=nextpc_const.1
1 : 399616787 { 0x17d1ab13 +1.63803327e176 } : BV:32
=input.spec-%var-arr-1
1 : Lambda7251 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 511 { 0x1ff +1.6091e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 512 { 0x200 +1.6103e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7252 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 512 { 0x200 +1.6103e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda7255 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 511 { 0x1ff +1.6091e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 512 { 0x200 +1.6103e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7256 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 511 ] -> true, [ 512; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform743 : BV:32
4 : Lambda7259 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7260 : BV:32
7 : 1385382022 { 0x52934086 +1.15040659e38 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 511 ] -> true, [ 512; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda7219 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 511 { 0x1ff +1.6091e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 512 { 0x200 +1.6103e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1039940972 { 0x3dfc3d6c +1.97062444e252 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 79309544 { 0x4ba2ae8 +1.45443439e138 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 59 , m_adder -> 138), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 399616787 , 1000 , 8 ) -> 1503266444, () -> 318883397, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1089 : BV:32
5 : Lambda9721 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda9722 : BV:32
8 : 1364860540 { 0x515a1e7c +1.70405530e35 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 779183728 { 0x2e716670 +1.88593864e221 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1503266443 ] -> 0, [ 1503266444; 1503266444 ] -> 0, [ 1503266445; 1503266445 ] -> 0, [ 1503266446; 1503266446 ] -> 0, [ 1503266447; 1503266447 ] -> 0, [ 1503266448; 1503266448 ] -> 0, [ 1503266449; 1503266449 ] -> 0, [ 1503266450; 1503266450 ] -> 0, [ 1503266451; 1503266451 ] -> 0, [ 1503266452; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1881458479 { 0x7024c72f +1.28732860e97 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 79309543 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 79309544; 79309547 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 79309548; 1039940971 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1039940972; 1039940975 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1039940976; 1098907643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1098907644; 1503266443 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1503266444; 1503266451 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1503266452; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1902904941 { 0x716c066d +1.84394609e99 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 401876621 { 0x17f4268d +1.90742647e176 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1503266444 { 0x599a068c +1.20332479e52 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1540806114 { 0x5bd6d5e2 +1.67840218e56 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 79309544 { 0x4ba2ae8 +1.45443439e138 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 79309547 { 0x4ba2aeb +1.45443475e138 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1039940972 { 0x3dfc3d6c +1.97062444e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1039940975 { 0x3dfc3d6f +1.97062480e252 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 59 , m_adder -> 138), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2647757757
=counter_example_end
=global nodece 46 num_edges_traversed 2
=global nodece 46 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 47
=global nodece 47 nodece z3.ce2004.num_edges_traversed3
=global nodece 47 nodece_path
=global nodece 47 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 47 nodece_cached_counterexample
=counter_example_begin z3.ce2004 86939dd79ee7ef4a20c8632f9bdfb1b3
=nextpc_const.1
1 : 399616787 { 0x17d1ab13 +1.63803327e176 } : BV:32
=input.spec-%var-arr-1
1 : Lambda7251 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 511 { 0x1ff +1.6091e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 512 { 0x200 +1.6103e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7252 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 512 { 0x200 +1.6103e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda7255 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 511 { 0x1ff +1.6091e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 512 { 0x200 +1.6103e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7256 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 511 ] -> true, [ 512; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform743 : BV:32
4 : Lambda7259 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7260 : BV:32
7 : 1385382022 { 0x52934086 +1.15040659e38 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 511 ] -> true, [ 512; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda7219 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 511 { 0x1ff +1.6091e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 512 { 0x200 +1.6103e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1039940972 { 0x3dfc3d6c +1.97062444e252 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 79309544 { 0x4ba2ae8 +1.45443439e138 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 59 , m_adder -> 138), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 399616787 , 1000 , 8 ) -> 1503266444, () -> 318883397, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1089 : BV:32
5 : Lambda9721 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda9722 : BV:32
8 : 1364860540 { 0x515a1e7c +1.70405530e35 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 779183728 { 0x2e716670 +1.88593864e221 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1503266443 ] -> 0, [ 1503266444; 1503266444 ] -> 0, [ 1503266445; 1503266445 ] -> 0, [ 1503266446; 1503266446 ] -> 0, [ 1503266447; 1503266447 ] -> 0, [ 1503266448; 1503266448 ] -> 0, [ 1503266449; 1503266449 ] -> 0, [ 1503266450; 1503266450 ] -> 0, [ 1503266451; 1503266451 ] -> 0, [ 1503266452; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1881458479 { 0x7024c72f +1.28732860e97 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 79309543 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 79309544; 79309547 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 79309548; 1039940971 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1039940972; 1039940975 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1039940976; 1098907643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1098907644; 1503266443 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1503266444; 1503266451 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1503266452; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1902904941 { 0x716c066d +1.84394609e99 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 401876621 { 0x17f4268d +1.90742647e176 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1503266444 { 0x599a068c +1.20332479e52 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1540806114 { 0x5bd6d5e2 +1.67840218e56 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 79309544 { 0x4ba2ae8 +1.45443439e138 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 79309547 { 0x4ba2aeb +1.45443475e138 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1039940972 { 0x3dfc3d6c +1.97062444e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1039940975 { 0x3dfc3d6f +1.97062480e252 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 59 , m_adder -> 138), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2647757757
=counter_example_end
=global nodece 47 num_edges_traversed 3
=global nodece 47 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 48
=global nodece 48 nodece z3.ce2014.num_edges_traversed4
=global nodece 48 nodece_path
=global nodece 48 nodece_path.graph_edge_composition
(epsilon)
=global nodece 48 nodece_cached_counterexample
=counter_example_begin z3.ce2014 704e25214b7c768a784a2e6ccb56b2c2
=nextpc_const.1
1 : 399616787 { 0x17d1ab13 +1.63803327e176 } : BV:32
=input.spec-%var-arr-1
1 : Lambda7251 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 511 { 0x1ff +1.6091e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 512 { 0x200 +1.6103e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7252 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 512 { 0x200 +1.6103e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda7255 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 511 { 0x1ff +1.6091e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 512 { 0x200 +1.6103e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda7256 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 511 ] -> true, [ 512; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform743 : BV:32
4 : Lambda7259 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda7260 : BV:32
7 : 1385382022 { 0x52934086 +1.15040659e38 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 511 ] -> true, [ 512; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda7219 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 511 { 0x1ff +1.6091e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 512 { 0x200 +1.6103e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1039940972 { 0x3dfc3d6c +1.97062444e252 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 79309544 { 0x4ba2ae8 +1.45443439e138 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 59 , m_adder -> 138), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 399616787 , 1000 , 8 ) -> 1503266444, () -> 318883397, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1089 : BV:32
5 : Lambda9721 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda9722 : BV:32
8 : 1364860540 { 0x515a1e7c +1.70405530e35 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 779183728 { 0x2e716670 +1.88593864e221 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1503266443 ] -> 0, [ 1503266444; 1503266444 ] -> 0, [ 1503266445; 1503266445 ] -> 0, [ 1503266446; 1503266446 ] -> 0, [ 1503266447; 1503266447 ] -> 0, [ 1503266448; 1503266448 ] -> 0, [ 1503266449; 1503266449 ] -> 0, [ 1503266450; 1503266450 ] -> 0, [ 1503266451; 1503266451 ] -> 0, [ 1503266452; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1881458479 { 0x7024c72f +1.28732860e97 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 79309543 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 79309544; 79309547 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 79309548; 1039940971 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1039940972; 1039940975 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1039940976; 1098907643 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1098907644; 1503266443 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1503266444; 1503266451 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1503266452; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1902904941 { 0x716c066d +1.84394609e99 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1503266443 ] -> 0, [ 1503266444; 1503266444 ] -> 0, [ 1503266445; 1503266445 ] -> 0, [ 1503266446; 1503266446 ] -> 0, [ 1503266447; 1503266447 ] -> 0, [ 1503266448; 1503266448 ] -> 0, [ 1503266449; 1503266449 ] -> 0, [ 1503266450; 1503266450 ] -> 0, [ 1503266451; 1503266451 ] -> 0, [ 1503266452; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 401876621 { 0x17f4268d +1.90742647e176 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1503266444 { 0x599a068c +1.20332479e52 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1540806114 { 0x5bd6d5e2 +1.67840218e56 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1503266444 { 0x599a068c +1.20332479e52 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 79309544 { 0x4ba2ae8 +1.45443439e138 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 79309547 { 0x4ba2aeb +1.45443475e138 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1039940972 { 0x3dfc3d6c +1.97062444e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1039940975 { 0x3dfc3d6f +1.97062480e252 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 59 , m_adder -> 138), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
2647757757
=counter_example_end
=global nodece 48 num_edges_traversed 4
=global nodece 48 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 49
=global nodece 49 nodece z3.ce1857.num_edges_traversed1
=global nodece 49 nodece_path
=global nodece 49 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 49 nodece_cached_counterexample
=counter_example_begin z3.ce1857 df63af3a972ec118c261bcc8cee863c
=input.spec-%var-arr-1
1 : Lambda9612 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 524288 { 0x80000 +1.6250000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9613 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
32 : eq(30, 31) : BOOL
33 : 0 { 0x0 } : BV:8
34 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
35 : eq(30, 34) : BOOL
36 : eq(30, 27) : BOOL
37 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
38 : eq(30, 37) : BOOL
39 : 3 { 0x3 } : BV:8
40 : ite(38, 33, 39) : BV:8
41 : ite(36, 33, 40) : BV:8
42 : ite(35, 33, 41) : BV:8
43 : ite(32, 33, 42) : BV:8
44 : bvadd(31, 29) : BV:32
45 : eq(44, 31) : BOOL
46 : eq(44, 34) : BOOL
47 : eq(44, 27) : BOOL
48 : eq(44, 37) : BOOL
49 : ite(48, 33, 39) : BV:8
50 : ite(47, 33, 49) : BV:8
51 : ite(46, 33, 50) : BV:8
52 : ite(45, 33, 51) : BV:8
53 : bvadd(37, 29) : BV:32
54 : eq(53, 31) : BOOL
55 : eq(53, 34) : BOOL
56 : eq(53, 27) : BOOL
57 : eq(53, 37) : BOOL
58 : ite(57, 33, 39) : BV:8
59 : ite(56, 33, 58) : BV:8
60 : ite(55, 33, 59) : BV:8
61 : ite(54, 33, 60) : BV:8
62 : bvadd(34, 29) : BV:32
63 : eq(62, 31) : BOOL
64 : eq(62, 34) : BOOL
65 : eq(62, 27) : BOOL
66 : eq(62, 37) : BOOL
67 : ite(66, 33, 39) : BV:8
68 : ite(65, 33, 67) : BV:8
69 : ite(64, 33, 68) : BV:8
70 : ite(63, 33, 69) : BV:8
71 : bvconcat(43, 52, 61, 70) : BV:32
72 : ite(18, 2, 71) : BV:32
73 : ite(26, 71, 72) : BV:32
74 : ite(18, 2, 73) : BV:32
75 : lambda(17, 74) : FUNCTION[BV:32 -> BV:32]
76 : map(16, 75) : MAP[BV:32 -> BV:32]
77 : sym_const(76) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda9615 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 524288 { 0x80000 +1.6250000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9616 : BV:32
18 : eq(17, 2) : BOOL
19 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
24 : eq(22, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
27 : eq(22, 26) : BOOL
28 : eq(22, 19) : BOOL
29 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
30 : eq(22, 29) : BOOL
31 : 3 { 0x3 } : BV:8
32 : ite(30, 25, 31) : BV:8
33 : ite(28, 25, 32) : BV:8
34 : ite(27, 25, 33) : BV:8
35 : ite(24, 25, 34) : BV:8
36 : bvadd(23, 21) : BV:32
37 : eq(36, 23) : BOOL
38 : eq(36, 26) : BOOL
39 : eq(36, 19) : BOOL
40 : eq(36, 29) : BOOL
41 : ite(40, 25, 31) : BV:8
42 : ite(39, 25, 41) : BV:8
43 : ite(38, 25, 42) : BV:8
44 : ite(37, 25, 43) : BV:8
45 : bvadd(29, 21) : BV:32
46 : eq(45, 23) : BOOL
47 : eq(45, 26) : BOOL
48 : eq(45, 19) : BOOL
49 : eq(45, 29) : BOOL
50 : ite(49, 25, 31) : BV:8
51 : ite(48, 25, 50) : BV:8
52 : ite(47, 25, 51) : BV:8
53 : ite(46, 25, 52) : BV:8
54 : bvadd(26, 21) : BV:32
55 : eq(54, 23) : BOOL
56 : eq(54, 26) : BOOL
57 : eq(54, 19) : BOOL
58 : eq(54, 29) : BOOL
59 : ite(58, 25, 31) : BV:8
60 : ite(57, 25, 59) : BV:8
61 : ite(56, 25, 60) : BV:8
62 : ite(55, 25, 61) : BV:8
63 : bvconcat(35, 44, 53, 62) : BV:32
64 : ite(18, 2, 63) : BV:32
65 : lambda(17, 64) : FUNCTION[BV:32 -> BV:32]
66 : map(16, 65) : MAP[BV:32 -> BV:32]
67 : sym_const(66) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 524287 ] -> true, [ 524288; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda9588 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
9 : eq(7, 8) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
12 : eq(7, 11) : BOOL
13 : eq(7, 4) : BOOL
14 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
15 : eq(7, 14) : BOOL
16 : 3 { 0x3 } : BV:8
17 : ite(15, 10, 16) : BV:8
18 : ite(13, 10, 17) : BV:8
19 : ite(12, 10, 18) : BV:8
20 : ite(9, 10, 19) : BV:8
21 : bvadd(8, 6) : BV:32
22 : eq(21, 8) : BOOL
23 : eq(21, 11) : BOOL
24 : eq(21, 4) : BOOL
25 : eq(21, 14) : BOOL
26 : ite(25, 10, 16) : BV:8
27 : ite(24, 10, 26) : BV:8
28 : ite(23, 10, 27) : BV:8
29 : ite(22, 10, 28) : BV:8
30 : bvadd(14, 6) : BV:32
31 : eq(30, 8) : BOOL
32 : eq(30, 11) : BOOL
33 : eq(30, 4) : BOOL
34 : eq(30, 14) : BOOL
35 : ite(34, 10, 16) : BV:8
36 : ite(33, 10, 35) : BV:8
37 : ite(32, 10, 36) : BV:8
38 : ite(31, 10, 37) : BV:8
39 : bvadd(11, 6) : BV:32
40 : eq(39, 8) : BOOL
41 : eq(39, 11) : BOOL
42 : eq(39, 4) : BOOL
43 : eq(39, 14) : BOOL
44 : ite(43, 10, 16) : BV:8
45 : ite(42, 10, 44) : BV:8
46 : ite(41, 10, 45) : BV:8
47 : ite(40, 10, 46) : BV:8
48 : bvconcat(20, 29, 38, 47) : BV:32
49 : ite(3, 2, 48) : BV:32
50 : lambda(1, 49) : FUNCTION[BV:32 -> BV:32]
51 : sym_const(50) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1043 : BV:32
4 : Lambda9619 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda9620 : BV:32
7 : 1976985272 { 0x75d666b8 +1.67500972e108 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 524287 ] -> true, [ 524288; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda9592 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 524288 { 0x80000 +1.6250000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
22 : eq(20, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
25 : eq(20, 24) : BOOL
26 : eq(20, 17) : BOOL
27 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
28 : eq(20, 27) : BOOL
29 : 3 { 0x3 } : BV:8
30 : ite(28, 23, 29) : BV:8
31 : ite(26, 23, 30) : BV:8
32 : ite(25, 23, 31) : BV:8
33 : ite(22, 23, 32) : BV:8
34 : bvadd(21, 19) : BV:32
35 : eq(34, 21) : BOOL
36 : eq(34, 24) : BOOL
37 : eq(34, 17) : BOOL
38 : eq(34, 27) : BOOL
39 : ite(38, 23, 29) : BV:8
40 : ite(37, 23, 39) : BV:8
41 : ite(36, 23, 40) : BV:8
42 : ite(35, 23, 41) : BV:8
43 : bvadd(27, 19) : BV:32
44 : eq(43, 21) : BOOL
45 : eq(43, 24) : BOOL
46 : eq(43, 17) : BOOL
47 : eq(43, 27) : BOOL
48 : ite(47, 23, 29) : BV:8
49 : ite(46, 23, 48) : BV:8
50 : ite(45, 23, 49) : BV:8
51 : ite(44, 23, 50) : BV:8
52 : bvadd(24, 19) : BV:32
53 : eq(52, 21) : BOOL
54 : eq(52, 24) : BOOL
55 : eq(52, 17) : BOOL
56 : eq(52, 27) : BOOL
57 : ite(56, 23, 29) : BV:8
58 : ite(55, 23, 57) : BV:8
59 : ite(54, 23, 58) : BV:8
60 : ite(53, 23, 59) : BV:8
61 : bvconcat(33, 42, 51, 60) : BV:32
62 : ite(3, 2, 61) : BV:32
63 : ite(16, 61, 62) : BV:32
64 : ite(3, 2, 63) : BV:32
65 : lambda(1, 64) : FUNCTION[BV:32 -> BV:32]
66 : sym_const(65) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2428895236 { 0x90c60004 -1866072060 -1.54687547e162 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3202203688 { 0xbeddc028 -1092763608 -1.73242664e254 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1075 : BV:32
5 : Lambda9693 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda9694 : BV:32
8 : 1667814087 { 0x6368d2c7 +1.81893241e71 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1482579980 { 0x585e600c +1.73730611e49 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1088712247 ] -> 3, [ 1088712248; 1088712251 ] -> 0, [ 1088712252; 4294959103 ] -> 3, [ 4294959104; 4294959104 ] -> 0, [ 4294959105; 4294959105 ] -> 0, [ 4294959106; 4294959106 ] -> 0, [ 4294959107; 4294959107 ] -> 0, [ 4294959108; 4294959108 ] -> 0, [ 4294959109; 4294959109 ] -> 0, [ 4294959110; 4294959110 ] -> 0, [ 4294959111; 4294959111 ] -> 0, [ 4294959112; 4294967295 ] -> 3, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 148665306 { 0x8dc73da +1.72228550e146 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1088712247 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1088712248; 1088712251 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1088712252; 2428895235 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2428895236; 2428895239 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2428895240; 3202203687 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3202203688; 3202203691 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3202203692; 4294959103 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4294959104; 4294959111 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4294959112; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1281088935 { 0x4c5bdda7 +1.71770179e25 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1675085845 { 0x63d7c815 +1.68579351e72 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4294959104 { 0xffffe000 -8192 -1.99902343e128 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 804122035 { 0x2fededb3 +1.85881650e224 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3202203688 { 0xbeddc028 -1092763608 -1.73242664e254 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3202203691 { 0xbeddc02b -1092763605 -1.73242700e254 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2428895236 { 0x90c60004 -1866072060 -1.54687547e162 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2428895239 { 0x90c60007 -1866072057 -1.54687583e162 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2461235881
=counter_example_end
=global nodece 49 num_edges_traversed 1
=global nodece 49 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 50
=global nodece 50 nodece z3.ce2043.num_edges_traversed2
=global nodece 50 nodece_path
=global nodece 50 nodece_path.graph_edge_composition
(epsilon)
=global nodece 50 nodece_cached_counterexample
=counter_example_begin z3.ce2043 e2fc8d4c93f4901da9e4fc2183e84
=input.spec-%var-arr-1
1 : Lambda9612 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 524288 { 0x80000 +1.6250000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9613 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
32 : eq(30, 31) : BOOL
33 : 0 { 0x0 } : BV:8
34 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
35 : eq(30, 34) : BOOL
36 : eq(30, 27) : BOOL
37 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
38 : eq(30, 37) : BOOL
39 : 3 { 0x3 } : BV:8
40 : ite(38, 33, 39) : BV:8
41 : ite(36, 33, 40) : BV:8
42 : ite(35, 33, 41) : BV:8
43 : ite(32, 33, 42) : BV:8
44 : bvadd(31, 29) : BV:32
45 : eq(44, 31) : BOOL
46 : eq(44, 34) : BOOL
47 : eq(44, 27) : BOOL
48 : eq(44, 37) : BOOL
49 : ite(48, 33, 39) : BV:8
50 : ite(47, 33, 49) : BV:8
51 : ite(46, 33, 50) : BV:8
52 : ite(45, 33, 51) : BV:8
53 : bvadd(37, 29) : BV:32
54 : eq(53, 31) : BOOL
55 : eq(53, 34) : BOOL
56 : eq(53, 27) : BOOL
57 : eq(53, 37) : BOOL
58 : ite(57, 33, 39) : BV:8
59 : ite(56, 33, 58) : BV:8
60 : ite(55, 33, 59) : BV:8
61 : ite(54, 33, 60) : BV:8
62 : bvadd(34, 29) : BV:32
63 : eq(62, 31) : BOOL
64 : eq(62, 34) : BOOL
65 : eq(62, 27) : BOOL
66 : eq(62, 37) : BOOL
67 : ite(66, 33, 39) : BV:8
68 : ite(65, 33, 67) : BV:8
69 : ite(64, 33, 68) : BV:8
70 : ite(63, 33, 69) : BV:8
71 : bvconcat(43, 52, 61, 70) : BV:32
72 : ite(18, 2, 71) : BV:32
73 : ite(26, 71, 72) : BV:32
74 : ite(18, 2, 73) : BV:32
75 : lambda(17, 74) : FUNCTION[BV:32 -> BV:32]
76 : map(16, 75) : MAP[BV:32 -> BV:32]
77 : sym_const(76) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda9615 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 524288 { 0x80000 +1.6250000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9616 : BV:32
18 : eq(17, 2) : BOOL
19 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
24 : eq(22, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
27 : eq(22, 26) : BOOL
28 : eq(22, 19) : BOOL
29 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
30 : eq(22, 29) : BOOL
31 : 3 { 0x3 } : BV:8
32 : ite(30, 25, 31) : BV:8
33 : ite(28, 25, 32) : BV:8
34 : ite(27, 25, 33) : BV:8
35 : ite(24, 25, 34) : BV:8
36 : bvadd(23, 21) : BV:32
37 : eq(36, 23) : BOOL
38 : eq(36, 26) : BOOL
39 : eq(36, 19) : BOOL
40 : eq(36, 29) : BOOL
41 : ite(40, 25, 31) : BV:8
42 : ite(39, 25, 41) : BV:8
43 : ite(38, 25, 42) : BV:8
44 : ite(37, 25, 43) : BV:8
45 : bvadd(29, 21) : BV:32
46 : eq(45, 23) : BOOL
47 : eq(45, 26) : BOOL
48 : eq(45, 19) : BOOL
49 : eq(45, 29) : BOOL
50 : ite(49, 25, 31) : BV:8
51 : ite(48, 25, 50) : BV:8
52 : ite(47, 25, 51) : BV:8
53 : ite(46, 25, 52) : BV:8
54 : bvadd(26, 21) : BV:32
55 : eq(54, 23) : BOOL
56 : eq(54, 26) : BOOL
57 : eq(54, 19) : BOOL
58 : eq(54, 29) : BOOL
59 : ite(58, 25, 31) : BV:8
60 : ite(57, 25, 59) : BV:8
61 : ite(56, 25, 60) : BV:8
62 : ite(55, 25, 61) : BV:8
63 : bvconcat(35, 44, 53, 62) : BV:32
64 : ite(18, 2, 63) : BV:32
65 : lambda(17, 64) : FUNCTION[BV:32 -> BV:32]
66 : map(16, 65) : MAP[BV:32 -> BV:32]
67 : sym_const(66) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 524287 ] -> true, [ 524288; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda9588 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
9 : eq(7, 8) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
12 : eq(7, 11) : BOOL
13 : eq(7, 4) : BOOL
14 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
15 : eq(7, 14) : BOOL
16 : 3 { 0x3 } : BV:8
17 : ite(15, 10, 16) : BV:8
18 : ite(13, 10, 17) : BV:8
19 : ite(12, 10, 18) : BV:8
20 : ite(9, 10, 19) : BV:8
21 : bvadd(8, 6) : BV:32
22 : eq(21, 8) : BOOL
23 : eq(21, 11) : BOOL
24 : eq(21, 4) : BOOL
25 : eq(21, 14) : BOOL
26 : ite(25, 10, 16) : BV:8
27 : ite(24, 10, 26) : BV:8
28 : ite(23, 10, 27) : BV:8
29 : ite(22, 10, 28) : BV:8
30 : bvadd(14, 6) : BV:32
31 : eq(30, 8) : BOOL
32 : eq(30, 11) : BOOL
33 : eq(30, 4) : BOOL
34 : eq(30, 14) : BOOL
35 : ite(34, 10, 16) : BV:8
36 : ite(33, 10, 35) : BV:8
37 : ite(32, 10, 36) : BV:8
38 : ite(31, 10, 37) : BV:8
39 : bvadd(11, 6) : BV:32
40 : eq(39, 8) : BOOL
41 : eq(39, 11) : BOOL
42 : eq(39, 4) : BOOL
43 : eq(39, 14) : BOOL
44 : ite(43, 10, 16) : BV:8
45 : ite(42, 10, 44) : BV:8
46 : ite(41, 10, 45) : BV:8
47 : ite(40, 10, 46) : BV:8
48 : bvconcat(20, 29, 38, 47) : BV:32
49 : ite(3, 2, 48) : BV:32
50 : lambda(1, 49) : FUNCTION[BV:32 -> BV:32]
51 : sym_const(50) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1043 : BV:32
4 : Lambda9619 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda9620 : BV:32
7 : 1976985272 { 0x75d666b8 +1.67500972e108 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 524287 ] -> true, [ 524288; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda9592 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 524288 { 0x80000 +1.6250000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
22 : eq(20, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
25 : eq(20, 24) : BOOL
26 : eq(20, 17) : BOOL
27 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
28 : eq(20, 27) : BOOL
29 : 3 { 0x3 } : BV:8
30 : ite(28, 23, 29) : BV:8
31 : ite(26, 23, 30) : BV:8
32 : ite(25, 23, 31) : BV:8
33 : ite(22, 23, 32) : BV:8
34 : bvadd(21, 19) : BV:32
35 : eq(34, 21) : BOOL
36 : eq(34, 24) : BOOL
37 : eq(34, 17) : BOOL
38 : eq(34, 27) : BOOL
39 : ite(38, 23, 29) : BV:8
40 : ite(37, 23, 39) : BV:8
41 : ite(36, 23, 40) : BV:8
42 : ite(35, 23, 41) : BV:8
43 : bvadd(27, 19) : BV:32
44 : eq(43, 21) : BOOL
45 : eq(43, 24) : BOOL
46 : eq(43, 17) : BOOL
47 : eq(43, 27) : BOOL
48 : ite(47, 23, 29) : BV:8
49 : ite(46, 23, 48) : BV:8
50 : ite(45, 23, 49) : BV:8
51 : ite(44, 23, 50) : BV:8
52 : bvadd(24, 19) : BV:32
53 : eq(52, 21) : BOOL
54 : eq(52, 24) : BOOL
55 : eq(52, 17) : BOOL
56 : eq(52, 27) : BOOL
57 : ite(56, 23, 29) : BV:8
58 : ite(55, 23, 57) : BV:8
59 : ite(54, 23, 58) : BV:8
60 : ite(53, 23, 59) : BV:8
61 : bvconcat(33, 42, 51, 60) : BV:32
62 : ite(3, 2, 61) : BV:32
63 : ite(16, 61, 62) : BV:32
64 : ite(3, 2, 63) : BV:32
65 : lambda(1, 64) : FUNCTION[BV:32 -> BV:32]
66 : sym_const(65) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2428895236 { 0x90c60004 -1866072060 -1.54687547e162 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3202203688 { 0xbeddc028 -1092763608 -1.73242664e254 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1075 : BV:32
5 : Lambda9693 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda9694 : BV:32
8 : 1667814087 { 0x6368d2c7 +1.81893241e71 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1482579980 { 0x585e600c +1.73730611e49 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1088712247 ] -> 3, [ 1088712248; 1088712251 ] -> 0, [ 1088712252; 4294959103 ] -> 3, [ 4294959104; 4294959104 ] -> 0, [ 4294959105; 4294959105 ] -> 0, [ 4294959106; 4294959106 ] -> 0, [ 4294959107; 4294959107 ] -> 0, [ 4294959108; 4294959108 ] -> 0, [ 4294959109; 4294959109 ] -> 0, [ 4294959110; 4294959110 ] -> 0, [ 4294959111; 4294959111 ] -> 0, [ 4294959112; 4294967295 ] -> 3, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 148665306 { 0x8dc73da +1.72228550e146 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1088712247 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1088712248; 1088712251 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1088712252; 2428895235 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2428895236; 2428895239 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2428895240; 3202203687 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3202203688; 3202203691 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3202203692; 4294959103 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4294959104; 4294959111 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4294959112; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1281088935 { 0x4c5bdda7 +1.71770179e25 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1675085845 { 0x63d7c815 +1.68579351e72 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4294959104 { 0xffffe000 -8192 -1.99902343e128 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 804122035 { 0x2fededb3 +1.85881650e224 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3202203688 { 0xbeddc028 -1092763608 -1.73242664e254 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3202203691 { 0xbeddc02b -1092763605 -1.73242700e254 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2428895236 { 0x90c60004 -1866072060 -1.54687547e162 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2428895239 { 0x90c60007 -1866072057 -1.54687583e162 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2461235881
=counter_example_end
=global nodece 50 num_edges_traversed 2
=global nodece 50 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 51
=global nodece 51 nodece z3.ce2047.num_edges_traversed3
=global nodece 51 nodece_path
=global nodece 51 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 51 nodece_cached_counterexample
=counter_example_begin z3.ce2047 df4994c446523142df31e2817f2e10f7
=nextpc_const.1
1 : 1476449922 { 0x5800d682 +1.654625e49 } : BV:32
=input.spec-%var-arr-1
1 : Lambda9612 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 524288 { 0x80000 +1.6250000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9613 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
32 : eq(30, 31) : BOOL
33 : 0 { 0x0 } : BV:8
34 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
35 : eq(30, 34) : BOOL
36 : eq(30, 27) : BOOL
37 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
38 : eq(30, 37) : BOOL
39 : 3 { 0x3 } : BV:8
40 : ite(38, 33, 39) : BV:8
41 : ite(36, 33, 40) : BV:8
42 : ite(35, 33, 41) : BV:8
43 : ite(32, 33, 42) : BV:8
44 : bvadd(31, 29) : BV:32
45 : eq(44, 31) : BOOL
46 : eq(44, 34) : BOOL
47 : eq(44, 27) : BOOL
48 : eq(44, 37) : BOOL
49 : ite(48, 33, 39) : BV:8
50 : ite(47, 33, 49) : BV:8
51 : ite(46, 33, 50) : BV:8
52 : ite(45, 33, 51) : BV:8
53 : bvadd(37, 29) : BV:32
54 : eq(53, 31) : BOOL
55 : eq(53, 34) : BOOL
56 : eq(53, 27) : BOOL
57 : eq(53, 37) : BOOL
58 : ite(57, 33, 39) : BV:8
59 : ite(56, 33, 58) : BV:8
60 : ite(55, 33, 59) : BV:8
61 : ite(54, 33, 60) : BV:8
62 : bvadd(34, 29) : BV:32
63 : eq(62, 31) : BOOL
64 : eq(62, 34) : BOOL
65 : eq(62, 27) : BOOL
66 : eq(62, 37) : BOOL
67 : ite(66, 33, 39) : BV:8
68 : ite(65, 33, 67) : BV:8
69 : ite(64, 33, 68) : BV:8
70 : ite(63, 33, 69) : BV:8
71 : bvconcat(43, 52, 61, 70) : BV:32
72 : ite(18, 2, 71) : BV:32
73 : ite(26, 71, 72) : BV:32
74 : ite(18, 2, 73) : BV:32
75 : lambda(17, 74) : FUNCTION[BV:32 -> BV:32]
76 : map(16, 75) : MAP[BV:32 -> BV:32]
77 : sym_const(76) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 524288 { 0x80000 +1.6250000e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda9615 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 524288 { 0x80000 +1.6250000e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9616 : BV:32
18 : eq(17, 2) : BOOL
19 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
24 : eq(22, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
27 : eq(22, 26) : BOOL
28 : eq(22, 19) : BOOL
29 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
30 : eq(22, 29) : BOOL
31 : 3 { 0x3 } : BV:8
32 : ite(30, 25, 31) : BV:8
33 : ite(28, 25, 32) : BV:8
34 : ite(27, 25, 33) : BV:8
35 : ite(24, 25, 34) : BV:8
36 : bvadd(23, 21) : BV:32
37 : eq(36, 23) : BOOL
38 : eq(36, 26) : BOOL
39 : eq(36, 19) : BOOL
40 : eq(36, 29) : BOOL
41 : ite(40, 25, 31) : BV:8
42 : ite(39, 25, 41) : BV:8
43 : ite(38, 25, 42) : BV:8
44 : ite(37, 25, 43) : BV:8
45 : bvadd(29, 21) : BV:32
46 : eq(45, 23) : BOOL
47 : eq(45, 26) : BOOL
48 : eq(45, 19) : BOOL
49 : eq(45, 29) : BOOL
50 : ite(49, 25, 31) : BV:8
51 : ite(48, 25, 50) : BV:8
52 : ite(47, 25, 51) : BV:8
53 : ite(46, 25, 52) : BV:8
54 : bvadd(26, 21) : BV:32
55 : eq(54, 23) : BOOL
56 : eq(54, 26) : BOOL
57 : eq(54, 19) : BOOL
58 : eq(54, 29) : BOOL
59 : ite(58, 25, 31) : BV:8
60 : ite(57, 25, 59) : BV:8
61 : ite(56, 25, 60) : BV:8
62 : ite(55, 25, 61) : BV:8
63 : bvconcat(35, 44, 53, 62) : BV:32
64 : ite(18, 2, 63) : BV:32
65 : lambda(17, 64) : FUNCTION[BV:32 -> BV:32]
66 : map(16, 65) : MAP[BV:32 -> BV:32]
67 : sym_const(66) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 524287 ] -> true, [ 524288; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda9588 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
9 : eq(7, 8) : BOOL
10 : 0 { 0x0 } : BV:8
11 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
12 : eq(7, 11) : BOOL
13 : eq(7, 4) : BOOL
14 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
15 : eq(7, 14) : BOOL
16 : 3 { 0x3 } : BV:8
17 : ite(15, 10, 16) : BV:8
18 : ite(13, 10, 17) : BV:8
19 : ite(12, 10, 18) : BV:8
20 : ite(9, 10, 19) : BV:8
21 : bvadd(8, 6) : BV:32
22 : eq(21, 8) : BOOL
23 : eq(21, 11) : BOOL
24 : eq(21, 4) : BOOL
25 : eq(21, 14) : BOOL
26 : ite(25, 10, 16) : BV:8
27 : ite(24, 10, 26) : BV:8
28 : ite(23, 10, 27) : BV:8
29 : ite(22, 10, 28) : BV:8
30 : bvadd(14, 6) : BV:32
31 : eq(30, 8) : BOOL
32 : eq(30, 11) : BOOL
33 : eq(30, 4) : BOOL
34 : eq(30, 14) : BOOL
35 : ite(34, 10, 16) : BV:8
36 : ite(33, 10, 35) : BV:8
37 : ite(32, 10, 36) : BV:8
38 : ite(31, 10, 37) : BV:8
39 : bvadd(11, 6) : BV:32
40 : eq(39, 8) : BOOL
41 : eq(39, 11) : BOOL
42 : eq(39, 4) : BOOL
43 : eq(39, 14) : BOOL
44 : ite(43, 10, 16) : BV:8
45 : ite(42, 10, 44) : BV:8
46 : ite(41, 10, 45) : BV:8
47 : ite(40, 10, 46) : BV:8
48 : bvconcat(20, 29, 38, 47) : BV:32
49 : ite(3, 2, 48) : BV:32
50 : lambda(1, 49) : FUNCTION[BV:32 -> BV:32]
51 : sym_const(50) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1043 : BV:32
4 : Lambda9619 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda9620 : BV:32
7 : 1976985272 { 0x75d666b8 +1.67500972e108 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 524287 ] -> true, [ 524288; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda9592 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 524287 { 0x7ffff +1.6249988e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 524288 { 0x80000 +1.6250000e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 1088712251 { 0x40e46e3b +1.78461396e2 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : 1088712250 { 0x40e46e3a +1.78461384e2 } : BV:32
22 : eq(20, 21) : BOOL
23 : 0 { 0x0 } : BV:8
24 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
25 : eq(20, 24) : BOOL
26 : eq(20, 17) : BOOL
27 : 1088712249 { 0x40e46e39 +1.78461372e2 } : BV:32
28 : eq(20, 27) : BOOL
29 : 3 { 0x3 } : BV:8
30 : ite(28, 23, 29) : BV:8
31 : ite(26, 23, 30) : BV:8
32 : ite(25, 23, 31) : BV:8
33 : ite(22, 23, 32) : BV:8
34 : bvadd(21, 19) : BV:32
35 : eq(34, 21) : BOOL
36 : eq(34, 24) : BOOL
37 : eq(34, 17) : BOOL
38 : eq(34, 27) : BOOL
39 : ite(38, 23, 29) : BV:8
40 : ite(37, 23, 39) : BV:8
41 : ite(36, 23, 40) : BV:8
42 : ite(35, 23, 41) : BV:8
43 : bvadd(27, 19) : BV:32
44 : eq(43, 21) : BOOL
45 : eq(43, 24) : BOOL
46 : eq(43, 17) : BOOL
47 : eq(43, 27) : BOOL
48 : ite(47, 23, 29) : BV:8
49 : ite(46, 23, 48) : BV:8
50 : ite(45, 23, 49) : BV:8
51 : ite(44, 23, 50) : BV:8
52 : bvadd(24, 19) : BV:32
53 : eq(52, 21) : BOOL
54 : eq(52, 24) : BOOL
55 : eq(52, 17) : BOOL
56 : eq(52, 27) : BOOL
57 : ite(56, 23, 29) : BV:8
58 : ite(55, 23, 57) : BV:8
59 : ite(54, 23, 58) : BV:8
60 : ite(53, 23, 59) : BV:8
61 : bvconcat(33, 42, 51, 60) : BV:32
62 : ite(3, 2, 61) : BV:32
63 : ite(16, 61, 62) : BV:32
64 : ite(3, 2, 63) : BV:32
65 : lambda(1, 64) : FUNCTION[BV:32 -> BV:32]
66 : sym_const(65) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2428895236 { 0x90c60004 -1866072060 -1.54687547e162 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3202203688 { 0xbeddc028 -1092763608 -1.73242664e254 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 1088712248 { 0x40e46e38 +1.78461360e2 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 219 , m_adder -> 148), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1476449922 , 1000 , 8 ) -> 1856366187, () -> 1463408599, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1075 : BV:32
5 : Lambda9693 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda9694 : BV:32
8 : 1667814087 { 0x6368d2c7 +1.81893241e71 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1482579980 { 0x585e600c +1.73730611e49 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1088712247 ] -> 3, [ 1088712248; 1088712251 ] -> 0, [ 1088712252; 4294959103 ] -> 3, [ 4294959104; 4294959104 ] -> 0, [ 4294959105; 4294959105 ] -> 0, [ 4294959106; 4294959106 ] -> 0, [ 4294959107; 4294959107 ] -> 0, [ 4294959108; 4294959108 ] -> 0, [ 4294959109; 4294959109 ] -> 0, [ 4294959110; 4294959110 ] -> 0, [ 4294959111; 4294959111 ] -> 0, [ 4294959112; 4294967295 ] -> 3, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 148665306 { 0x8dc73da +1.72228550e146 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1088712247 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1088712248; 1088712251 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1088712252; 2428895235 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2428895236; 2428895239 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2428895240; 3202203687 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 3202203688; 3202203691 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3202203692; 4294959103 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4294959104; 4294959111 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 4294959112; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1281088935 { 0x4c5bdda7 +1.71770179e25 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1088712247 ] -> 3, [ 1088712248; 1088712251 ] -> 0, [ 1088712252; 4294959103 ] -> 3, [ 4294959104; 4294959104 ] -> 0, [ 4294959105; 4294959105 ] -> 0, [ 4294959106; 4294959106 ] -> 0, [ 4294959107; 4294959107 ] -> 0, [ 4294959108; 4294959108 ] -> 0, [ 4294959109; 4294959109 ] -> 0, [ 4294959110; 4294959110 ] -> 0, [ 4294959111; 4294959111 ] -> 0, [ 4294959112; 4294967295 ] -> 3, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1675085845 { 0x63d7c815 +1.68579351e72 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4294959104 { 0xffffe000 -8192 -1.99902343e128 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 804122035 { 0x2fededb3 +1.85881650e224 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1856366187 { 0x6ea5e66b +1.29609429e94 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3202203688 { 0xbeddc028 -1092763608 -1.73242664e254 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3202203691 { 0xbeddc02b -1092763605 -1.73242700e254 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2428895236 { 0x90c60004 -1866072060 -1.54687547e162 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2428895239 { 0x90c60007 -1866072057 -1.54687583e162 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 219 , m_adder -> 148), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
4265550445
=counter_example_end
=global nodece 51 num_edges_traversed 3
=global nodece 51 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 52
=global nodece 52 nodece z3.ce2250.num_edges_traversed1
=global nodece 52 nodece_path
=global nodece 52 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 52 nodece_cached_counterexample
=counter_example_begin z3.ce2250 14773b1da57e254d2f7c226b98cb9b6a
=input.spec-%var-arr-1
1 : Lambda9856 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2047 { 0x7ff +1.24402e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2048 { 0x800 +1.24414e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9857 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 3 { 0x3 +1.35e129 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : eq(30, 28) : BOOL
32 : 128 { 0x80 -128 } : BV:8
33 : 3959422771 { 0xebffff33 -335544525 -1.99997556e88 } : BV:32
34 : eq(30, 33) : BOOL
35 : 0 { 0x0 } : BV:8
36 : ite(34, 32, 35) : BV:8
37 : ite(31, 32, 36) : BV:8
38 : 2 { 0x2 +1.23e129 } : BV:32
39 : bvadd(38, 29) : BV:32
40 : eq(39, 28) : BOOL
41 : eq(39, 33) : BOOL
42 : ite(41, 32, 35) : BV:8
43 : ite(40, 32, 42) : BV:8
44 : 1 { 0x1 +1.11e129 } : BV:32
45 : bvadd(44, 29) : BV:32
46 : eq(45, 28) : BOOL
47 : eq(45, 33) : BOOL
48 : ite(47, 32, 35) : BV:8
49 : ite(46, 32, 48) : BV:8
50 : eq(29, 28) : BOOL
51 : eq(29, 33) : BOOL
52 : ite(51, 32, 35) : BV:8
53 : ite(50, 32, 52) : BV:8
54 : bvconcat(37, 43, 49, 53) : BV:32
55 : ite(18, 2, 54) : BV:32
56 : ite(26, 54, 55) : BV:32
57 : ite(18, 2, 56) : BV:32
58 : lambda(17, 57) : FUNCTION[BV:32 -> BV:32]
59 : map(16, 58) : MAP[BV:32 -> BV:32]
60 : sym_const(59) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2048 { 0x800 +1.24414e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda9859 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2047 { 0x7ff +1.24402e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2048 { 0x800 +1.24414e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9860 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : eq(22, 20) : BOOL
24 : 128 { 0x80 -128 } : BV:8
25 : 3959422771 { 0xebffff33 -335544525 -1.99997556e88 } : BV:32
26 : eq(22, 25) : BOOL
27 : 0 { 0x0 } : BV:8
28 : ite(26, 24, 27) : BV:8
29 : ite(23, 24, 28) : BV:8
30 : 2 { 0x2 +1.23e129 } : BV:32
31 : bvadd(30, 21) : BV:32
32 : eq(31, 20) : BOOL
33 : eq(31, 25) : BOOL
34 : ite(33, 24, 27) : BV:8
35 : ite(32, 24, 34) : BV:8
36 : 1 { 0x1 +1.11e129 } : BV:32
37 : bvadd(36, 21) : BV:32
38 : eq(37, 20) : BOOL
39 : eq(37, 25) : BOOL
40 : ite(39, 24, 27) : BV:8
41 : ite(38, 24, 40) : BV:8
42 : eq(21, 20) : BOOL
43 : eq(21, 25) : BOOL
44 : ite(43, 24, 27) : BV:8
45 : ite(42, 24, 44) : BV:8
46 : bvconcat(29, 35, 41, 45) : BV:32
47 : ite(18, 2, 46) : BV:32
48 : lambda(17, 47) : FUNCTION[BV:32 -> BV:32]
49 : map(16, 48) : MAP[BV:32 -> BV:32]
50 : sym_const(49) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2047 ] -> true, [ 2048; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda9828 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : eq(7, 5) : BOOL
9 : 128 { 0x80 -128 } : BV:8
10 : 3959422771 { 0xebffff33 -335544525 -1.99997556e88 } : BV:32
11 : eq(7, 10) : BOOL
12 : 0 { 0x0 } : BV:8
13 : ite(11, 9, 12) : BV:8
14 : ite(8, 9, 13) : BV:8
15 : 2 { 0x2 +1.23e129 } : BV:32
16 : bvadd(15, 6) : BV:32
17 : eq(16, 5) : BOOL
18 : eq(16, 10) : BOOL
19 : ite(18, 9, 12) : BV:8
20 : ite(17, 9, 19) : BV:8
21 : 1 { 0x1 +1.11e129 } : BV:32
22 : bvadd(21, 6) : BV:32
23 : eq(22, 5) : BOOL
24 : eq(22, 10) : BOOL
25 : ite(24, 9, 12) : BV:8
26 : ite(23, 9, 25) : BV:8
27 : eq(6, 5) : BOOL
28 : eq(6, 10) : BOOL
29 : ite(28, 9, 12) : BV:8
30 : ite(27, 9, 29) : BV:8
31 : bvconcat(14, 20, 26, 30) : BV:32
32 : ite(3, 2, 31) : BV:32
33 : lambda(1, 32) : FUNCTION[BV:32 -> BV:32]
34 : sym_const(33) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1115 : BV:32
4 : Lambda9863 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda9864 : BV:32
7 : 1996222969 { 0x76fbf1f9 +1.96832191e110 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2047 ] -> true, [ 2048; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : Lambda9832 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2047 { 0x7ff +1.24402e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2048 { 0x800 +1.24414e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 3 { 0x3 +1.35e129 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : eq(20, 18) : BOOL
22 : 128 { 0x80 -128 } : BV:8
23 : 3959422771 { 0xebffff33 -335544525 -1.99997556e88 } : BV:32
24 : eq(20, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : ite(24, 22, 25) : BV:8
27 : ite(21, 22, 26) : BV:8
28 : 2 { 0x2 +1.23e129 } : BV:32
29 : bvadd(28, 19) : BV:32
30 : eq(29, 18) : BOOL
31 : eq(29, 23) : BOOL
32 : ite(31, 22, 25) : BV:8
33 : ite(30, 22, 32) : BV:8
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : bvadd(34, 19) : BV:32
36 : eq(35, 18) : BOOL
37 : eq(35, 23) : BOOL
38 : ite(37, 22, 25) : BV:8
39 : ite(36, 22, 38) : BV:8
40 : eq(19, 18) : BOOL
41 : eq(19, 23) : BOOL
42 : ite(41, 22, 25) : BV:8
43 : ite(40, 22, 42) : BV:8
44 : bvconcat(27, 33, 39, 43) : BV:32
45 : ite(3, 2, 44) : BV:32
46 : ite(16, 44, 45) : BV:32
47 : ite(3, 2, 46) : BV:32
48 : lambda(1, 47) : FUNCTION[BV:32 -> BV:32]
49 : sym_const(48) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1554688344 { 0x5caaa958 +1.33329296e58 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3189393424 { 0xbe1a4810 -1105573872 -1.20532417e253 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 134217728 { 0x8000000 +1.0e145 } : BV:32
2 : unit : UNIT
3 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : Indxform1114 : BV:32
6 : Lambda9861 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda9862 : BV:32
9 : 1982074169 { 0x76240d39 +1.28165352e109 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(4, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(4, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(4, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 128, [ 5; 3959422770 ] -> 0, [ 3959422771; 3959422771 ] -> 128, [ 3959422772; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1554688343 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1554688344; 1554688347 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1554688348; 3189393423 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3189393424; 3189393427 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3189393428; 3963617279 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3963617280; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 3959422768 { 0xebffff30 -335544528 -1.99997520e88 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 3963617280 { 0xec400000 -331350016 -1.50000000e89 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3189393424 { 0xbe1a4810 -1105573872 -1.20532417e253 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3189393427 { 0xbe1a4813 -1105573869 -1.20532453e253 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1554688344 { 0x5caaa958 +1.33329296e58 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1554688347 { 0x5caaa95b +1.33329331e58 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 134217728 { 0x8000000 +1.0e145 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
489242711
=counter_example_end
=global nodece 52 num_edges_traversed 1
=global nodece 52 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 53
=global nodece 53 nodece z3.ce2264.num_edges_traversed2
=global nodece 53 nodece_path
=global nodece 53 nodece_path.graph_edge_composition
(epsilon)
=global nodece 53 nodece_cached_counterexample
=counter_example_begin z3.ce2264 6f2089fa11352e0b26c57bfb6dfc2f
=nextpc_const.1
1 : 1734223593 { 0x675e26e9 +1.73556244e79 } : BV:32
=input.spec-%var-arr-1
1 : Lambda9856 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2047 { 0x7ff +1.24402e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2048 { 0x800 +1.24414e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9857 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : 3 { 0x3 +1.35e129 } : BV:32
28 : 4 { 0x4 +1.47e129 } : BV:32
29 : bvmul(28, 17) : BV:32
30 : bvadd(27, 29) : BV:32
31 : eq(30, 28) : BOOL
32 : 128 { 0x80 -128 } : BV:8
33 : 3959422771 { 0xebffff33 -335544525 -1.99997556e88 } : BV:32
34 : eq(30, 33) : BOOL
35 : 0 { 0x0 } : BV:8
36 : ite(34, 32, 35) : BV:8
37 : ite(31, 32, 36) : BV:8
38 : 2 { 0x2 +1.23e129 } : BV:32
39 : bvadd(38, 29) : BV:32
40 : eq(39, 28) : BOOL
41 : eq(39, 33) : BOOL
42 : ite(41, 32, 35) : BV:8
43 : ite(40, 32, 42) : BV:8
44 : 1 { 0x1 +1.11e129 } : BV:32
45 : bvadd(44, 29) : BV:32
46 : eq(45, 28) : BOOL
47 : eq(45, 33) : BOOL
48 : ite(47, 32, 35) : BV:8
49 : ite(46, 32, 48) : BV:8
50 : eq(29, 28) : BOOL
51 : eq(29, 33) : BOOL
52 : ite(51, 32, 35) : BV:8
53 : ite(50, 32, 52) : BV:8
54 : bvconcat(37, 43, 49, 53) : BV:32
55 : ite(18, 2, 54) : BV:32
56 : ite(26, 54, 55) : BV:32
57 : ite(18, 2, 56) : BV:32
58 : lambda(17, 57) : FUNCTION[BV:32 -> BV:32]
59 : map(16, 58) : MAP[BV:32 -> BV:32]
60 : sym_const(59) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2048 { 0x800 +1.24414e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda9859 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2047 { 0x7ff +1.24402e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2048 { 0x800 +1.24414e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda9860 : BV:32
18 : eq(17, 2) : BOOL
19 : 3 { 0x3 +1.35e129 } : BV:32
20 : 4 { 0x4 +1.47e129 } : BV:32
21 : bvmul(20, 17) : BV:32
22 : bvadd(19, 21) : BV:32
23 : eq(22, 20) : BOOL
24 : 128 { 0x80 -128 } : BV:8
25 : 3959422771 { 0xebffff33 -335544525 -1.99997556e88 } : BV:32
26 : eq(22, 25) : BOOL
27 : 0 { 0x0 } : BV:8
28 : ite(26, 24, 27) : BV:8
29 : ite(23, 24, 28) : BV:8
30 : 2 { 0x2 +1.23e129 } : BV:32
31 : bvadd(30, 21) : BV:32
32 : eq(31, 20) : BOOL
33 : eq(31, 25) : BOOL
34 : ite(33, 24, 27) : BV:8
35 : ite(32, 24, 34) : BV:8
36 : 1 { 0x1 +1.11e129 } : BV:32
37 : bvadd(36, 21) : BV:32
38 : eq(37, 20) : BOOL
39 : eq(37, 25) : BOOL
40 : ite(39, 24, 27) : BV:8
41 : ite(38, 24, 40) : BV:8
42 : eq(21, 20) : BOOL
43 : eq(21, 25) : BOOL
44 : ite(43, 24, 27) : BV:8
45 : ite(42, 24, 44) : BV:8
46 : bvconcat(29, 35, 41, 45) : BV:32
47 : ite(18, 2, 46) : BV:32
48 : lambda(17, 47) : FUNCTION[BV:32 -> BV:32]
49 : map(16, 48) : MAP[BV:32 -> BV:32]
50 : sym_const(49) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2047 ] -> true, [ 2048; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda9828 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : 4 { 0x4 +1.47e129 } : BV:32
6 : bvmul(5, 1) : BV:32
7 : bvadd(4, 6) : BV:32
8 : eq(7, 5) : BOOL
9 : 128 { 0x80 -128 } : BV:8
10 : 3959422771 { 0xebffff33 -335544525 -1.99997556e88 } : BV:32
11 : eq(7, 10) : BOOL
12 : 0 { 0x0 } : BV:8
13 : ite(11, 9, 12) : BV:8
14 : ite(8, 9, 13) : BV:8
15 : 2 { 0x2 +1.23e129 } : BV:32
16 : bvadd(15, 6) : BV:32
17 : eq(16, 5) : BOOL
18 : eq(16, 10) : BOOL
19 : ite(18, 9, 12) : BV:8
20 : ite(17, 9, 19) : BV:8
21 : 1 { 0x1 +1.11e129 } : BV:32
22 : bvadd(21, 6) : BV:32
23 : eq(22, 5) : BOOL
24 : eq(22, 10) : BOOL
25 : ite(24, 9, 12) : BV:8
26 : ite(23, 9, 25) : BV:8
27 : eq(6, 5) : BOOL
28 : eq(6, 10) : BOOL
29 : ite(28, 9, 12) : BV:8
30 : ite(27, 9, 29) : BV:8
31 : bvconcat(14, 20, 26, 30) : BV:32
32 : ite(3, 2, 31) : BV:32
33 : lambda(1, 32) : FUNCTION[BV:32 -> BV:32]
34 : sym_const(33) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1115 : BV:32
4 : Lambda9863 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda9864 : BV:32
7 : 1996222969 { 0x76fbf1f9 +1.96832191e110 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2047 ] -> true, [ 2048; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : Lambda9832 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2047 { 0x7ff +1.24402e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2048 { 0x800 +1.24414e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : 3 { 0x3 +1.35e129 } : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : bvmul(18, 1) : BV:32
20 : bvadd(17, 19) : BV:32
21 : eq(20, 18) : BOOL
22 : 128 { 0x80 -128 } : BV:8
23 : 3959422771 { 0xebffff33 -335544525 -1.99997556e88 } : BV:32
24 : eq(20, 23) : BOOL
25 : 0 { 0x0 } : BV:8
26 : ite(24, 22, 25) : BV:8
27 : ite(21, 22, 26) : BV:8
28 : 2 { 0x2 +1.23e129 } : BV:32
29 : bvadd(28, 19) : BV:32
30 : eq(29, 18) : BOOL
31 : eq(29, 23) : BOOL
32 : ite(31, 22, 25) : BV:8
33 : ite(30, 22, 32) : BV:8
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : bvadd(34, 19) : BV:32
36 : eq(35, 18) : BOOL
37 : eq(35, 23) : BOOL
38 : ite(37, 22, 25) : BV:8
39 : ite(36, 22, 38) : BV:8
40 : eq(19, 18) : BOOL
41 : eq(19, 23) : BOOL
42 : ite(41, 22, 25) : BV:8
43 : ite(40, 22, 42) : BV:8
44 : bvconcat(27, 33, 39, 43) : BV:32
45 : ite(3, 2, 44) : BV:32
46 : ite(16, 44, 45) : BV:32
47 : ite(3, 2, 46) : BV:32
48 : lambda(1, 47) : FUNCTION[BV:32 -> BV:32]
49 : sym_const(48) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1554688344 { 0x5caaa958 +1.33329296e58 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3189393424 { 0xbe1a4810 -1105573872 -1.20532417e253 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 181 , m_adder -> 168), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1734223593 , 1000 , 8 ) -> 231212711, () -> 828299576, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 134217728 { 0x8000000 +1.0e145 } : BV:32
2 : unit : UNIT
3 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : Indxform1114 : BV:32
6 : Lambda9861 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda9862 : BV:32
9 : 1982074169 { 0x76240d39 +1.28165352e109 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(4, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(4, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(4, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(4, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(1, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 128, [ 5; 3959422770 ] -> 0, [ 3959422771; 3959422771 ] -> 128, [ 3959422772; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1554688343 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1554688344; 1554688347 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1554688348; 3189393423 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3189393424; 3189393427 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3189393428; 3963617279 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3963617280; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 128, [ 5; 3959422770 ] -> 0, [ 3959422771; 3959422771 ] -> 128, [ 3959422772; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 3959422768 { 0xebffff30 -335544528 -1.99997520e88 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 231212711 { 0xdc806a7 +1.56270301e156 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3189393424 { 0xbe1a4810 -1105573872 -1.20532417e253 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3189393427 { 0xbe1a4813 -1105573869 -1.20532453e253 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1554688344 { 0x5caaa958 +1.33329296e58 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1554688347 { 0x5caaa95b +1.33329331e58 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 134217728 { 0x8000000 +1.0e145 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 181 , m_adder -> 168), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1536739131
=counter_example_end
=global nodece 53 num_edges_traversed 2
=global nodece 53 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 54
=global nodece 54 nodece z3v487.ce2285.num_edges_traversed1
=global nodece 54 nodece_path
=global nodece 54 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 54 nodece_cached_counterexample
=counter_example_begin z3v487.ce2285 80df83e2a26da3d3932c8ff6b2494c5
=nextpc_const.1
1 : 1244873509 { 0x4a334325 +1.40048658e21 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10002 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2047 { 0x7ff +1.24402e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2048 { 0x800 +1.24414e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10003 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2048 { 0x800 +1.24414e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10005 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2047 { 0x7ff +1.24402e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2048 { 0x800 +1.24414e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10006 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2047 ] -> true, [ 2048; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda9973 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2047 { 0x7ff +1.24402e129 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2048 { 0x800 +1.24414e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1131 : BV:32
4 : Lambda10009 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10010 : BV:32
7 : 135991798 { 0x81b11f6 +1.21148562e145 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2047 ] -> true, [ 2048; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1130993672 { 0x43699808 +1.82495212e7 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 124 , m_adder -> 145), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1244873509 , 1000 , 8 ) -> 371744682, () -> 829324194, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1130 : BV:32
5 : Lambda10007 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda10008 : BV:32
8 : 1980671000 { 0x760ea418 +1.11438274e109 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(1, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : sym_const(16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 8; 1130993671 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1130993672; 1130993675 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1130993676; 2147483640 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2147483641; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 371744682 { 0x16285faa +1.31541943e173 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1130993672 { 0x43699808 +1.82495212e7 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1130993675 { 0x4369980b +1.82495248e7 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 124 , m_adder -> 145), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3329939358
=counter_example_end
=global nodece 54 num_edges_traversed 1
=global nodece 54 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 55
=global nodece 55 nodece z3v487.ce2314.num_edges_traversed1
=global nodece 55 nodece_path
=global nodece 55 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 55 nodece_cached_counterexample
=counter_example_begin z3v487.ce2314 2a1cd64836f41fd495967b42c9539e9
=input.spec-%var-arr-1
1 : Lambda10097 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10098 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10100 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10101 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1145 : BV:32
4 : Lambda10108 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10109 : BV:32
7 : 1849381547 { 0x6e3b52ab +1.46346032e93 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(1, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sym_const(16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10079 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1143 : BV:32
4 : Lambda10104 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10105 : BV:32
7 : 418654272 { 0x18f42840 +1.90747833e178 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1149 : BV:32
5 : Lambda10116 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda10117 : BV:32
8 : 1849381547 { 0x6e3b52ab +1.46346032e93 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1153 : BV:32
5 : Lambda10124 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda10125 : BV:32
8 : 1849381547 { 0x6e3b52ab +1.46346032e93 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073880612 { 0x40021e24 +1.1654481e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3637068368 { 0xd8c94250 -657898928 -1.57233619e50 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3910860576 { 0xe91aff20 -384106720 -1.21091079e83 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1157 : BV:32
5 : Lambda10132 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda10133 : BV:32
8 : 1849381547 { 0x6e3b52ab +1.46346032e93 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1376523585 { 0x520c1541 +1.9439861e37 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1291515463 { 0x4cfaf647 +1.96064078e26 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1073815547 ] -> 0, [ 1073815548; 1073815548 ] -> 0, [ 1073815549; 1073815549 ] -> 0, [ 1073815550; 1073815550 ] -> 0, [ 1073815551; 1073815551 ] -> 0, [ 1073815552; 1073815552 ] -> 0, [ 1073815553; 1073815553 ] -> 0, [ 1073815554; 1073815554 ] -> 0, [ 1073815555; 1073815555 ] -> 0, [ 1073815556; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1316176408 { 0x4e734218 +1.90045452e29 } : COUNT
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1073815547 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073815548; 1073815555 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073815556; 1073880611 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073880612; 1073880615 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073880616; 3637068367 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3637068368; 3637068371 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3637068372; 3910860575 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3910860576; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1291515463 { 0x4cfaf647 +1.96064078e26 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 116438095 { 0x6f0b44f +1.88050258e142 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1073815548 { 0x40011ffc +1.878858e1 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 120761902 { 0x732ae2e +1.39594054e143 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1073815548 { 0x40011ffc +1.878858e1 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 3910860576 { 0xe91aff20 -384106720 -1.21091079e83 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 1073815547 ] -> 0, [ 1073815548; 1073815555 ] -> 23, [ 1073815556; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 1073815547 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073815548; 1073815555 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073815556; 1073880611 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073880612; 1073880615 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073880616; 3637068367 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3637068368; 3637068371 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3637068372; 3910860575 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3910860576; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 116438095 { 0x6f0b44f +1.88050258e142 } : BV:32
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 1316176408 { 0x4e734218 +1.90045452e29 } : COUNT
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%2%d
1 : 1073815548 { 0x40011ffc +1.878858e1 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 1073815552 { 0x40012000 +1.878906e1 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 3910860576 { 0xe91aff20 -384106720 -1.21091079e83 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 1073815548 { 0x40011ffc +1.878858e1 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 3910860576 { 0xe91aff20 -384106720 -1.21091079e83 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 1073815548 { 0x40011ffc +1.878858e1 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1073815548 { 0x40011ffc +1.878858e1 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 1073815552 { 0x40012000 +1.878906e1 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 1073815548 { 0x40011ffc +1.878858e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3637068368 { 0xd8c94250 -657898928 -1.57233619e50 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3637068371 { 0xd8c94253 -657898925 -1.57233655e50 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073880612 { 0x40021e24 +1.1654481e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073880615 { 0x40021e27 +1.1654517e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3367656154
=counter_example_end
=global nodece 55 num_edges_traversed 1
=global nodece 55 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 56
=global nodece 56 nodece z3v487.ce2345.num_edges_traversed2
=global nodece 56 nodece_path
=global nodece 56 nodece_path.graph_edge_composition
(epsilon)
=global nodece 56 nodece_cached_counterexample
=counter_example_begin z3v487.ce2345 7e23bc917fb4934ed16dc3aef7e38def
=input.spec-%var-arr-1
1 : Lambda10097 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10098 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10100 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10101 : BV:32
18 : eq(17, 2) : BOOL
19 : bvule(2, 17) : BOOL
20 : bvule(17, 4) : BOOL
21 : and(19, 20) : BOOL
22 : bvule(8, 17) : BOOL
23 : bvule(17, 10) : BOOL
24 : and(22, 23) : BOOL
25 : ite(24, 13, 13) : BOOL
26 : ite(21, 7, 25) : BOOL
27 : and(19, 23) : BOOL
28 : ite(27, 2, 2) : BV:32
29 : ite(26, 2, 28) : BV:32
30 : ite(18, 2, 29) : BV:32
31 : lambda(17, 30) : FUNCTION[BV:32 -> BV:32]
32 : map(16, 31) : MAP[BV:32 -> BV:32]
33 : sym_const(32) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10079 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : bvule(2, 1) : BOOL
5 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
6 : bvule(1, 5) : BOOL
7 : and(4, 6) : BOOL
8 : 1 { 0x1 } : BOOL
9 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
10 : bvule(9, 1) : BOOL
11 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
12 : bvule(1, 11) : BOOL
13 : and(10, 12) : BOOL
14 : 0 { 0x0 } : BOOL
15 : ite(13, 14, 14) : BOOL
16 : ite(7, 8, 15) : BOOL
17 : and(4, 12) : BOOL
18 : ite(17, 2, 2) : BV:32
19 : ite(16, 2, 18) : BV:32
20 : ite(3, 2, 19) : BV:32
21 : lambda(1, 20) : FUNCTION[BV:32 -> BV:32]
22 : sym_const(21) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1143 : BV:32
4 : Lambda10104 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10105 : BV:32
7 : 418654272 { 0x18f42840 +1.90747833e178 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073880612 { 0x40021e24 +1.1654481e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 3637068368 { 0xd8c94250 -657898928 -1.57233619e50 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3910860576 { 0xe91aff20 -384106720 -1.21091079e83 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : Indxform1157 : BV:32
5 : Lambda10132 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda10133 : BV:32
8 : 1849381547 { 0x6e3b52ab +1.46346032e93 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(3, 2, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(3, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(3, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(3, 2, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(3, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(3, 2, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(3, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sum(1, 2, 17) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
19 : sym_const(18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1376523585 { 0x520c1541 +1.9439861e37 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1073815547 ] -> 0, [ 1073815548; 1073815548 ] -> 0, [ 1073815549; 1073815549 ] -> 0, [ 1073815550; 1073815550 ] -> 0, [ 1073815551; 1073815551 ] -> 0, [ 1073815552; 1073815552 ] -> 0, [ 1073815553; 1073815553 ] -> 0, [ 1073815554; 1073815554 ] -> 0, [ 1073815555; 1073815555 ] -> 0, [ 1073815556; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1316176408 { 0x4e734218 +1.90045452e29 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 1073815547 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073815548; 1073815555 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073815556; 1073880611 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073880612; 1073880615 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073880616; 3637068367 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3637068368; 3637068371 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 3637068372; 3910860575 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 3910860576; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1291515463 { 0x4cfaf647 +1.96064078e26 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 116438095 { 0x6f0b44f +1.88050258e142 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1073815548 { 0x40011ffc +1.878858e1 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 120761902 { 0x732ae2e +1.39594054e143 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 3637068368 { 0xd8c94250 -657898928 -1.57233619e50 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 3637068371 { 0xd8c94253 -657898925 -1.57233655e50 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073880612 { 0x40021e24 +1.1654481e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073880615 { 0x40021e27 +1.1654517e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3367656154
=counter_example_end
=global nodece 56 num_edges_traversed 2
=global nodece 56 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 57
=global nodece 57 nodece z3v487.ce2360.num_edges_traversed1
=global nodece 57 nodece_path
=global nodece 57 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 57 nodece_cached_counterexample
=counter_example_begin z3v487.ce2360 6719e310e9f1c85a74ae1997e639ccbf
=input.spec-%var-arr-1
1 : Lambda10201 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10202 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10204 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10205 : BV:32
18 : 1 { 0x1 +1.11e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
3 : unit : UNIT
4 : Indxform1167 : BV:32
5 : Lambda10212 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda10213 : BV:32
8 : 1177672647 { 0x4631dbc7 +1.38951957e13 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(1, 3, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(1, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(1, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 3, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(1, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(2, 3, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(1, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10185 : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 3 { 0x3 +1.35e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 4 { 0x4 +1.47e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1165 : BV:32
4 : Lambda10208 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10209 : BV:32
7 : 1555362612 { 0x5cb4f334 +1.41367197e58 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1171 : BV:32
6 : Lambda10220 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10221 : BV:32
9 : 1177672647 { 0x4631dbc7 +1.38951957e13 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1175 : BV:32
6 : Lambda10228 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10229 : BV:32
9 : 1177672647 { 0x4631dbc7 +1.38951957e13 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2147500032 { 0x80004000 -2147467264 -1.195312e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 268435460 { 0x10000004 +1.47e161 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2126512124 { 0x7ebffffc +1.49999952e126 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1179 : BV:32
6 : Lambda10236 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10237 : BV:32
9 : 1177672647 { 0x4631dbc7 +1.38951957e13 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 563891674 { 0x219c4dda +1.22112584e196 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 75416451 { 0x47ec383 +1.99034154e137 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1073741823 ] -> 0, [ 1073741824; 1073741824 ] -> 0, [ 1073741825; 1073741825 ] -> 0, [ 1073741826; 1073741826 ] -> 0, [ 1073741827; 1073741827 ] -> 0, [ 1073741828; 1073741828 ] -> 32, [ 1073741829; 1073741829 ] -> 0, [ 1073741830; 1073741830 ] -> 0, [ 1073741831; 1073741831 ] -> 0, [ 1073741832; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 197475779 { 0xbc53dc3 +1.54094731e152 } : COUNT
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 268435459 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435460; 268435463 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 268435464; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741831 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073741832; 2147500031 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147500032; 2147500035 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147500036; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 75416451 { 0x47ec383 +1.99034154e137 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1575189145 { 0x5de37a99 +1.77717888e60 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1032497568 { 0x3d8aa9a0 +1.8330154e252 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 2126512124 { 0x7ebffffc +1.49999952e126 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 1073741823 ] -> 0, [ 1073741824; 1073741831 ] -> 194, [ 1073741832; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 268435459 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435460; 268435463 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 268435464; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741831 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073741832; 2147500031 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147500032; 2147500035 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147500036; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1575189145 { 0x5de37a99 +1.77717888e60 } : BV:32
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 197475779 { 0xbc53dc3 +1.54094731e152 } : COUNT
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%2%d
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 1073741828 { 0x40000004 +1.47e1 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 2126512128 { 0x7ec00000 +1.50000000e126 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 2126512128 { 0x7ec00000 +1.50000000e126 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 1073741828 { 0x40000004 +1.47e1 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 268435460 { 0x10000004 +1.47e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 268435463 { 0x10000007 +1.83e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2147500032 { 0x80004000 -2147467264 -1.195312e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2147500035 { 0x80004003 -2147467261 -1.195348e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1845567373
=counter_example_end
=global nodece 57 num_edges_traversed 1
=global nodece 57 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 58
=global nodece 58 nodece z3v487.ce2391.num_edges_traversed2
=global nodece 58 nodece_path
=global nodece 58 nodece_path.graph_edge_composition
(epsilon)
=global nodece 58 nodece_cached_counterexample
=counter_example_begin z3v487.ce2391 5f81b79b4845dbe45a4f139967ada21
=input.spec-%var-arr-1
1 : Lambda10201 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10202 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10204 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10205 : BV:32
18 : 1 { 0x1 +1.11e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10185 : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 3 { 0x3 +1.35e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 4 { 0x4 +1.47e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1165 : BV:32
4 : Lambda10208 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10209 : BV:32
7 : 1555362612 { 0x5cb4f334 +1.41367197e58 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2147500032 { 0x80004000 -2147467264 -1.195312e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 268435460 { 0x10000004 +1.47e161 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2126512124 { 0x7ebffffc +1.49999952e126 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1179 : BV:32
6 : Lambda10236 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10237 : BV:32
9 : 1177672647 { 0x4631dbc7 +1.38951957e13 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 563891674 { 0x219c4dda +1.22112584e196 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1073741823 ] -> 0, [ 1073741824; 1073741824 ] -> 0, [ 1073741825; 1073741825 ] -> 0, [ 1073741826; 1073741826 ] -> 0, [ 1073741827; 1073741827 ] -> 0, [ 1073741828; 1073741828 ] -> 32, [ 1073741829; 1073741829 ] -> 0, [ 1073741830; 1073741830 ] -> 0, [ 1073741831; 1073741831 ] -> 0, [ 1073741832; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 197475779 { 0xbc53dc3 +1.54094731e152 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 268435459 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435460; 268435463 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 268435464; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741831 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073741832; 2147500031 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147500032; 2147500035 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147500036; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 75416451 { 0x47ec383 +1.99034154e137 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1575189145 { 0x5de37a99 +1.77717888e60 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1032497568 { 0x3d8aa9a0 +1.8330154e252 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 268435460 { 0x10000004 +1.47e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 268435463 { 0x10000007 +1.83e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2147500032 { 0x80004000 -2147467264 -1.195312e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2147500035 { 0x80004003 -2147467261 -1.195348e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
1845567373
=counter_example_end
=global nodece 58 num_edges_traversed 2
=global nodece 58 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 59
=global nodece 59 nodece z3v487.ce2395.num_edges_traversed3
=global nodece 59 nodece_path
=global nodece 59 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 59 nodece_cached_counterexample
=counter_example_begin z3v487.ce2395 bb959c8640a7a261a4e039ff6d75ec5
=nextpc_const.1
1 : 575805652 { 0x225218d4 +1.64138269e197 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10201 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10202 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10204 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 3 { 0x3 +1.35e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10205 : BV:32
18 : 1 { 0x1 +1.11e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10185 : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 3 { 0x3 +1.35e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 4 { 0x4 +1.47e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1165 : BV:32
4 : Lambda10208 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10209 : BV:32
7 : 1555362612 { 0x5cb4f334 +1.41367197e58 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 3 ] -> true, [ 4; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2147500032 { 0x80004000 -2147467264 -1.195312e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 268435460 { 0x10000004 +1.47e161 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2126512124 { 0x7ebffffc +1.49999952e126 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 145 , m_adder -> 108), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 575805652 , 1000 , 8 ) -> 1440389235, () -> 1699199688, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1179 : BV:32
6 : Lambda10236 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10237 : BV:32
9 : 1177672647 { 0x4631dbc7 +1.38951957e13 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 563891674 { 0x219c4dda +1.22112584e196 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 1073741823 ] -> 0, [ 1073741824; 1073741824 ] -> 0, [ 1073741825; 1073741825 ] -> 0, [ 1073741826; 1073741826 ] -> 0, [ 1073741827; 1073741827 ] -> 0, [ 1073741828; 1073741828 ] -> 32, [ 1073741829; 1073741829 ] -> 0, [ 1073741830; 1073741830 ] -> 0, [ 1073741831; 1073741831 ] -> 0, [ 1073741832; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 197475779 { 0xbc53dc3 +1.54094731e152 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 268435459 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 268435460; 268435463 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 268435464; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741831 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1073741832; 2147500031 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147500032; 2147500035 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2147500036; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 75416451 { 0x47ec383 +1.99034154e137 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 1073741823 ] -> 0, [ 1073741824; 1073741824 ] -> 0, [ 1073741825; 1073741825 ] -> 0, [ 1073741826; 1073741826 ] -> 0, [ 1073741827; 1073741827 ] -> 0, [ 1073741828; 1073741828 ] -> 32, [ 1073741829; 1073741829 ] -> 0, [ 1073741830; 1073741830 ] -> 0, [ 1073741831; 1073741831 ] -> 0, [ 1073741832; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1575189145 { 0x5de37a99 +1.77717888e60 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 2 { 0x2 +1.23e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1032497568 { 0x3d8aa9a0 +1.8330154e252 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1440389235 { 0x55da9873 +1.70777738e44 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 268435460 { 0x10000004 +1.47e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 268435463 { 0x10000007 +1.83e161 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2147500032 { 0x80004000 -2147467264 -1.195312e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2147500035 { 0x80004003 -2147467261 -1.195348e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 145 , m_adder -> 108), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3318531345
=counter_example_end
=global nodece 59 num_edges_traversed 3
=global nodece 59 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 60
=global nodece 60 nodece z3v487.ce2411.num_edges_traversed1
=global nodece 60 nodece_path
=global nodece 60 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 60 nodece_cached_counterexample
=counter_example_begin z3v487.ce2411 82ddc5c074e6cbf9c6d3b677d7774a6
=input.spec-%var-arr-1
1 : Lambda10293 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10294 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10296 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10297 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
3 : unit : UNIT
4 : Indxform1189 : BV:32
5 : Lambda10304 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda10305 : BV:32
8 : 154898959 { 0x93b920f +1.46539485e147 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(1, 3, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(1, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(1, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 3, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(1, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(2, 3, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(1, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10277 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 31 { 0x1f +1.369e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 32 { 0x20 +1.381e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1187 : BV:32
4 : Lambda10300 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10301 : BV:32
7 : 1855945905 { 0x6e9f7cb1 +1.24599277e94 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1193 : BV:32
6 : Lambda10312 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10313 : BV:32
9 : 154898959 { 0x93b920f +1.46539485e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1197 : BV:32
6 : Lambda10320 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10321 : BV:32
9 : 154898959 { 0x93b920f +1.46539485e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2184183816 { 0x82300008 -2110783480 -1.37500095e133 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1201 : BV:32
6 : Lambda10328 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10329 : BV:32
9 : 154898959 { 0x93b920f +1.46539485e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 348604293 { 0x14c74785 +1.55687010e170 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1625638530 { 0x60e54682 +1.79121422e66 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 7 ] -> 0, [ 8; 8 ] -> 0, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 12 ] -> 0, [ 13; 13 ] -> 64, [ 14; 14 ] -> 0, [ 15; 15 ] -> 0, [ 16; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1768918645 { 0x696f8e75 +1.87153494e83 } : COUNT
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 15 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 16; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1625638530 { 0x60e54682 +1.79121422e66 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 559036640 { 0x215238e0 +1.64236068e195 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1660899412 { 0x62ff5054 +1.99463891e70 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 2184183816 { 0x82300008 -2110783480 -1.37500095e133 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 7 ] -> 0, [ 8; 15 ] -> 116, [ 16; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 15 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 16; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 559036640 { 0x215238e0 +1.64236068e195 } : BV:32
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 1768918645 { 0x696f8e75 +1.87153494e83 } : COUNT
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 3 { 0x3 +1.35e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 16384 { 0x4000 +1.195312e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 2184183828 { 0x82300014 -2110783468 -1.37500238e133 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 2184183828 { 0x82300014 -2110783468 -1.37500238e133 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2069837109
=counter_example_end
=global nodece 60 num_edges_traversed 1
=global nodece 60 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 61
=global nodece 61 nodece z3v487.ce2442.num_edges_traversed2
=global nodece 61 nodece_path
=global nodece 61 nodece_path.graph_edge_composition
(epsilon)
=global nodece 61 nodece_cached_counterexample
=counter_example_begin z3v487.ce2442 7fa588ba8adddab743d39489eca3a663
=input.spec-%var-arr-1
1 : Lambda10293 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10294 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10296 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10297 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10277 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 31 { 0x1f +1.369e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 32 { 0x20 +1.381e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1187 : BV:32
4 : Lambda10300 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10301 : BV:32
7 : 1855945905 { 0x6e9f7cb1 +1.24599277e94 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2184183816 { 0x82300008 -2110783480 -1.37500095e133 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1201 : BV:32
6 : Lambda10328 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10329 : BV:32
9 : 154898959 { 0x93b920f +1.46539485e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 348604293 { 0x14c74785 +1.55687010e170 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 7 ] -> 0, [ 8; 8 ] -> 0, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 12 ] -> 0, [ 13; 13 ] -> 64, [ 14; 14 ] -> 0, [ 15; 15 ] -> 0, [ 16; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1768918645 { 0x696f8e75 +1.87153494e83 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 15 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 16; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1625638530 { 0x60e54682 +1.79121422e66 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 559036640 { 0x215238e0 +1.64236068e195 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1660899412 { 0x62ff5054 +1.99463891e70 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
2069837109
=counter_example_end
=global nodece 61 num_edges_traversed 2
=global nodece 61 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 62
=global nodece 62 nodece z3v487.ce2446.num_edges_traversed3
=global nodece 62 nodece_path
=global nodece 62 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 62 nodece_cached_counterexample
=counter_example_begin z3v487.ce2446 cab721b5ec55883c3bb87b3948a123
=nextpc_const.1
1 : 1540739912 { 0x5bd5d348 +1.67051029e56 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10293 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10294 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10296 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10297 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10277 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 31 { 0x1f +1.369e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 32 { 0x20 +1.381e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1187 : BV:32
4 : Lambda10300 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10301 : BV:32
7 : 1855945905 { 0x6e9f7cb1 +1.24599277e94 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2184183816 { 0x82300008 -2110783480 -1.37500095e133 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 143), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1540739912 , 1000 , 8 ) -> 559551460, () -> 1970694948, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1201 : BV:32
6 : Lambda10328 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10329 : BV:32
9 : 154898959 { 0x93b920f +1.46539485e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 348604293 { 0x14c74785 +1.55687010e170 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 7 ] -> 0, [ 8; 8 ] -> 0, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 12 ] -> 0, [ 13; 13 ] -> 64, [ 14; 14 ] -> 0, [ 15; 15 ] -> 0, [ 16; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1768918645 { 0x696f8e75 +1.87153494e83 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 15 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 16; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1625638530 { 0x60e54682 +1.79121422e66 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 7 ] -> 0, [ 8; 8 ] -> 0, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 12 ] -> 0, [ 13; 13 ] -> 64, [ 14; 14 ] -> 0, [ 15; 15 ] -> 0, [ 16; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 559036640 { 0x215238e0 +1.64236068e195 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1660899412 { 0x62ff5054 +1.99463891e70 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 559551460 { 0x215a13e4 +1.70373201e195 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 143), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3799824441
=counter_example_end
=global nodece 62 num_edges_traversed 3
=global nodece 62 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 63
=global nodece 63 nodece z3v487.ce2465.num_edges_traversed4
=global nodece 63 nodece_path
=global nodece 63 nodece_path.graph_edge_composition
(epsilon)
=global nodece 63 nodece_cached_counterexample
=counter_example_begin z3v487.ce2465 edc94a44e9ff388d8517e0c6e5780bd
=nextpc_const.1
1 : 1540739912 { 0x5bd5d348 +1.67051029e56 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10293 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10294 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10296 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10297 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10277 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 31 { 0x1f +1.369e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 32 { 0x20 +1.381e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1187 : BV:32
4 : Lambda10300 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10301 : BV:32
7 : 1855945905 { 0x6e9f7cb1 +1.24599277e94 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2184183816 { 0x82300008 -2110783480 -1.37500095e133 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 143), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1540739912 , 1000 , 8 ) -> 559551460, () -> 1970694948, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1215 : BV:32
6 : Lambda10356 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10357 : BV:32
9 : 154898959 { 0x93b920f +1.46539485e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : prod(3, 19) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
21 : sum(1, 2, 20) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
22 : sym_const(21) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 348604294 { 0x14c74786 +1.55687022e170 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 12 ] -> 0, [ 13; 13 ] -> 64, [ 14; 559551459 ] -> 0, [ 559551460; 559551460 ] -> 0, [ 559551461; 559551461 ] -> 0, [ 559551462; 559551462 ] -> 0, [ 559551463; 559551463 ] -> 0, [ 559551464; 559551464 ] -> 8, [ 559551465; 559551465 ] -> 0, [ 559551466; 559551466 ] -> 0, [ 559551467; 559551467 ] -> 0, [ 559551468; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1768918646 { 0x696f8e76 +1.87153506e83 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 15 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 16; 559551459 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 559551460; 559551467 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 559551468; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1625638530 { 0x60e54682 +1.79121422e66 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 559036640 { 0x215238e0 +1.64236068e195 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 559551460 { 0x215a13e4 +1.70373201e195 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1660899413 { 0x62ff5055 +1.99463903e70 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 143), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3799824441
=counter_example_end
=global nodece 63 num_edges_traversed 4
=global nodece 63 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 64
=global nodece 64 nodece z3v487.ce2481.num_edges_traversed5
=global nodece 64 nodece_path
=global nodece 64 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 64 nodece_cached_counterexample
=counter_example_begin z3v487.ce2481 1566711427b54a9397972c709771f6
=nextpc_const.1
1 : 1540739912 { 0x5bd5d348 +1.67051029e56 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10293 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10294 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10296 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10297 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10277 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 31 { 0x1f +1.369e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 32 { 0x20 +1.381e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1187 : BV:32
4 : Lambda10300 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10301 : BV:32
7 : 1855945905 { 0x6e9f7cb1 +1.24599277e94 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2184183816 { 0x82300008 -2110783480 -1.37500095e133 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 143), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1540739912 , 1000 , 8 ) -> 559551460, () -> 1970694948, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1215 : BV:32
6 : Lambda10356 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10357 : BV:32
9 : 154898959 { 0x93b920f +1.46539485e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : prod(3, 19) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
21 : sum(1, 2, 20) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
22 : sym_const(21) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 348604294 { 0x14c74786 +1.55687022e170 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 12 ] -> 0, [ 13; 13 ] -> 64, [ 14; 559551459 ] -> 0, [ 559551460; 559551460 ] -> 0, [ 559551461; 559551461 ] -> 0, [ 559551462; 559551462 ] -> 0, [ 559551463; 559551463 ] -> 0, [ 559551464; 559551464 ] -> 8, [ 559551465; 559551465 ] -> 0, [ 559551466; 559551466 ] -> 0, [ 559551467; 559551467 ] -> 0, [ 559551468; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1768918646 { 0x696f8e76 +1.87153506e83 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 15 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 16; 559551459 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 559551460; 559551467 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 559551468; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1625638530 { 0x60e54682 +1.79121422e66 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 559036640 { 0x215238e0 +1.64236068e195 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 559551460 { 0x215a13e4 +1.70373201e195 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1660899413 { 0x62ff5055 +1.99463903e70 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 143), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3799824441
=counter_example_end
=global nodece 64 num_edges_traversed 5
=global nodece 64 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 65
=global nodece 65 nodece z3v487.ce2491.num_edges_traversed6
=global nodece 65 nodece_path
=global nodece 65 nodece_path.graph_edge_composition
(epsilon)
=global nodece 65 nodece_cached_counterexample
=counter_example_begin z3v487.ce2491 44b045c586b6956ce1c4aba16f55dc8e
=nextpc_const.1
1 : 1540739912 { 0x5bd5d348 +1.67051029e56 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10293 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10294 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10296 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 31 { 0x1f +1.369e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 32 { 0x20 +1.381e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10297 : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10277 : BV:32
2 : 3 { 0x3 +1.35e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 31 { 0x1f +1.369e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 32 { 0x20 +1.381e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1187 : BV:32
4 : Lambda10300 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10301 : BV:32
7 : 1855945905 { 0x6e9f7cb1 +1.24599277e94 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 31 ] -> true, [ 32; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2184183816 { 0x82300008 -2110783480 -1.37500095e133 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 143), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1540739912 , 1000 , 8 ) -> 559551460, () -> 1970694948, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1215 : BV:32
6 : Lambda10356 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10357 : BV:32
9 : 154898959 { 0x93b920f +1.46539485e147 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : prod(3, 19) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
21 : sum(1, 2, 20) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
22 : sym_const(21) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 348604294 { 0x14c74786 +1.55687022e170 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 12 ] -> 0, [ 13; 13 ] -> 64, [ 14; 559551459 ] -> 0, [ 559551460; 559551460 ] -> 0, [ 559551461; 559551461 ] -> 0, [ 559551462; 559551462 ] -> 0, [ 559551463; 559551463 ] -> 0, [ 559551464; 559551464 ] -> 8, [ 559551465; 559551465 ] -> 0, [ 559551466; 559551466 ] -> 0, [ 559551467; 559551467 ] -> 0, [ 559551468; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1768918646 { 0x696f8e76 +1.87153506e83 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 7 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 8; 15 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 16; 559551459 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 559551460; 559551467 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 559551468; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1625638530 { 0x60e54682 +1.79121422e66 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 12 ] -> 0, [ 13; 13 ] -> 64, [ 14; 559551459 ] -> 0, [ 559551460; 559551460 ] -> 0, [ 559551461; 559551461 ] -> 0, [ 559551462; 559551462 ] -> 0, [ 559551463; 559551463 ] -> 0, [ 559551464; 559551464 ] -> 8, [ 559551465; 559551465 ] -> 0, [ 559551466; 559551466 ] -> 0, [ 559551467; 559551467 ] -> 0, [ 559551468; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 559036640 { 0x215238e0 +1.64236068e195 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 559551460 { 0x215a13e4 +1.70373201e195 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1660899413 { 0x62ff5055 +1.99463903e70 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 559551460 { 0x215a13e4 +1.70373201e195 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 143), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
3799824441
=counter_example_end
=global nodece 65 num_edges_traversed 6
=global nodece 65 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 66
=global nodece 66 nodece z3v487.ce2496.num_edges_traversed1
=global nodece 66 nodece_path
=global nodece 66 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 66 nodece_cached_counterexample
=counter_example_begin z3v487.ce2496 f9bd5a16e7f1655dd5bb4d36d7f92918
=input.spec-%var-arr-1
1 : Lambda10413 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8 { 0x8 +1.95e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 9 { 0x9 +1.107e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10414 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10416 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8 { 0x8 +1.95e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 9 { 0x9 +1.107e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10417 : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
3 : unit : UNIT
4 : Indxform1225 : BV:32
5 : Lambda10424 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda10425 : BV:32
8 : 1906756643 { 0x71a6cc23 +1.30310475e100 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(1, 3, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(1, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(1, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 3, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(1, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(2, 3, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(1, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 8 ] -> true, [ 9; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10397 : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 8 { 0x8 +1.95e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 9 { 0x9 +1.107e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1223 : BV:32
4 : Lambda10420 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10421 : BV:32
7 : 792186626 { 0x2f37cf02 +1.43600487e223 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1229 : BV:32
6 : Lambda10432 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10433 : BV:32
9 : 1906756643 { 0x71a6cc23 +1.30310475e100 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 8 ] -> true, [ 9; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1233 : BV:32
6 : Lambda10440 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10441 : BV:32
9 : 1906756643 { 0x71a6cc23 +1.30310475e100 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2097152 { 0x200000 +1.25000000e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3113271288 { 0xb990bff8 -1181696008 -1.13085842e244 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1237 : BV:32
6 : Lambda10448 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10449 : BV:32
9 : 1906756643 { 0x71a6cc23 +1.30310475e100 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1735733306 { 0x6775303a +1.91553425e79 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 2085622539 { 0x7c50130b +1.62558114e121 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 16, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1586045721 { 0x5e892319 +1.7138359e62 } : COUNT
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 32767 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 32768; 32771 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 32772; 2097151 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2097152; 2097155 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2097156; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 2085622539 { 0x7c50130b +1.62558114e121 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1523943128 { 0x5ad586d8 +1.66817760e54 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1787467107 { 0x6a8a9563 +1.8268392e86 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 3113271288 { 0xb990bff8 -1181696008 -1.13085842e244 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 3 ] -> 0, [ 4; 11 ] -> 24, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 32767 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 32768; 32771 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 32772; 2097151 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2097152; 2097155 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2097156; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1523943128 { 0x5ad586d8 +1.66817760e54 } : BV:32
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 1586045721 { 0x5e892319 +1.7138359e62 } : COUNT
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%2%d
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 3113271304 { 0xb990c008 -1181695992 -1.13086032e244 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 3113271304 { 0xb990c008 -1181695992 -1.13086032e244 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 32771 { 0x8003 +1.390660e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2097152 { 0x200000 +1.25000000e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2097155 { 0x200003 +1.25000035e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
717215275
=counter_example_end
=global nodece 66 num_edges_traversed 1
=global nodece 66 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 67
=global nodece 67 nodece z3v487.ce2527.num_edges_traversed2
=global nodece 67 nodece_path
=global nodece 67 nodece_path.graph_edge_composition
(epsilon)
=global nodece 67 nodece_cached_counterexample
=counter_example_begin z3v487.ce2527 c9a9615b1c8fd891eb7c795858b1938
=input.spec-%var-arr-1
1 : Lambda10413 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8 { 0x8 +1.95e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 9 { 0x9 +1.107e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10414 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10416 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8 { 0x8 +1.95e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 9 { 0x9 +1.107e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10417 : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 8 ] -> true, [ 9; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10397 : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 8 { 0x8 +1.95e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 9 { 0x9 +1.107e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1223 : BV:32
4 : Lambda10420 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10421 : BV:32
7 : 792186626 { 0x2f37cf02 +1.43600487e223 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 8 ] -> true, [ 9; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2097152 { 0x200000 +1.25000000e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3113271288 { 0xb990bff8 -1181696008 -1.13085842e244 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1237 : BV:32
6 : Lambda10448 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10449 : BV:32
9 : 1906756643 { 0x71a6cc23 +1.30310475e100 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1735733306 { 0x6775303a +1.91553425e79 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 16, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1586045721 { 0x5e892319 +1.7138359e62 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 32767 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 32768; 32771 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 32772; 2097151 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2097152; 2097155 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2097156; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 2085622539 { 0x7c50130b +1.62558114e121 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1523943128 { 0x5ad586d8 +1.66817760e54 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1787467107 { 0x6a8a9563 +1.8268392e86 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 32771 { 0x8003 +1.390660e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2097152 { 0x200000 +1.25000000e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2097155 { 0x200003 +1.25000035e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
717215275
=counter_example_end
=global nodece 67 num_edges_traversed 2
=global nodece 67 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 68
=global nodece 68 nodece z3v487.ce2531.num_edges_traversed3
=global nodece 68 nodece_path
=global nodece 68 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 68 nodece_cached_counterexample
=counter_example_begin z3v487.ce2531 5385a4a48e7cfb3d32878ea31efdde6
=nextpc_const.1
1 : 1930582253 { 0x731258ed +1.14333879e103 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10413 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8 { 0x8 +1.95e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 9 { 0x9 +1.107e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10414 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10416 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8 { 0x8 +1.95e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 9 { 0x9 +1.107e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10417 : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 8 ] -> true, [ 9; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10397 : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 8 { 0x8 +1.95e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 9 { 0x9 +1.107e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1223 : BV:32
4 : Lambda10420 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10421 : BV:32
7 : 792186626 { 0x2f37cf02 +1.43600487e223 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 8 ] -> true, [ 9; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2097152 { 0x200000 +1.25000000e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3113271288 { 0xb990bff8 -1181696008 -1.13085842e244 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 144), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1930582253 , 1000 , 8 ) -> 995404440, () -> 1433031332, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1237 : BV:32
6 : Lambda10448 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10449 : BV:32
9 : 1906756643 { 0x71a6cc23 +1.30310475e100 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1735733306 { 0x6775303a +1.91553425e79 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 16, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1586045721 { 0x5e892319 +1.7138359e62 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 32767 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 32768; 32771 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 32772; 2097151 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2097152; 2097155 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2097156; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 2085622539 { 0x7c50130b +1.62558114e121 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 16, [ 9; 9 ] -> 0, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1523943128 { 0x5ad586d8 +1.66817760e54 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 5 { 0x5 +1.59e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1787467107 { 0x6a8a9563 +1.8268392e86 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 995404440 { 0x3b54aa98 +1.66145610e247 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 32771 { 0x8003 +1.390660e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2097152 { 0x200000 +1.25000000e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2097155 { 0x200003 +1.25000035e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 144), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
4105739215
=counter_example_end
=global nodece 68 num_edges_traversed 3
=global nodece 68 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 69
=global nodece 69 nodece z3v487.ce2550.num_edges_traversed4
=global nodece 69 nodece_path
=global nodece 69 nodece_path.graph_edge_composition
(epsilon)
=global nodece 69 nodece_cached_counterexample
=counter_example_begin z3v487.ce2550 e641b1c696b47aea5c73f8d1152bc37
=nextpc_const.1
1 : 1930582253 { 0x731258ed +1.14333879e103 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10413 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8 { 0x8 +1.95e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 9 { 0x9 +1.107e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10414 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10416 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 8 { 0x8 +1.95e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 9 { 0x9 +1.107e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10417 : BV:32
18 : 4 { 0x4 +1.47e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 8 ] -> true, [ 9; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10397 : BV:32
2 : 4 { 0x4 +1.47e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 8 { 0x8 +1.95e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 9 { 0x9 +1.107e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1223 : BV:32
4 : Lambda10420 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10421 : BV:32
7 : 792186626 { 0x2f37cf02 +1.43600487e223 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 8 ] -> true, [ 9; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 2097152 { 0x200000 +1.25000000e129 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 3113271288 { 0xb990bff8 -1181696008 -1.13085842e244 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 6 { 0x6 +1.71e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 144), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1930582253 , 1000 , 8 ) -> 995404440, () -> 1433031332, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1251 : BV:32
6 : Lambda10476 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10477 : BV:32
9 : 1906756643 { 0x71a6cc23 +1.30310475e100 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : prod(3, 19) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
21 : sum(1, 2, 20) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
22 : sym_const(21) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 1735733307 { 0x6775303b +1.91553437e79 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 7 ] -> 0, [ 8; 8 ] -> 16, [ 9; 995404439 ] -> 0, [ 995404440; 995404440 ] -> 0, [ 995404441; 995404441 ] -> 0, [ 995404442; 995404442 ] -> 0, [ 995404443; 995404443 ] -> 0, [ 995404444; 995404444 ] -> 4, [ 995404445; 995404445 ] -> 0, [ 995404446; 995404446 ] -> 0, [ 995404447; 995404447 ] -> 0, [ 995404448; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1586045722 { 0x5e89231a +1.7138371e62 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 32767 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 32768; 32771 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 32772; 2097151 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2097152; 2097155 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 2097156; 995404439 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 995404440; 995404447 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 995404448; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 2085622539 { 0x7c50130b +1.62558114e121 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1523943128 { 0x5ad586d8 +1.66817760e54 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 6 { 0x6 +1.71e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 995404440 { 0x3b54aa98 +1.66145610e247 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1787467108 { 0x6a8a9564 +1.8268404e86 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 32768 { 0x8000 +1.390625e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 32771 { 0x8003 +1.390660e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 2097152 { 0x200000 +1.25000000e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 2097155 { 0x200003 +1.25000035e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 160 , m_adder -> 144), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
4105739215
=counter_example_end
=global nodece 69 num_edges_traversed 4
=global nodece 69 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 70
=global nodece 70 nodece z3v487.ce2576.num_edges_traversed1
=global nodece 70 nodece_path
=global nodece 70 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 70 nodece_cached_counterexample
=counter_example_begin z3v487.ce2576 8b1d26e69bb6cae8f79f15e11f99da6
=input.spec-%var-arr-1
1 : Lambda10560 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10561 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10563 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10564 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
3 : unit : UNIT
4 : Indxform1265 : BV:32
5 : Lambda10571 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda10572 : BV:32
8 : 607452423 { 0x2434fd07 +1.41397178e201 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(1, 3, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(1, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(1, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 3, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(1, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(2, 3, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(1, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10544 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1263 : BV:32
4 : Lambda10567 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10568 : BV:32
7 : 1867418942 { 0x6f4e8d3e +1.61368536e95 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1269 : BV:32
6 : Lambda10579 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10580 : BV:32
9 : 607452423 { 0x2434fd07 +1.41397178e201 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1273 : BV:32
6 : Lambda10587 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10588 : BV:32
9 : 607452423 { 0x2434fd07 +1.41397178e201 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2118226944 { 0x7e419400 +1.51232910e125 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1277 : BV:32
6 : Lambda10595 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10596 : BV:32
9 : 607452423 { 0x2434fd07 +1.41397178e201 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 2135546818 { 0x7f49dbc2 +1.57701897e127 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 922732837 { 0x36ffc925 +1.99832594e238 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 0, [ 9; 9 ] -> 1, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1322611760 { 0x4ed57430 +1.66760826e30 } : COUNT
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073741828; 2118226971 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2118226972; 2118226975 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2118226976; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 922732837 { 0x36ffc925 +1.99832594e238 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 429407331 { 0x19983c63 +1.18934285e180 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1546175906 { 0x5c28c5a2 +1.31853127e57 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 2118226944 { 0x7e419400 +1.51232910e125 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 3 ] -> 0, [ 4; 11 ] -> 47, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073741828; 2118226971 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2118226972; 2118226975 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2118226976; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 429407331 { 0x19983c63 +1.18934285e180 } : BV:32
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 1322611760 { 0x4ed57430 +1.66760826e30 } : COUNT
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 7 { 0x7 +1.83e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 256 { 0x100 +1.3051e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%2%d
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 28 { 0x1c +1.333e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 2118226972 { 0x7e41941c +1.51233243e125 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 28 { 0x1c +1.333e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 2118226972 { 0x7e41941c +1.51233243e125 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073741827 { 0x40000003 +1.35e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
163726688
=counter_example_end
=global nodece 70 num_edges_traversed 1
=global nodece 70 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 71
=global nodece 71 nodece z3v487.ce2607.num_edges_traversed2
=global nodece 71 nodece_path
=global nodece 71 nodece_path.graph_edge_composition
(epsilon)
=global nodece 71 nodece_cached_counterexample
=counter_example_begin z3v487.ce2607 6652b6645ff3d905d5180ea5d50643
=input.spec-%var-arr-1
1 : Lambda10560 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10561 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10563 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10564 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10544 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1263 : BV:32
4 : Lambda10567 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10568 : BV:32
7 : 1867418942 { 0x6f4e8d3e +1.61368536e95 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2118226944 { 0x7e419400 +1.51232910e125 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1277 : BV:32
6 : Lambda10595 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10596 : BV:32
9 : 607452423 { 0x2434fd07 +1.41397178e201 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 2135546818 { 0x7f49dbc2 +1.57701897e127 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 0, [ 9; 9 ] -> 1, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1322611760 { 0x4ed57430 +1.66760826e30 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073741828; 2118226971 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2118226972; 2118226975 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2118226976; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 922732837 { 0x36ffc925 +1.99832594e238 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 429407331 { 0x19983c63 +1.18934285e180 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1546175906 { 0x5c28c5a2 +1.31853127e57 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073741827 { 0x40000003 +1.35e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
163726688
=counter_example_end
=global nodece 71 num_edges_traversed 2
=global nodece 71 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 72
=global nodece 72 nodece z3v487.ce2611.num_edges_traversed3
=global nodece 72 nodece_path
=global nodece 72 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 72 nodece_cached_counterexample
=counter_example_begin z3v487.ce2611 b8ca923430247e5bf6bee140a15bf12f
=nextpc_const.1
1 : 295966769 { 0x11a41831 +1.28198826e164 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10560 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10561 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10563 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10564 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10544 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1263 : BV:32
4 : Lambda10567 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10568 : BV:32
7 : 1867418942 { 0x6f4e8d3e +1.61368536e95 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2118226944 { 0x7e419400 +1.51232910e125 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 15 , m_adder -> 33), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 295966769 , 1000 , 8 ) -> 1341558580, () -> 471012384, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1277 : BV:32
6 : Lambda10595 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10596 : BV:32
9 : 607452423 { 0x2434fd07 +1.41397178e201 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 2135546818 { 0x7f49dbc2 +1.57701897e127 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 0, [ 9; 9 ] -> 1, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1322611760 { 0x4ed57430 +1.66760826e30 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073741828; 2118226971 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2118226972; 2118226975 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2118226976; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 922732837 { 0x36ffc925 +1.99832594e238 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 3 ] -> 0, [ 4; 4 ] -> 0, [ 5; 5 ] -> 0, [ 6; 6 ] -> 0, [ 7; 7 ] -> 0, [ 8; 8 ] -> 0, [ 9; 9 ] -> 1, [ 10; 10 ] -> 0, [ 11; 11 ] -> 0, [ 12; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 429407331 { 0x19983c63 +1.18934285e180 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1546175906 { 0x5c28c5a2 +1.31853127e57 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1341558580 { 0x4ff68f34 +1.92624521e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073741827 { 0x40000003 +1.35e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 15 , m_adder -> 33), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1546911412
=counter_example_end
=global nodece 72 num_edges_traversed 3
=global nodece 72 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 73
=global nodece 73 nodece z3v487.ce2630.num_edges_traversed4
=global nodece 73 nodece_path
=global nodece 73 nodece_path.graph_edge_composition
(epsilon)
=global nodece 73 nodece_cached_counterexample
=counter_example_begin z3v487.ce2630 4e4817501edf6b3e1484473be4dc35b
=nextpc_const.1
1 : 295966769 { 0x11a41831 +1.28198826e164 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10560 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10561 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10563 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10564 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10544 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1263 : BV:32
4 : Lambda10567 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10568 : BV:32
7 : 1867418942 { 0x6f4e8d3e +1.61368536e95 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2118226944 { 0x7e419400 +1.51232910e125 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 15 , m_adder -> 33), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 295966769 , 1000 , 8 ) -> 1341558580, () -> 471012384, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1291 : BV:32
6 : Lambda10623 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10624 : BV:32
9 : 607452423 { 0x2434fd07 +1.41397178e201 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : prod(3, 19) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
21 : sum(1, 2, 20) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
22 : sym_const(21) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 2135546819 { 0x7f49dbc3 +1.57701909e127 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 8 ] -> 0, [ 9; 9 ] -> 1, [ 10; 1341558579 ] -> 0, [ 1341558580; 1341558580 ] -> 0, [ 1341558581; 1341558581 ] -> 0, [ 1341558582; 1341558582 ] -> 0, [ 1341558583; 1341558583 ] -> 0, [ 1341558584; 1341558584 ] -> 4, [ 1341558585; 1341558585 ] -> 0, [ 1341558586; 1341558586 ] -> 0, [ 1341558587; 1341558587 ] -> 0, [ 1341558588; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1322611761 { 0x4ed57431 +1.66760838e30 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073741828; 1341558579 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1341558580; 1341558587 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1341558588; 2118226971 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2118226972; 2118226975 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2118226976; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 922732837 { 0x36ffc925 +1.99832594e238 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 429407331 { 0x19983c63 +1.18934285e180 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1341558580 { 0x4ff68f34 +1.92624521e32 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1546175907 { 0x5c28c5a3 +1.31853139e57 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073741827 { 0x40000003 +1.35e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 15 , m_adder -> 33), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1546911412
=counter_example_end
=global nodece 73 num_edges_traversed 4
=global nodece 73 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 74
=global nodece 74 nodece z3v487.ce2646.num_edges_traversed5
=global nodece 74 nodece_path
=global nodece 74 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart)
=global nodece 74 nodece_cached_counterexample
=counter_example_begin z3v487.ce2646 a74e139814dfa9b1a79ad6c3f546e8f
=nextpc_const.1
1 : 295966769 { 0x11a41831 +1.28198826e164 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10560 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10561 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10563 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10564 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10544 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1263 : BV:32
4 : Lambda10567 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10568 : BV:32
7 : 1867418942 { 0x6f4e8d3e +1.61368536e95 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2118226944 { 0x7e419400 +1.51232910e125 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 15 , m_adder -> 33), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 295966769 , 1000 , 8 ) -> 1341558580, () -> 471012384, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1291 : BV:32
6 : Lambda10623 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10624 : BV:32
9 : 607452423 { 0x2434fd07 +1.41397178e201 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : prod(3, 19) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
21 : sum(1, 2, 20) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
22 : sym_const(21) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 2135546819 { 0x7f49dbc3 +1.57701909e127 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 8 ] -> 0, [ 9; 9 ] -> 1, [ 10; 1341558579 ] -> 0, [ 1341558580; 1341558580 ] -> 0, [ 1341558581; 1341558581 ] -> 0, [ 1341558582; 1341558582 ] -> 0, [ 1341558583; 1341558583 ] -> 0, [ 1341558584; 1341558584 ] -> 4, [ 1341558585; 1341558585 ] -> 0, [ 1341558586; 1341558586 ] -> 0, [ 1341558587; 1341558587 ] -> 0, [ 1341558588; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1322611761 { 0x4ed57431 +1.66760838e30 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073741828; 1341558579 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1341558580; 1341558587 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1341558588; 2118226971 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2118226972; 2118226975 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2118226976; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 922732837 { 0x36ffc925 +1.99832594e238 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 429407331 { 0x19983c63 +1.18934285e180 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1341558580 { 0x4ff68f34 +1.92624521e32 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1546175907 { 0x5c28c5a3 +1.31853139e57 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073741827 { 0x40000003 +1.35e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 15 , m_adder -> 33), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1546911412
=counter_example_end
=global nodece 74 num_edges_traversed 5
=global nodece 74 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 75
=global nodece 75 nodece z3v487.ce2656.num_edges_traversed6
=global nodece 75 nodece_path
=global nodece 75 nodece_path.graph_edge_composition
(epsilon)
=global nodece 75 nodece_cached_counterexample
=counter_example_begin z3v487.ce2656 e88fe137524d5016720a164b48d26a
=nextpc_const.1
1 : 295966769 { 0x11a41831 +1.28198826e164 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10560 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10561 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10563 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10564 : BV:32
18 : 7 { 0x7 +1.83e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10544 : BV:32
2 : 7 { 0x7 +1.83e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 2147483647 { 0x7fffffff +1.99999988e128 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1263 : BV:32
4 : Lambda10567 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10568 : BV:32
7 : 1867418942 { 0x6f4e8d3e +1.61368536e95 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 2147483647 ] -> true, [ 2147483648; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 2118226944 { 0x7e419400 +1.51232910e125 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 15 , m_adder -> 33), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 295966769 , 1000 , 8 ) -> 1341558580, () -> 471012384, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
5 : Indxform1291 : BV:32
6 : Lambda10623 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10624 : BV:32
9 : 607452423 { 0x2434fd07 +1.41397178e201 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : prod(3, 19) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
21 : sum(1, 2, 20) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
22 : sym_const(21) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 2135546819 { 0x7f49dbc3 +1.57701909e127 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 8 ] -> 0, [ 9; 9 ] -> 1, [ 10; 1341558579 ] -> 0, [ 1341558580; 1341558580 ] -> 0, [ 1341558581; 1341558581 ] -> 0, [ 1341558582; 1341558582 ] -> 0, [ 1341558583; 1341558583 ] -> 0, [ 1341558584; 1341558584 ] -> 4, [ 1341558585; 1341558585 ] -> 0, [ 1341558586; 1341558586 ] -> 0, [ 1341558587; 1341558587 ] -> 0, [ 1341558588; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1322611761 { 0x4ed57431 +1.66760838e30 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 3 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 4; 11 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 12; 1073741823 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1073741824; 1073741827 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 1073741828; 1341558579 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 1341558580; 1341558587 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 1341558588; 2118226971 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2118226972; 2118226975 ] -> memlabel-mem--hpalloc.R2p./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 2118226976; 2147483647 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 2147483648; 2147483651 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 2147483652; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 922732837 { 0x36ffc925 +1.99832594e238 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 8 ] -> 0, [ 9; 9 ] -> 1, [ 10; 1341558579 ] -> 0, [ 1341558580; 1341558580 ] -> 0, [ 1341558581; 1341558581 ] -> 0, [ 1341558582; 1341558582 ] -> 0, [ 1341558583; 1341558583 ] -> 0, [ 1341558584; 1341558584 ] -> 4, [ 1341558585; 1341558585 ] -> 0, [ 1341558586; 1341558586 ] -> 0, [ 1341558587; 1341558587 ] -> 0, [ 1341558588; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 429407331 { 0x19983c63 +1.18934285e180 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 1341558580 { 0x4ff68f34 +1.92624521e32 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 1546175907 { 0x5c28c5a3 +1.31853139e57 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1341558580 { 0x4ff68f34 +1.92624521e32 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 2147483651 { 0x80000003 -2147483645 -1.35e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 1073741824 { 0x40000000 +1.0e1 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 1073741827 { 0x40000003 +1.35e1 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 2147483648 { 0x80000000 -2147483648 -1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 15 , m_adder -> 33), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1546911412
=counter_example_end
=global nodece 75 num_edges_traversed 6
=global nodece 75 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=global nodece 76
=global nodece 76 nodece z3v487.ce2661.num_edges_traversed1
=global nodece 76 nodece_path
=global nodece 76 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry)
=global nodece 76 nodece_cached_counterexample
=counter_example_begin z3v487.ce2661 2415f2ccc058227c40feaa524d982057
=input.spec-%var-arr-1
1 : Lambda10680 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 65535 { 0xffff +1.781238e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 65536 { 0x10000 +1.781250e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10681 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 65536 { 0x10000 +1.781250e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10683 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 65535 { 0xffff +1.781238e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 65536 { 0x10000 +1.781250e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10684 : BV:32
18 : 8 { 0x8 +1.95e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%tmpvar-1.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : 67108864 { 0x4000000 +1.0e137 } : BV:32
3 : unit : UNIT
4 : Indxform1301 : BV:32
5 : Lambda10691 : BV:32
6 : lambda(5, 5) : FUNCTION[BV:32 -> BV:32]
7 : Lambda10692 : BV:32
8 : 1042149592 { 0x3e1df0d8 +1.23391246e253 } : BV:32
9 : prod(8, 4) : PROD[BV:32,BV:32]
10 : sum(1, 3, 9) : SUM[UNIT,PROD[BV:32,BV:32]]
11 : lambda(7, 10) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
12 : ind(1, 4, 6, 11) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
13 : prod(1, 12) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
14 : sum(1, 3, 13) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
15 : prod(1, 14) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
16 : sum(2, 3, 15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
17 : prod(1, 16) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
18 : sym_const(17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
=input.spec-%tmpvar-4.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 65535 ] -> true, [ 65536; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10664 : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 65535 { 0xffff +1.781238e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 65536 { 0x10000 +1.781250e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-0.L3%7%d
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : sum(1, 2, 3) : SUM[UNIT,BV:32]
5 : sym_const(4) : SUM[UNIT,BV:32]
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1299 : BV:32
4 : Lambda10687 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10688 : BV:32
7 : 1858723665 { 0x6ec9df51 +1.57712757e94 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%tmpvar-2.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 67108864 { 0x4000000 +1.0e137 } : BV:32
5 : Indxform1305 : BV:32
6 : Lambda10699 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10700 : BV:32
9 : 1042149592 { 0x3e1df0d8 +1.23391246e253 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 65535 ] -> true, [ 65536; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%tmpvar-3.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.spec-%var-arr_i-0.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-new_l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 67108864 { 0x4000000 +1.0e137 } : BV:32
5 : Indxform1309 : BV:32
6 : Lambda10707 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10708 : BV:32
9 : 1042149592 { 0x3e1df0d8 +1.23391246e253 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 537919556 { 0x20100044 +1.12500810e193 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 524292 { 0x80004 +1.6250047e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4075330952 { 0xf2e89d88 -219636344 -1.81730747e102 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 67108864 { 0x4000000 +1.0e137 } : BV:32
5 : Indxform1313 : BV:32
6 : Lambda10715 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10716 : BV:32
9 : 1042149592 { 0x3e1df0d8 +1.23391246e253 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 977264253 { 0x3a3fde7d +1.49897730e245 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 1979819695 { 0x7601a6af +1.1289927e109 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 11 ] -> 0, [ 12; 12 ] -> 0, [ 13; 13 ] -> 0, [ 14; 14 ] -> 0, [ 15; 15 ] -> 0, [ 16; 16 ] -> 0, [ 17; 17 ] -> 0, [ 18; 18 ] -> 2, [ 19; 19 ] -> 0, [ 20; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1881448620 { 0x7024a0ac +1.28615331e97 } : COUNT
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 11 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 12; 19 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 20; 524291 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524292; 524295 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524296; 537919555 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 537919556; 537919559 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 537919560; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1979819695 { 0x7601a6af +1.1289927e109 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 247027821 { 0xeb9586d +1.44801104e158 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 291585070 { 0x11613c2e +1.75964903e163 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%arr.Lfor.body%2%d
1 : 4075330952 { 0xf2e89d88 -219636344 -1.81730747e102 } : BV:32
=input.dst.llvm-%n.Lfor.body%2%d
1 : 65536 { 0x10000 +1.781250e129 } : BV:32
=input.dst.llvm-mem.Lfor.body%2%d
1 : ([ 0; 11 ] -> 0, [ 12; 19 ] -> 171, [ 20; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-mem.alloc.Lfor.body%2%d
1 : ([ 0; 11 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 12; 19 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 20; 524291 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524292; 524295 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524296; 537919555 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 537919556; 537919559 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 537919560; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.body%2%d
1 : 247027821 { 0xeb9586d +1.44801104e158 } : BV:32
=input.dst.local_alloc_count.Lfor.body%2%d
1 : 1881448620 { 0x7024a0ac +1.28615331e97 } : COUNT
=input.dst.llvm-%i.0.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.body%2%d
1 : 131072 { 0x20000 +1.1562500e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%call.Lfor.body%2%d
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%2%d
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%5886e9cac8f92ed81c176d98bf7d1784.intermediate.gepoffset.2.offset.Lfor.cond%1%bbentry
1 : 4 { 0x4 +1.47e129 } : BV:32
=input.dst.llvm-%arrayidx.Lfor.cond%1%bbentry
1 : 4075330984 { 0xf2e89da8 -219636312 -1.81731128e102 } : BV:32
=input.dst.llvm-%0.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%1.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.1.total_offset.Lfor.cond%1%bbentry
1 : 32 { 0x20 +1.381e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%537c02a60f148c42acb992374da0f0.gepoffset.2.total_offset.Lfor.cond%1%bbentry
1 : 4075330984 { 0xf2e89da8 -219636312 -1.81731128e102 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.gepoffset.3.total_offset.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%b266369ba4ec8e93ac6eb6338c72c0.intermediate.gepoffset.1.offset.Lfor.cond%1%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.dst.llvm-%l.0.phi.tmpvar.for.inc.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-%inc.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%next.Lfor.cond%1%bbentry
1 : 16 { 0x10 +1.190e129 } : BV:32
=input.dst.llvm-%val.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 524292 { 0x80004 +1.6250047e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 524295 { 0x80007 +1.6250083e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 537919556 { 0x20100044 +1.12500810e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 537919559 { 0x20100047 +1.12500846e193 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 67108864 { 0x4000000 +1.0e137 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3157830303
=counter_example_end
=global nodece 76 num_edges_traversed 1
=global nodece 76 nodece_visted_pcs: 
L3%6%bbentry_Lfor.cond%1%bbentry
=global nodece 77
=global nodece 77 nodece z3v487.ce2692.num_edges_traversed2
=global nodece 77 nodece_path
=global nodece 77 nodece_path.graph_edge_composition
(epsilon)
=global nodece 77 nodece_cached_counterexample
=counter_example_begin z3v487.ce2692 dc18e018e3a72d1cd174ee0f432dab
=input.spec-%var-arr-1
1 : Lambda10680 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 65535 { 0xffff +1.781238e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 65536 { 0x10000 +1.781250e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10681 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 65536 { 0x10000 +1.781250e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10683 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 65535 { 0xffff +1.781238e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 65536 { 0x10000 +1.781250e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10684 : BV:32
18 : 8 { 0x8 +1.95e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 65535 ] -> true, [ 65536; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10664 : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 65535 { 0xffff +1.781238e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 65536 { 0x10000 +1.781250e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1299 : BV:32
4 : Lambda10687 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10688 : BV:32
7 : 1858723665 { 0x6ec9df51 +1.57712757e94 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 65535 ] -> true, [ 65536; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 537919556 { 0x20100044 +1.12500810e193 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 524292 { 0x80004 +1.6250047e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4075330952 { 0xf2e89d88 -219636344 -1.81730747e102 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 67108864 { 0x4000000 +1.0e137 } : BV:32
5 : Indxform1313 : BV:32
6 : Lambda10715 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10716 : BV:32
9 : 1042149592 { 0x3e1df0d8 +1.23391246e253 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 977264253 { 0x3a3fde7d +1.49897730e245 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 11 ] -> 0, [ 12; 12 ] -> 0, [ 13; 13 ] -> 0, [ 14; 14 ] -> 0, [ 15; 15 ] -> 0, [ 16; 16 ] -> 0, [ 17; 17 ] -> 0, [ 18; 18 ] -> 2, [ 19; 19 ] -> 0, [ 20; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1881448620 { 0x7024a0ac +1.28615331e97 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 11 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 12; 19 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 20; 524291 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524292; 524295 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524296; 537919555 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 537919556; 537919559 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 537919560; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1979819695 { 0x7601a6af +1.1289927e109 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 247027821 { 0xeb9586d +1.44801104e158 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 291585070 { 0x11613c2e +1.75964903e163 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 524292 { 0x80004 +1.6250047e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 524295 { 0x80007 +1.6250083e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 537919556 { 0x20100044 +1.12500810e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 537919559 { 0x20100047 +1.12500846e193 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 67108864 { 0x4000000 +1.0e137 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=counter_example.random_seed
3157830303
=counter_example_end
=global nodece 77 num_edges_traversed 2
=global nodece 77 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallStart
=global nodece 78
=global nodece 78 nodece z3v487.ce2696.num_edges_traversed3
=global nodece 78 nodece_path
=global nodece 78 nodece_path.graph_edge_composition
(L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd)
=global nodece 78 nodece_cached_counterexample
=counter_example_begin z3v487.ce2696 73b7a8ac0e62348de8ea52bf735d3cd
=nextpc_const.1
1 : 1634823172 { 0x61716c04 +1.88610887e67 } : BV:32
=input.spec-%var-arr-1
1 : Lambda10680 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 65535 { 0xffff +1.781238e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 65536 { 0x10000 +1.781250e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10681 : BV:32
18 : bvule(2, 17) : BOOL
19 : bvule(17, 10) : BOOL
20 : and(18, 19) : BOOL
21 : ite(20, 2, 2) : BV:32
22 : lambda(17, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(16, 22) : MAP[BV:32 -> BV:32]
24 : sym_const(23) : MAP[BV:32 -> BV:32]
=input.dst.llvm-%n.Lfor.cond%1%bbentry
1 : 65536 { 0x10000 +1.781250e129 } : BV:32
=input.spec-%var-arr-0.L3%6%bbentry
1 : Lambda10683 : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvule(2, 1) : BOOL
4 : 65535 { 0xffff +1.781238e129 } : BV:32
5 : bvule(1, 4) : BOOL
6 : and(3, 5) : BOOL
7 : 1 { 0x1 } : BOOL
8 : 65536 { 0x10000 +1.781250e129 } : BV:32
9 : bvule(8, 1) : BOOL
10 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
11 : bvule(1, 10) : BOOL
12 : and(9, 11) : BOOL
13 : 0 { 0x0 } : BOOL
14 : ite(12, 13, 13) : BOOL
15 : ite(6, 7, 14) : BOOL
16 : lambda(1, 15) : FUNCTION[BV:32 -> BOOL]
17 : Lambda10684 : BV:32
18 : 8 { 0x8 +1.95e129 } : BV:32
19 : eq(17, 18) : BOOL
20 : bvule(2, 17) : BOOL
21 : bvule(17, 4) : BOOL
22 : and(20, 21) : BOOL
23 : bvule(8, 17) : BOOL
24 : bvule(17, 10) : BOOL
25 : and(23, 24) : BOOL
26 : ite(25, 13, 13) : BOOL
27 : ite(22, 7, 26) : BOOL
28 : and(20, 24) : BOOL
29 : ite(28, 2, 2) : BV:32
30 : ite(27, 2, 29) : BV:32
31 : ite(19, 2, 30) : BV:32
32 : lambda(17, 31) : FUNCTION[BV:32 -> BV:32]
33 : map(16, 32) : MAP[BV:32 -> BV:32]
34 : sym_const(33) : MAP[BV:32 -> BV:32]
=input.spec-%var-arr-0.L3%6%bbentry.0.1
1 : ([ 0; 65535 ] -> true, [ 65536; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-0.L3%6%bbentry.1.1
1 : Lambda10664 : BV:32
2 : 8 { 0x8 +1.95e129 } : BV:32
3 : eq(1, 2) : BOOL
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 1) : BOOL
6 : 65535 { 0xffff +1.781238e129 } : BV:32
7 : bvule(1, 6) : BOOL
8 : and(5, 7) : BOOL
9 : 1 { 0x1 } : BOOL
10 : 65536 { 0x10000 +1.781250e129 } : BV:32
11 : bvule(10, 1) : BOOL
12 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
13 : bvule(1, 12) : BOOL
14 : and(11, 13) : BOOL
15 : 0 { 0x0 } : BOOL
16 : ite(14, 15, 15) : BOOL
17 : ite(8, 9, 16) : BOOL
18 : and(5, 13) : BOOL
19 : ite(18, 4, 4) : BV:32
20 : ite(17, 4, 19) : BV:32
21 : ite(3, 4, 20) : BV:32
22 : lambda(1, 21) : FUNCTION[BV:32 -> BV:32]
23 : sym_const(22) : FUNCTION[BV:32 -> BV:32]
=input.spec-%tmpvar-9.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry
1 : 0 { 0x0 +1.0e129 } : BV:32
2 : unit : UNIT
3 : Indxform1299 : BV:32
4 : Lambda10687 : BV:32
5 : lambda(4, 4) : FUNCTION[BV:32 -> BV:32]
6 : Lambda10688 : BV:32
7 : 1858723665 { 0x6ec9df51 +1.57712757e94 } : BV:32
8 : prod(7, 3) : PROD[BV:32,BV:32]
9 : sum(1, 2, 8) : SUM[UNIT,PROD[BV:32,BV:32]]
10 : lambda(6, 9) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
11 : ind(1, 3, 5, 10) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
12 : prod(1, 11) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
13 : sum(1, 2, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(1, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(1, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : sym_const(15) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.spec-%var-arr-1.0.1
1 : ([ 0; 65535 ] -> true, [ 65536; 4294967295 ] -> false, ) : FUNCTION[BV:32 -> BOOL]
=input.spec-%var-arr-1.1.1
1 : ([ 0; 4294967295 ] -> 0, ) : FUNCTION[BV:32 -> BV:32]
=input.dst.local./*___y___make_list__x__=L0%0%argnum0=/
1 : 537919556 { 0x20100044 +1.12500810e193 } : BV:32
=input.dst.local./*___y___make_list__x__=L0%0%argnum1=/
1 : 524292 { 0x80004 +1.6250047e129 } : BV:32
=input.dst.llvm-%arr.Lfor.cond%1%bbentry
1 : 4075330952 { 0xf2e89d88 -219636344 -1.81730747e102 } : BV:32
=input.spec-%var-i-0.L3%6%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=func.calla4bcb626de6152719ca44f8b649b9c4a.reg
1 : (( memlabel-mem--dummy , memlabel-mem--dummy , ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 181 , m_adder -> 247), ) , ([ 0; 4294967295 ] -> memlabel-mem--dummy, ) , 1634823172 , 1000 , 8 ) -> 1940745219, () -> 2120597293, ) : FUNCTION[MEMLABEL,MEMLABEL,ARRAY[BV:32 -> BV:8],ARRAY[BV:32 -> MEMLABEL],BV:32,REGID,BV:32 -> BV:32]
=input.spec-%var-l-0.L3%6%bbentry
1 : 1 { 0x1 +1.11e129 } : BV:32
2 : unit : UNIT
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : 67108864 { 0x4000000 +1.0e137 } : BV:32
5 : Indxform1313 : BV:32
6 : Lambda10715 : BV:32
7 : lambda(6, 6) : FUNCTION[BV:32 -> BV:32]
8 : Lambda10716 : BV:32
9 : 1042149592 { 0x3e1df0d8 +1.23391246e253 } : BV:32
10 : prod(9, 5) : PROD[BV:32,BV:32]
11 : sum(3, 2, 10) : SUM[UNIT,PROD[BV:32,BV:32]]
12 : lambda(8, 11) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
13 : ind(3, 5, 7, 12) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
14 : prod(3, 13) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
15 : sum(3, 2, 14) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
16 : prod(3, 15) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
17 : sum(4, 2, 16) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
18 : prod(3, 17) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
19 : sum(1, 2, 18) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
20 : sym_const(19) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=input.src.spec-ghostvar.itervar.1.L3%6%bbentry
1 : 977264253 { 0x3a3fde7d +1.49897730e245 } : BV:32
=input.dst.llvm-mem.Lfor.cond%1%bbentry
1 : ([ 0; 11 ] -> 0, [ 12; 12 ] -> 0, [ 13; 13 ] -> 0, [ 14; 14 ] -> 0, [ 15; 15 ] -> 0, [ 16; 16 ] -> 0, [ 17; 17 ] -> 0, [ 18; 18 ] -> 2, [ 19; 19 ] -> 0, [ 20; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-%cmp.Lfor.cond%2%d
1 : 1 { 0x1 } : BOOL
=input.dst.local_alloc_count.Lfor.cond%1%bbentry
1 : 1881448620 { 0x7024a0ac +1.28615331e97 } : COUNT
=input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry
1 : ([ 0; 11 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 12; 19 ] -> memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/, [ 20; 524291 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 524292; 524295 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/, [ 524296; 537919555 ] -> memlabel-mem-may-straddle-symbol.1-heap, [ 537919556; 537919559 ] -> memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/, [ 537919560; 4294967295 ] -> memlabel-mem-may-straddle-symbol.1-heap, ) : ARRAY[BV:32 -> MEMLABEL]
=input.dst.llvm-%l.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 1979819695 { 0x7601a6af +1.1289927e109 } : BV:32
=input.dst.llvm-mem.Lfor.body%1%fcallEnd
1 : ([ 0; 11 ] -> 0, [ 12; 12 ] -> 0, [ 13; 13 ] -> 0, [ 14; 14 ] -> 0, [ 15; 15 ] -> 0, [ 16; 16 ] -> 0, [ 17; 17 ] -> 0, [ 18; 18 ] -> 2, [ 19; 19 ] -> 0, [ 20; 4294967295 ] -> 0, ) : ARRAY[BV:32 -> BV:8]
=input.dst.llvm-fcall_arg_copy.0.8.BV_32.Lfor.body%1%fcallEnd
1 : 8 { 0x8 +1.95e129 } : BV:32
=input.dst.llvm-%i.0.phi.tmpvar.entry.Lfor.cond%1%bbentry
1 : 247027821 { 0xeb9586d +1.44801104e158 } : BV:32
=input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1 : 9 { 0x9 +1.107e129 } : BV:32
=input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1 : 12 { 0xc +1.143e129 } : BV:32
=input.dst.llvm-ghostvar.itervar.1.Lfor.cond%1%bbentry
1 : 291585070 { 0x11613c2e +1.75964903e163 } : BV:32
=input.dst.llvm-%call.Lfor.body%1%fcallEnd
1 : 1940745219 { 0x73ad6c03 +1.35485875e104 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin
1 : 524292 { 0x80004 +1.6250047e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end
1 : 524295 { 0x80007 +1.6250083e129 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin
1 : 537919556 { 0x20100044 +1.12500810e193 } : BV:32
=input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end
1 : 537919559 { 0x20100047 +1.12500846e193 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%tmpvar-10.L3%6%bbentry.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.0
1 : 67108864 { 0x4000000 +1.0e137 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.1.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=input.spec-%var-l-0.L3%6%bbentry.2.1.2.0
1 : 0 { 0x0 +1.0e129 } : BV:32
=memzero_memvar
1 : ({ [ 0; 4294967295 ], } -> (RAC: m_multiplier -> 181 , m_adder -> 247), ) : ARRAY[BV:32 -> BV:8]
=counter_example.random_seed
1113302275
=counter_example_end
=global nodece 78 num_edges_traversed 3
=global nodece 78 nodece_visted_pcs: 
L3%6%bbentry_Lfor.body%1%fcallEnd
=graph_with_ce done
=point_set for reason inductive-invariants
=inductive-invariants point_set global exprs map
=inductive-invariants point_set point_expr 1
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=inductive-invariants point_set point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=inductive-invariants point_set point_expr 3
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=inductive-invariants point_set point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=inductive-invariants point_set point_expr 5
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=inductive-invariants point_set point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=inductive-invariants point_set point_expr 7
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=inductive-invariants point_set point_expr 8
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=inductive-invariants point_set point_expr 9
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=inductive-invariants point_set point_expr 10
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=inductive-invariants point_set point_expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=inductive-invariants point_set point_expr 12
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=inductive-invariants point_set point_expr 13
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=inductive-invariants point_set point_expr 14
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=inductive-invariants point_set point_expr 15
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 16
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 17
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : bvadd(14, 5) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(10, 11, 12, 15, 16, 17) : BV:32
19 : lambda(9, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(8, 19) : MAP[BV:32 -> BV:32]
21 : eq(1, 20) : BOOL
=inductive-invariants point_set point_expr 18
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 19
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 20
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 21
1 : spec-%tmpvar-10.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 0 { 0x0 +1.0e1025 } : INT
4 : unit : UNIT
5 : sum_init(2, 3, 4) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : eq(1, 5) : BOOL
=inductive-invariants point_set point_expr 22
1 : spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 23
1 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 0 { 0x0 +1.0e1025 } : INT
4 : unit : UNIT
5 : sum_init(2, 3, 4) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : eq(1, 5) : BOOL
=inductive-invariants point_set point_expr 24
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 25
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 26
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 27
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 28
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=inductive-invariants point_set point_expr 29
1 : spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : input.spec-%var-i-0.L3%6%bbentry : BV:32
23 : map_get(21, 22) : SUM[UNIT,BV:32]
24 : eq(1, 23) : BOOL
=inductive-invariants point_set point_expr 30
1 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 31
1 : spec-%tmpvar-1.L3%6%bbentry : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
3 : Lambda0 : BV:32
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 3) : BOOL
6 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
7 : bvult(3, 6) : BOOL
8 : and(5, 7) : BOOL
9 : lambda(3, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda1 : BV:32
11 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
12 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
13 : memlabel-top : MEMLABEL
14 : 4 { 0x4 +1.47e129 } : BV:32
15 : bvmul(10, 14) : BV:32
16 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
17 : bvadd(15, 16) : BV:32
18 : 4 { 0x4 +1.0e1025 } : INT
19 : 0 { 0x0 } : BOOL
20 : select(11, 12, 13, 17, 18, 19) : BV:32
21 : lambda(10, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(9, 21) : MAP[BV:32 -> BV:32]
23 : input.spec-%var-i-0.L3%6%bbentry : BV:32
24 : map_get(22, 23) : SUM[UNIT,BV:32]
25 : 1 { 0x1 +1.0e1025 } : INT
26 : sum_get(24, 25) : BV:32
27 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
28 : Indxform0 : BV:32
29 : bvadd(10, 14) : BV:32
30 : select(11, 12, 13, 29, 18, 19) : BV:32
31 : lambda(10, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(4, 3) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 4, 33) : BV:32
35 : unit : UNIT
36 : select(11, 12, 13, 3, 18, 19) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(3, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(27, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(2, 26, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : eq(1, 41) : BOOL
=inductive-invariants point_set point_expr 32
1 : spec-%tmpvar-2.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 33
1 : spec-%var-new_l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 34
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 35
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(18, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=inductive-invariants point_set point_expr 36
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 37
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(8, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=inductive-invariants point_set point_expr 38
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : bvadd(17, 8) : BV:32
19 : 4 { 0x4 +1.0e1025 } : INT
20 : 0 { 0x0 } : BOOL
21 : select(13, 14, 15, 18, 19, 20) : BV:32
22 : lambda(12, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(11, 22) : MAP[BV:32 -> BV:32]
24 : input.spec-%var-i-0.L3%6%bbentry : BV:32
25 : map_get(23, 24) : SUM[UNIT,BV:32]
26 : sum_get(25, 3) : BV:32
27 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 19, 20) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 19, 20) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(27, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 26, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=inductive-invariants point_set point_expr 39
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 40
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(8, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=inductive-invariants point_set point_expr 41
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=inductive-invariants point_set point_expr 42
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 43
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 44
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : bvadd(14, 5) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(10, 11, 12, 15, 16, 17) : BV:32
19 : lambda(9, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(8, 19) : MAP[BV:32 -> BV:32]
21 : eq(1, 20) : BOOL
=inductive-invariants point_set point_expr 45
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 46
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 47
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 48
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 49
1 : spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : input.spec-%var-i-0.L3%6%bbentry : BV:32
23 : map_get(21, 22) : SUM[UNIT,BV:32]
24 : eq(1, 23) : BOOL
=inductive-invariants point_set point_expr 50
1 : spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=inductive-invariants point_set point_expr 51
1 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 52
1 : spec-%tmpvar-1.L3%6%bbentry : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
3 : Lambda0 : BV:32
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 3) : BOOL
6 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
7 : bvult(3, 6) : BOOL
8 : and(5, 7) : BOOL
9 : lambda(3, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda1 : BV:32
11 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
12 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
13 : memlabel-top : MEMLABEL
14 : 4 { 0x4 +1.47e129 } : BV:32
15 : bvmul(10, 14) : BV:32
16 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
17 : bvadd(15, 16) : BV:32
18 : 4 { 0x4 +1.0e1025 } : INT
19 : 0 { 0x0 } : BOOL
20 : select(11, 12, 13, 17, 18, 19) : BV:32
21 : lambda(10, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(9, 21) : MAP[BV:32 -> BV:32]
23 : input.spec-%var-i-0.L3%6%bbentry : BV:32
24 : map_get(22, 23) : SUM[UNIT,BV:32]
25 : 1 { 0x1 +1.0e1025 } : INT
26 : sum_get(24, 25) : BV:32
27 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
28 : Indxform0 : BV:32
29 : bvadd(10, 14) : BV:32
30 : select(11, 12, 13, 29, 18, 19) : BV:32
31 : lambda(10, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(4, 3) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 4, 33) : BV:32
35 : unit : UNIT
36 : select(11, 12, 13, 3, 18, 19) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(3, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(27, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(2, 26, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : eq(1, 41) : BOOL
=inductive-invariants point_set point_expr 53
1 : spec-%tmpvar-2.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 54
1 : spec-%var-new_l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 55
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 56
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 57
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 58
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 59
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=inductive-invariants point_set point_expr 60
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 61
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(18, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=inductive-invariants point_set point_expr 62
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 63
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(8, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=inductive-invariants point_set point_expr 64
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : bvadd(17, 8) : BV:32
19 : 4 { 0x4 +1.0e1025 } : INT
20 : 0 { 0x0 } : BOOL
21 : select(13, 14, 15, 18, 19, 20) : BV:32
22 : lambda(12, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(11, 22) : MAP[BV:32 -> BV:32]
24 : input.spec-%var-i-0.L3%6%bbentry : BV:32
25 : map_get(23, 24) : SUM[UNIT,BV:32]
26 : sum_get(25, 3) : BV:32
27 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 19, 20) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 19, 20) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(27, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 26, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=inductive-invariants point_set point_expr 65
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 66
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(8, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=inductive-invariants point_set point_expr 67
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set point_expr 68
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=inductive-invariants point_set global exprs map done
=inductive-invariants point_set points
=inductive-invariants point_set point z3.ce5
=inductive-invariants point_set point z3.ce5 expr point z3.ce5
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2859808244
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce5 expr point z3.ce5 done
=inductive-invariants point_set point z3v487.ce20
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
262144
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce20 expr point z3v487.ce20 done
=inductive-invariants point_set point z3.ce19
=inductive-invariants point_set point z3.ce19 expr point z3.ce19
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4139645696
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
150402806
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce19 expr point z3.ce19 done
=inductive-invariants point_set point z3v487.ce42
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce42 expr point z3v487.ce42 done
=inductive-invariants point_set point z3.ce41
=inductive-invariants point_set point z3.ce41 expr point z3.ce41
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4294090240
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4076007937
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce41 expr point z3.ce41 done
=inductive-invariants point_set point z3v487.ce64
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4294967040
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4294967295
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce64 expr point z3v487.ce64 done
=inductive-invariants point_set point z3.ce63
=inductive-invariants point_set point z3.ce63 expr point z3.ce63
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3982394112
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4294967295
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce63 expr point z3.ce63 done
=inductive-invariants point_set point z3v487.ce86
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce86 expr point z3v487.ce86 done
=inductive-invariants point_set point z3.ce85
=inductive-invariants point_set point z3.ce85 expr point z3.ce85
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4284083456
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
3991792897
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce85 expr point z3.ce85 done
=inductive-invariants point_set point z3v487.ce110
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
17825808
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce110 expr point z3v487.ce110 done
=inductive-invariants point_set point z3.ce109
=inductive-invariants point_set point z3.ce109 expr point z3.ce109
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
322408992
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce109 expr point z3.ce109 done
=inductive-invariants point_set point z3.ce131
=inductive-invariants point_set point z3.ce131 expr point z3.ce131
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3113745468
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce131 expr point z3.ce131 done
=inductive-invariants point_set point z3v487.ce132
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
806883344
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce132 expr point z3v487.ce132 done
=inductive-invariants point_set point z3v487.ce154
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
17825808
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce154 expr point z3v487.ce154 done
=inductive-invariants point_set point z3.ce153
=inductive-invariants point_set point z3.ce153 expr point z3.ce153
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
322408992
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce153 expr point z3.ce153 done
=inductive-invariants point_set point z3v487.ce179
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce179 expr point z3v487.ce179 done
=inductive-invariants point_set point z3.ce602
=inductive-invariants point_set point z3.ce602 expr point z3.ce602
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce602 expr point z3.ce602 done
=inductive-invariants point_set point z3v487.ce606
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
128
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce606 expr point z3v487.ce606 done
=inductive-invariants point_set point z3v487.ce846
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce846 expr point z3v487.ce846 done
=inductive-invariants point_set point z3.ce845
=inductive-invariants point_set point z3.ce845 expr point z3.ce845
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce845 expr point z3.ce845 done
=inductive-invariants point_set point z3v487.ce868
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
256
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce868 expr point z3v487.ce868 done
=inductive-invariants point_set point z3.ce867
=inductive-invariants point_set point z3.ce867 expr point z3.ce867
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4194304
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1048576
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce867 expr point z3.ce867 done
=inductive-invariants point_set point z3v487.ce889
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
64
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce889 expr point z3v487.ce889 done
=inductive-invariants point_set point z3.ce890
=inductive-invariants point_set point z3.ce890 expr point z3.ce890
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4096
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
128
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce890 expr point z3.ce890 done
=inductive-invariants point_set point z3v487.ce911
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce911 expr point z3v487.ce911 done
=inductive-invariants point_set point z3.ce912
=inductive-invariants point_set point z3.ce912 expr point z3.ce912
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
16
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
128
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce912 expr point z3.ce912 done
=inductive-invariants point_set point z3v487.ce933
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
262144
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce933 expr point z3v487.ce933 done
=inductive-invariants point_set point z3.ce934
=inductive-invariants point_set point z3.ce934 expr point z3.ce934
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
32
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce934 expr point z3.ce934 done
=inductive-invariants point_set point z3v487.ce956
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4294967295
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce956 expr point z3v487.ce956 done
=inductive-invariants point_set point z3.ce955
=inductive-invariants point_set point z3.ce955 expr point z3.ce955
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4294967295
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce955 expr point z3.ce955 done
=inductive-invariants point_set point z3v487.ce977
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
512
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce977 expr point z3v487.ce977 done
=inductive-invariants point_set point z3.ce978
=inductive-invariants point_set point z3.ce978 expr point z3.ce978
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4096
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce978 expr point z3.ce978 done
=inductive-invariants point_set point z3v487.ce1008
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1610776592
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
41976065
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1008 expr point z3v487.ce1008 done
=inductive-invariants point_set point z3.ce1007
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1208308536
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
77840897
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1007 expr point z3.ce1007 done
=inductive-invariants point_set point z3v487.ce1031
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8388608
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1031 expr point z3v487.ce1031 done
=inductive-invariants point_set point z3.ce1032
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
128
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1032 expr point z3.ce1032 done
=inductive-invariants point_set point z3v487.ce1070
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
134873216
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2097152
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1070 expr point z3v487.ce1070 done
=inductive-invariants point_set point z3.ce1069
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
808722436
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
268435456
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1069 expr point z3.ce1069 done
=inductive-invariants point_set point z3v487.ce1091
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
19005444
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1091 expr point z3v487.ce1091 done
=inductive-invariants point_set point z3.ce1092
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2151589524
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
262144
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1092 expr point z3.ce1092 done
=inductive-invariants point_set point z3v487.ce1115
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
344457732
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce1115 expr point z3v487.ce1115 done
=inductive-invariants point_set point z3.ce1116
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1213444
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2097152
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce1116 expr point z3.ce1116 done
=inductive-invariants point_set point z3.ce1223
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4096
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1847547135
=inductive-invariants point_set point z3.ce1223 expr point z3.ce1223 done
=inductive-invariants point_set point z3v487.ce1226
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
2016219116
=inductive-invariants point_set point z3v487.ce1226 expr point z3v487.ce1226 done
=inductive-invariants point_set point z3.ce1253
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3982394112
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4294967295
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1049355574
=inductive-invariants point_set point z3.ce1253 expr point z3.ce1253 done
=inductive-invariants point_set point z3.ce1256
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4294090240
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4076007937
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1081939524
=inductive-invariants point_set point z3.ce1256 expr point z3.ce1256 done
=inductive-invariants point_set point z3v487.ce1259
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
262144
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1441260588
=inductive-invariants point_set point z3v487.ce1259 expr point z3v487.ce1259 done
=inductive-invariants point_set point z3.ce1262
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4139645696
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
150402806
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
44611973
=inductive-invariants point_set point z3.ce1262 expr point z3.ce1262 done
=inductive-invariants point_set point z3v487.ce1613
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
128
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1258173929
=inductive-invariants point_set point z3v487.ce1613 expr point z3v487.ce1613 done
=inductive-invariants point_set point z3.ce1614
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
512
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1503266444
=inductive-invariants point_set point z3.ce1614 expr point z3.ce1614 done
=inductive-invariants point_set point z3v487.ce1634
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
252153669
=inductive-invariants point_set point z3v487.ce1634 expr point z3v487.ce1634 done
=inductive-invariants point_set point z3.ce1633
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
32
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1283148321
=inductive-invariants point_set point z3.ce1633 expr point z3.ce1633 done
=inductive-invariants point_set point z3v487.ce1654
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1828042454
=inductive-invariants point_set point z3v487.ce1654 expr point z3v487.ce1654 done
=inductive-invariants point_set point z3.ce1653
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
196822121
=inductive-invariants point_set point z3.ce1653 expr point z3.ce1653 done
=inductive-invariants point_set point z3v487.ce1676
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
541206552
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
128
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
912306717
=inductive-invariants point_set point z3v487.ce1676 expr point z3v487.ce1676 done
=inductive-invariants point_set point z3.ce1675
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
356679716
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
131072
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
266830142
=inductive-invariants point_set point z3.ce1675 expr point z3.ce1675 done
=inductive-invariants point_set point z3v487.ce1696
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
856162368
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
536870912
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1316296861
=inductive-invariants point_set point z3v487.ce1696 expr point z3v487.ce1696 done
=inductive-invariants point_set point z3.ce1695
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
606135320
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1935048384
=inductive-invariants point_set point z3.ce1695 expr point z3.ce1695 done
=inductive-invariants point_set point z3v487.ce1727
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2299527172
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
16
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
2032095852
=inductive-invariants point_set point z3v487.ce1727 expr point z3v487.ce1727 done
=inductive-invariants point_set point z3.ce1728
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
814257728
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
16384
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1681317052
=inductive-invariants point_set point z3.ce1728 expr point z3.ce1728 done
=inductive-invariants point_set point z3v487.ce1747
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2159181888
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1031971771
=inductive-invariants point_set point z3v487.ce1747 expr point z3v487.ce1747 done
=inductive-invariants point_set point z3.ce1748
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
298389888
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
8652882
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
2105631410
=inductive-invariants point_set point z3.ce1748 expr point z3.ce1748 done
=inductive-invariants point_set point z3v487.ce1783
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
213000
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1048576
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
2147483650
=inductive-invariants point_set point z3v487.ce1783 expr point z3v487.ce1783 done
=inductive-invariants point_set point z3v487.ce1794
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1113401712
=inductive-invariants point_set point z3v487.ce1794 expr point z3v487.ce1794 done
=inductive-invariants point_set point z3.ce1795
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1199676058
=inductive-invariants point_set point z3.ce1795 expr point z3.ce1795 done
=inductive-invariants point_set point z3v487.ce1814
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
140655648
=inductive-invariants point_set point z3v487.ce1814 expr point z3v487.ce1814 done
=inductive-invariants point_set point z3.ce1815
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 2 for input.spec-%var-i-0.L3%6%bbentry
0
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1149516087
=inductive-invariants point_set point z3.ce1815 expr point z3.ce1815 done
=inductive-invariants point_set point z3v487.ce1847
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
184593444
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
67108864
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce1847 expr point z3v487.ce1847 done
=inductive-invariants point_set point z3.ce1857
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1088712248
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4294959104
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
524288
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1857 expr point z3.ce1857 done
=inductive-invariants point_set point z3.ce1918
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4194304
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
255197840
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1048576
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1918 expr point z3.ce1918 done
=inductive-invariants point_set point z3.ce1975
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4194304
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
255197840
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
1048576
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
255197840
=inductive-invariants point_set point z3.ce1975 expr point z3.ce1975 done
=inductive-invariants point_set point z3.ce2004
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1503266444
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
512
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce2004 expr point z3.ce2004 done
=inductive-invariants point_set point z3.ce2047
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
1088712248
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4294959104
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
524288
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1856366187
=inductive-invariants point_set point z3.ce2047 expr point z3.ce2047 done
=inductive-invariants point_set point z3v487.ce2251
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
16
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
16384
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce2251 expr point z3v487.ce2251 done
=inductive-invariants point_set point z3.ce2250
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
3959422768
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2048
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3.ce2250 expr point z3.ce2250 done
=inductive-invariants point_set point z3v487.ce2285
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2048
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
371744682
=inductive-invariants point_set point z3v487.ce2285 expr point z3v487.ce2285 done
=inductive-invariants point_set point z3.ce2286
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
0
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4294967284
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
524288
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1541320253
=inductive-invariants point_set point z3.ce2286 expr point z3.ce2286 done
=inductive-invariants point_set point z3v487.ce2349
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3910860576
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1073815548
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1460555473
=inductive-invariants point_set point z3v487.ce2349 expr point z3v487.ce2349 done
=inductive-invariants point_set point z3v487.ce2314
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 2 for input.spec-%var-i-0.L3%6%bbentry
1
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3910860576
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
1
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1073815548
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2314 expr point z3v487.ce2314 done
=inductive-invariants point_set point z3v487.ce2395
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 2 for input.spec-%var-i-0.L3%6%bbentry
2
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2126512124
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
2
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1440389235
=inductive-invariants point_set point z3v487.ce2395 expr point z3v487.ce2395 done
=inductive-invariants point_set point z3v487.ce2360
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 2 for input.spec-%var-i-0.L3%6%bbentry
2
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2126512124
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
2
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1073741824
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2360 expr point z3v487.ce2360 done
=inductive-invariants point_set point z3v487.ce2446
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 2 for input.spec-%var-i-0.L3%6%bbentry
4
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2184183816
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
32
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
559551460
=inductive-invariants point_set point z3v487.ce2446 expr point z3v487.ce2446 done
=inductive-invariants point_set point z3v487.ce2411
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 2 for input.spec-%var-i-0.L3%6%bbentry
4
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2184183816
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
32
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2411 expr point z3v487.ce2411 done
=inductive-invariants point_set point z3v487.ce2481
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 2 for input.spec-%var-i-0.L3%6%bbentry
5
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2184183816
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
5
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
559551460
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
32
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce2481 expr point z3v487.ce2481 done
=inductive-invariants point_set point z3v487.ce2531
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 2 for input.spec-%var-i-0.L3%6%bbentry
5
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3113271288
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
5
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
9
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
995404440
=inductive-invariants point_set point z3v487.ce2531 expr point z3v487.ce2531 done
=inductive-invariants point_set point z3v487.ce2496
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 2 for input.spec-%var-i-0.L3%6%bbentry
5
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3113271288
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
5
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
9
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2496 expr point z3v487.ce2496 done
=inductive-invariants point_set point z3v487.ce2566
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 2 for input.spec-%var-i-0.L3%6%bbentry
6
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
3113271288
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
6
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
995404440
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
9
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce2566 expr point z3v487.ce2566 done
=inductive-invariants point_set point z3v487.ce2611
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 2 for input.spec-%var-i-0.L3%6%bbentry
8
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2118226944
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1341558580
=inductive-invariants point_set point z3v487.ce2611 expr point z3v487.ce2611 done
=inductive-invariants point_set point z3v487.ce2576
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 2 for input.spec-%var-i-0.L3%6%bbentry
8
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2118226944
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
8
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
4
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2576 expr point z3v487.ce2576 done
=inductive-invariants point_set point z3v487.ce2646
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 2 for input.spec-%var-i-0.L3%6%bbentry
9
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
2118226944
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
9
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
1341558580
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
2147483648
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 val 28 for input.dst.llvm-%cmp.Lfor.cond%2%d
1
=inductive-invariants point_set point z3v487.ce2646 expr point z3v487.ce2646 done
=inductive-invariants point_set point z3v487.ce2696
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 2 for input.spec-%var-i-0.L3%6%bbentry
9
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4075330952
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
9
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
12
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
65536
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 val 41 for input.dst.llvm-%call.Lfor.body%1%fcallEnd
1940745219
=inductive-invariants point_set point z3v487.ce2696 expr point z3v487.ce2696 done
=inductive-invariants point_set point z3v487.ce2661
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 1 for and(and(and(and(and(and(bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin, bvadd(4, 4294967295)))), bvule(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end)), eq(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end, bvadd(input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin, bvadd(4, 4294967295)))), and(eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, 3), 0), eq(bvand(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, 3), 0))), and(eq(input.dst.local./*___y___make_list__x__=L0%0%argnum1=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin), eq(input.dst.local./*___y___make_list__x__=L0%0%argnum0=/, input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin))), region_agrees_with_memlabel(input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry, 0, 1, memlabel-mem-may-straddle-symbol.1-heap))
1
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 2 for input.spec-%var-i-0.L3%6%bbentry
9
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 3 for input.dst.llvm-%arr.Lfor.cond%1%bbentry
4075330952
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 4 for input.dst.llvm-%i.0.Lfor.cond%1%bbentry
9
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 5 for input.dst.llvm-%l.0.Lfor.cond%1%bbentry
12
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 6 for input.dst.llvm-%n.Lfor.cond%1%bbentry
65536
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 7 for bvslt(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 8 for bvult(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 9 for bvslt(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 10 for bvult(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 11 for bvsle(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 12 for bvule(input.dst.llvm-%i.0.Lfor.cond%1%bbentry, input.dst.llvm-%n.Lfor.cond%1%bbentry)
1
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 13 for bvsle(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 val 14 for bvule(input.dst.llvm-%n.Lfor.cond%1%bbentry, input.dst.llvm-%i.0.Lfor.cond%1%bbentry)
0
=inductive-invariants point_set point z3v487.ce2661 expr point z3v487.ce2661 done
=inductive-invariants point_set points done
=out-of-bound-exprs for reason inductive-invariants
=out-of-bound-exprs for reason inductive-invariants at L0%0%d_L0%0%d

=out-of-bound-exprs for reason inductive-invariants at L3%6%bbentry_Lfor.body%1%fcallStart

=out-of-bound-exprs for reason inductive-invariants at L3%6%bbentry_Lfor.body%1%fcallEnd

=out-of-bound-exprs for reason inductive-invariants at L3%6%bbentry_Lfor.cond%1%bbentry

=out-of-bound-exprs for reason inductive-invariants at E0%0%d_E0%0%d

=graph_with_points done
=Invariant state at node L0%0%d_L0%0%d for reason inductive-invariants
=pc L0%0%d_L0%0%d inductive-invariants invariant_state 
is_top 0
is_stable 1
=pc L0%0%d_L0%0%d inductive-invariants invariant_state failcond.description

=pc L0%0%d_L0%0%d inductive-invariants invariant_state failcond.expr is null
=pc L0%0%d_L0%0%d inductive-invariants invariant_state failcond done
=pc L0%0%d_L0%0%d inductive-invariants invariant_state done
=Invariant state at node L3%6%bbentry_Lfor.body%1%fcallStart for reason inductive-invariants
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants invariant_state 
is_top 0
is_stable 1
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants invariant_state failcond.description

=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants invariant_state failcond.expr is null
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants invariant_state failcond done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability name abstract-memlabel-asserts
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability expr_group_type HOUDINI_EXPECTS_STABILITY with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability point_expr 1
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability pred 0
=Comment
abstract-memlabel-asserts-houdini-guess
=LhsExpr
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ce 0: z3v487.ce606
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 0 type houdini_expects_stability summary: number of exprs=1; number of visited CEs=1; number of preds=1
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv name expr-group-bvs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv expr_group_type BV_EQ with 6 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 3
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 5
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv point_expr 28
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv pred 0
=Comment
expr-group-bvs.linear1-32-free_var_idx.28
=LhsExpr
1 : 1 { 0x1 +1.11e129 } : BV:32
=RhsExpr
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
2 : bool_to_bv(1) : BV:1
3 : 31 { 0x1f +1.0e1025 } : INT
4 : bvzero_ext(2, 3) : BV:32
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv pred 1
=Comment
expr-group-bvs.linear1-2-free_var_idx.5
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv pred 2
=Comment
expr-group-bvs.linear1-2-free_var_idx.3
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv pred 3
=Comment
expr-group-bvs.linear2-32-free_var_idx.2
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvneg(3) : BV:32
=RhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 0: z3.ce602
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 1: z3v487.ce606
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 2: z3.ce845
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 3: z3.ce867
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 4: z3v487.ce889
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 5: z3v487.ce911
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 6: z3v487.ce933
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 7: z3.ce2004
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ce 8: z3.ce2250
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv summary: number of exprs=6; number of visited CEs=9; number of preds=4
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv output matrix
matrix:
2
-2147483648->0; 2->4294967295; 3->0; 4->1; 5->0; 6->0; 28->0; 
3
-2147483648->0; 2->0; 3->1073741824; 4->0; 5->0; 6->0; 28->0; 
5
-2147483648->0; 2->0; 3->0; 4->0; 5->1073741824; 6->0; 28->0; 
28
-2147483648->4294967295; 2->0; 3->0; 4->0; 5->0; 6->0; 28->1; 
matrix done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 1 type bv state elems done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const name src-branches-const-ineq
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const pred 0
=Comment
src-branches-const-ineq.ub-unsigned
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const pred 1
=Comment
src-branches-const-ineq.lb-signed
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const visited ce 0: z3v487.ce606
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const visited ce 1: z3.ce2004
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const visited ce 2: z3v487.ce2481
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const visited ce 3: z3v487.ce2646
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const summary: number of exprs=1; number of visited CEs=4; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 2 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const pred 0
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.ub-unsigned
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const pred 1
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.lb-signed
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const visited ce 0: z3v487.ce606
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const visited ce 1: z3.ce2004
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const visited ce 2: z3v487.ce2481
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const visited ce 3: z3v487.ce2646
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const summary: number of exprs=1; number of visited CEs=4; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 3 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%n.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const pred 0
=Comment
dst-branches-const-ineq.input.dst.llvm-%n.Lfor.cond%1%bbentry.lb-unsigned
=LhsExpr
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvuge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const visited ce 0: z3.ce602
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const visited ce 1: z3v487.ce606
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const visited ce 2: z3v487.ce889
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const visited ce 3: z3.ce955
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const summary: number of exprs=1; number of visited CEs=4; number of preds=1
=m_lower_bound_signed_cur -2147483648
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 1
=m_upper_bound_unsigned_cur 4294967295
=m_lower_bound_signed_known -2147483648
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 1
=m_upper_bound_unsigned_known 4294967295
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 4 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini name dst-ineq
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini expr_group_type HOUDINI with 8 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 7
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 8
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 9
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 10
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 12
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 13
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini point_expr 14
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini pred 0
=Comment
dst-ineq-houdini-guess
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini pred 1
=Comment
dst-ineq-houdini-guess
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini visited ce 0: z3v487.ce606
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini visited ce 1: z3v487.ce889
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 5 type houdini summary: number of exprs=8; number of visited CEs=2; number of preds=2
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based name spec-coupling-invariants
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based expr_group_type HOUDINI_AXIOM_BASED with 23 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 15
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 16
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 17
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : bvadd(14, 5) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(10, 11, 12, 15, 16, 17) : BV:32
19 : lambda(9, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(8, 19) : MAP[BV:32 -> BV:32]
21 : eq(1, 20) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 18
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 19
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 20
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 22
1 : spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 24
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 25
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 26
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 27
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 29
1 : spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : input.spec-%var-i-0.L3%6%bbentry : BV:32
23 : map_get(21, 22) : SUM[UNIT,BV:32]
24 : eq(1, 23) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 30
1 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 31
1 : spec-%tmpvar-1.L3%6%bbentry : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
3 : Lambda0 : BV:32
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 3) : BOOL
6 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
7 : bvult(3, 6) : BOOL
8 : and(5, 7) : BOOL
9 : lambda(3, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda1 : BV:32
11 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
12 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
13 : memlabel-top : MEMLABEL
14 : 4 { 0x4 +1.47e129 } : BV:32
15 : bvmul(10, 14) : BV:32
16 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
17 : bvadd(15, 16) : BV:32
18 : 4 { 0x4 +1.0e1025 } : INT
19 : 0 { 0x0 } : BOOL
20 : select(11, 12, 13, 17, 18, 19) : BV:32
21 : lambda(10, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(9, 21) : MAP[BV:32 -> BV:32]
23 : input.spec-%var-i-0.L3%6%bbentry : BV:32
24 : map_get(22, 23) : SUM[UNIT,BV:32]
25 : 1 { 0x1 +1.0e1025 } : INT
26 : sum_get(24, 25) : BV:32
27 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
28 : Indxform0 : BV:32
29 : bvadd(10, 14) : BV:32
30 : select(11, 12, 13, 29, 18, 19) : BV:32
31 : lambda(10, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(4, 3) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 4, 33) : BV:32
35 : unit : UNIT
36 : select(11, 12, 13, 3, 18, 19) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(3, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(27, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(2, 26, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : eq(1, 41) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 32
1 : spec-%tmpvar-2.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 33
1 : spec-%var-new_l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 34
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 35
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(18, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 36
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 37
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(8, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 38
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : bvadd(17, 8) : BV:32
19 : 4 { 0x4 +1.0e1025 } : INT
20 : 0 { 0x0 } : BOOL
21 : select(13, 14, 15, 18, 19, 20) : BV:32
22 : lambda(12, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(11, 22) : MAP[BV:32 -> BV:32]
24 : input.spec-%var-i-0.L3%6%bbentry : BV:32
25 : map_get(23, 24) : SUM[UNIT,BV:32]
26 : sum_get(25, 3) : BV:32
27 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 19, 20) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 19, 20) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(27, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 26, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 39
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 40
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(8, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 0
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 1
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 2
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ce 0: z3v487.ce606
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants smallest_point_cover 6 type houdini-axiom-based summary: number of exprs=23; number of visited CEs=1; number of preds=3
=pc L3%6%bbentry_Lfor.body%1%fcallStart inductive-invariants invariant_state done
=Invariant state at node L3%6%bbentry_Lfor.body%1%fcallEnd for reason inductive-invariants
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants invariant_state 
is_top 0
is_stable 1
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants invariant_state failcond.description

=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants invariant_state failcond.expr is null
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants invariant_state failcond done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability name abstract-memlabel-asserts
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability expr_group_type HOUDINI_EXPECTS_STABILITY with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability point_expr 1
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability pred 0
=Comment
abstract-memlabel-asserts-houdini-guess
=LhsExpr
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ce 0: z3.ce1262
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 0 type houdini_expects_stability summary: number of exprs=1; number of visited CEs=1; number of preds=1
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv name expr-group-bvs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv expr_group_type BV_EQ with 6 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 3
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 5
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv point_expr 41
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv pred 0
=Comment
expr-group-bvs.linear1-2-free_var_idx.5
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv pred 1
=Comment
expr-group-bvs.linear1-2-free_var_idx.3
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv pred 2
=Comment
expr-group-bvs.linear2-32-free_var_idx.2
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvneg(3) : BV:32
=RhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 0: z3.ce1253
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 1: z3.ce1256
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 2: z3v487.ce1259
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 3: z3.ce1262
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 4: z3v487.ce1613
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 5: z3.ce1614
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 6: z3.ce1633
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 7: z3.ce1975
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 8: z3.ce2047
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ce 9: z3v487.ce2285
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv summary: number of exprs=6; number of visited CEs=10; number of preds=3
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv output matrix
matrix:
2
-2147483648->0; 2->4294967295; 3->0; 4->1; 5->0; 6->0; 41->0; 
3
-2147483648->0; 2->0; 3->1073741824; 4->0; 5->0; 6->0; 41->0; 
5
-2147483648->0; 2->0; 3->0; 4->0; 5->1073741824; 6->0; 41->0; 
matrix done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 1 type bv state elems done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const name src-branches-const-ineq
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const pred 0
=Comment
src-branches-const-ineq.ub-unsigned
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const pred 1
=Comment
src-branches-const-ineq.lb-signed
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 0: z3.ce1262
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 1: z3.ce1975
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 2: z3v487.ce2395
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 3: z3v487.ce2446
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 4: z3v487.ce2531
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 5: z3v487.ce2611
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ce 6: z3v487.ce2696
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const summary: number of exprs=1; number of visited CEs=7; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 2 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const pred 0
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.ub-unsigned
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const pred 1
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.lb-signed
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 0: z3.ce1262
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 1: z3.ce1975
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 2: z3v487.ce2395
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 3: z3v487.ce2446
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 4: z3v487.ce2531
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 5: z3v487.ce2611
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ce 6: z3v487.ce2696
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const summary: number of exprs=1; number of visited CEs=7; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 3 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%n.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const pred 0
=Comment
dst-branches-const-ineq.input.dst.llvm-%n.Lfor.cond%1%bbentry.lb-unsigned
=LhsExpr
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.11e129 } : BV:32
3 : bvuge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ce 0: z3.ce1253
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ce 1: z3.ce1256
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ce 2: z3.ce1262
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ce 3: z3v487.ce1654
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ce 4: z3.ce1653
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const summary: number of exprs=1; number of visited CEs=5; number of preds=1
=m_lower_bound_signed_cur -2147483648
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 1
=m_upper_bound_unsigned_cur 4294967295
=m_lower_bound_signed_known -2147483648
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 1
=m_upper_bound_unsigned_known 4294967295
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 4 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini name dst-ineq
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini expr_group_type HOUDINI with 8 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 7
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 8
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 9
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 10
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 12
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 13
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini point_expr 14
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini pred 0
=Comment
dst-ineq-houdini-guess
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini pred 1
=Comment
dst-ineq-houdini-guess
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini visited ce 0: z3.ce1256
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini visited ce 1: z3.ce1262
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 5 type houdini summary: number of exprs=8; number of visited CEs=2; number of preds=2
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based name spec-coupling-invariants
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based expr_group_type HOUDINI_AXIOM_BASED with 27 exprs
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 42
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 43
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 44
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : bvadd(14, 5) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(10, 11, 12, 15, 16, 17) : BV:32
19 : lambda(9, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(8, 19) : MAP[BV:32 -> BV:32]
21 : eq(1, 20) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 45
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 46
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 47
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 48
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 49
1 : spec-%tmpvar-0.L3%7%d : SUM[UNIT,BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : input.spec-%var-i-0.L3%6%bbentry : BV:32
23 : map_get(21, 22) : SUM[UNIT,BV:32]
24 : eq(1, 23) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 50
1 : spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 51
1 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 52
1 : spec-%tmpvar-1.L3%6%bbentry : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
3 : Lambda0 : BV:32
4 : 0 { 0x0 +1.0e129 } : BV:32
5 : bvule(4, 3) : BOOL
6 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
7 : bvult(3, 6) : BOOL
8 : and(5, 7) : BOOL
9 : lambda(3, 8) : FUNCTION[BV:32 -> BOOL]
10 : Lambda1 : BV:32
11 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
12 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
13 : memlabel-top : MEMLABEL
14 : 4 { 0x4 +1.47e129 } : BV:32
15 : bvmul(10, 14) : BV:32
16 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
17 : bvadd(15, 16) : BV:32
18 : 4 { 0x4 +1.0e1025 } : INT
19 : 0 { 0x0 } : BOOL
20 : select(11, 12, 13, 17, 18, 19) : BV:32
21 : lambda(10, 20) : FUNCTION[BV:32 -> BV:32]
22 : map(9, 21) : MAP[BV:32 -> BV:32]
23 : input.spec-%var-i-0.L3%6%bbentry : BV:32
24 : map_get(22, 23) : SUM[UNIT,BV:32]
25 : 1 { 0x1 +1.0e1025 } : INT
26 : sum_get(24, 25) : BV:32
27 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
28 : Indxform0 : BV:32
29 : bvadd(10, 14) : BV:32
30 : select(11, 12, 13, 29, 18, 19) : BV:32
31 : lambda(10, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(4, 3) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 4, 33) : BV:32
35 : unit : UNIT
36 : select(11, 12, 13, 3, 18, 19) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(3, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(27, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(2, 26, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : eq(1, 41) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 53
1 : spec-%tmpvar-2.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 54
1 : spec-%var-new_l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 55
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 56
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 57
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 58
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 59
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 60
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 61
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(18, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 62
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 63
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(8, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 64
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : bvadd(17, 8) : BV:32
19 : 4 { 0x4 +1.0e1025 } : INT
20 : 0 { 0x0 } : BOOL
21 : select(13, 14, 15, 18, 19, 20) : BV:32
22 : lambda(12, 21) : FUNCTION[BV:32 -> BV:32]
23 : map(11, 22) : MAP[BV:32 -> BV:32]
24 : input.spec-%var-i-0.L3%6%bbentry : BV:32
25 : map_get(23, 24) : SUM[UNIT,BV:32]
26 : sum_get(25, 3) : BV:32
27 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 19, 20) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 19, 20) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(27, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 26, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 65
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 66
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : Indxform0 : BV:32
29 : bvadd(12, 16) : BV:32
30 : select(13, 14, 15, 29, 20, 21) : BV:32
31 : lambda(12, 30) : FUNCTION[BV:32 -> BV:32]
32 : eq(6, 5) : BOOL
33 : 1 { 0x1 +1.11e129 } : BV:32
34 : ite(32, 6, 33) : BV:32
35 : unit : UNIT
36 : select(13, 14, 15, 5, 20, 21) : BV:32
37 : prod(36, 28) : PROD[BV:32,BV:32]
38 : sum(34, 35, 37) : SUM[UNIT,PROD[BV:32,BV:32]]
39 : lambda(5, 38) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
40 : ind(8, 28, 31, 39) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
41 : prod_init(4, 27, 40) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
42 : sum_init(2, 3, 41) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
43 : eq(1, 42) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 67
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 68
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 1 { 0x1 +1.0e1025 } : INT
4 : SORT2EXPR.VAR : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
5 : Lambda0 : BV:32
6 : 0 { 0x0 +1.0e129 } : BV:32
7 : bvule(6, 5) : BOOL
8 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
9 : bvult(5, 8) : BOOL
10 : and(7, 9) : BOOL
11 : lambda(5, 10) : FUNCTION[BV:32 -> BOOL]
12 : Lambda1 : BV:32
13 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
14 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
15 : memlabel-top : MEMLABEL
16 : 4 { 0x4 +1.47e129 } : BV:32
17 : bvmul(12, 16) : BV:32
18 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
19 : bvadd(17, 18) : BV:32
20 : 4 { 0x4 +1.0e1025 } : INT
21 : 0 { 0x0 } : BOOL
22 : select(13, 14, 15, 19, 20, 21) : BV:32
23 : lambda(12, 22) : FUNCTION[BV:32 -> BV:32]
24 : map(11, 23) : MAP[BV:32 -> BV:32]
25 : input.spec-%var-i-0.L3%6%bbentry : BV:32
26 : map_get(24, 25) : SUM[UNIT,BV:32]
27 : sum_get(26, 3) : BV:32
28 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
29 : Indxform0 : BV:32
30 : bvadd(12, 16) : BV:32
31 : select(13, 14, 15, 30, 20, 21) : BV:32
32 : lambda(12, 31) : FUNCTION[BV:32 -> BV:32]
33 : eq(6, 5) : BOOL
34 : 1 { 0x1 +1.11e129 } : BV:32
35 : ite(33, 6, 34) : BV:32
36 : unit : UNIT
37 : select(13, 14, 15, 5, 20, 21) : BV:32
38 : prod(37, 29) : PROD[BV:32,BV:32]
39 : sum(35, 36, 38) : SUM[UNIT,PROD[BV:32,BV:32]]
40 : lambda(5, 39) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
41 : ind(28, 29, 32, 40) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
42 : prod_init(4, 27, 41) : IND[Type0,PROD[BV:32,SUM[UNIT,DECL[Type0]]]]
43 : sum_init(2, 3, 42) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
44 : eq(1, 43) : BOOL
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 0
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 1
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 2
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.body%1%fcallEnd : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based predicate_set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ce 0: z3.ce1262
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ces set done
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants smallest_point_cover 6 type houdini-axiom-based summary: number of exprs=27; number of visited CEs=1; number of preds=3
=pc L3%6%bbentry_Lfor.body%1%fcallEnd inductive-invariants invariant_state done
=Invariant state at node L3%6%bbentry_Lfor.cond%1%bbentry for reason inductive-invariants
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants invariant_state 
is_top 0
is_stable 1
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants invariant_state failcond.description

=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants invariant_state failcond.expr is null
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants invariant_state failcond done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability name abstract-memlabel-asserts
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability expr_group_type HOUDINI_EXPECTS_STABILITY with 1 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability point_expr 1
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability pred 0
=Comment
abstract-memlabel-asserts-houdini-guess
=LhsExpr
1 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
2 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
3 : bvule(1, 2) : BOOL
4 : 4 { 0x4 +1.47e129 } : BV:32
5 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
6 : bvadd(4, 5) : BV:32
7 : bvadd(1, 6) : BV:32
8 : eq(2, 7) : BOOL
9 : and(3, 8) : BOOL
10 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
11 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
12 : bvule(10, 11) : BOOL
13 : and(9, 12) : BOOL
14 : bvadd(10, 6) : BV:32
15 : eq(11, 14) : BOOL
16 : and(13, 15) : BOOL
17 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
18 : 3 { 0x3 +1.35e129 } : BV:32
19 : bvand(17, 18) : BV:32
20 : 0 { 0x0 +1.0e129 } : BV:32
21 : eq(19, 20) : BOOL
22 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
23 : bvand(22, 18) : BV:32
24 : eq(23, 20) : BOOL
25 : and(21, 24) : BOOL
26 : and(16, 25) : BOOL
27 : eq(17, 1) : BOOL
28 : eq(22, 10) : BOOL
29 : and(27, 28) : BOOL
30 : and(26, 29) : BOOL
31 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
32 : 1 { 0x1 +1.11e129 } : BV:32
33 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
34 : region_agrees_with_memlabel(31, 20, 32, 33) : BOOL
35 : and(30, 34) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ce 0: z3.ce5
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 0 type houdini_expects_stability summary: number of exprs=1; number of visited CEs=1; number of preds=1
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv name expr-group-bvs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv expr_group_type BV_EQ with 5 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv point_expr 3
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv point_expr 5
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv pred 0
=Comment
expr-group-bvs.linear1-2-free_var_idx.5
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv pred 1
=Comment
expr-group-bvs.linear1-2-free_var_idx.3
=LhsExpr
1 : 0 { 0x0 } : BV:2
=RhsExpr
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
2 : 1 { 0x1 +1.0e1025 } : INT
3 : 0 { 0x0 +1.0e1025 } : INT
4 : bvextract(1, 2, 3) : BV:2
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv pred 2
=Comment
expr-group-bvs.linear2-32-free_var_idx.2
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
3 : bvmul(1, 2) : BV:32
4 : bvneg(3) : BV:32
=RhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 0: z3.ce5
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 1: z3v487.ce20
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 2: z3.ce19
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 3: z3.ce41
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 4: z3.ce1857
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 5: z3.ce1918
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ce 6: z3v487.ce2314
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv summary: number of exprs=5; number of visited CEs=7; number of preds=3
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv output matrix
matrix:
2
-2147483648->0; 2->4294967295; 3->0; 4->1; 5->0; 6->0; 
3
-2147483648->0; 2->0; 3->1073741824; 4->0; 5->0; 6->0; 
5
-2147483648->0; 2->0; 3->0; 4->0; 5->1073741824; 6->0; 
matrix done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 1 type bv state elems done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const name src-branches-const-ineq
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const point_expr 2
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const pred 0
=Comment
src-branches-const-ineq.ub-unsigned
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const pred 1
=Comment
src-branches-const-ineq.lb-signed
=LhsExpr
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 0: z3.ce5
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 1: z3.ce1918
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 2: z3v487.ce2360
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 3: z3v487.ce2411
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 4: z3v487.ce2496
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 5: z3v487.ce2576
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ce 6: z3v487.ce2661
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const summary: number of exprs=1; number of visited CEs=7; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 2 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const point_expr 4
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const pred 0
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.ub-unsigned
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 4294967294 { 0xfffffffe -2 -1.99999976e128 } : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const pred 1
=Comment
dst-branches-const-ineq.input.dst.llvm-%i.0.Lfor.cond%1%bbentry.lb-signed
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : 0 { 0x0 +1.0e129 } : BV:32
3 : bvsge(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 0: z3.ce5
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 1: z3.ce1918
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 2: z3v487.ce2360
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 3: z3v487.ce2411
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 4: z3v487.ce2496
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 5: z3v487.ce2576
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ce 6: z3v487.ce2661
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const summary: number of exprs=1; number of visited CEs=7; number of preds=2
=m_lower_bound_signed_cur 0
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967294
=m_lower_bound_signed_known 0
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967294
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 3 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const name dst-branches-const-ineq.input.dst.llvm-%n.Lfor.cond%1%bbentry
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const expr_group_type BV_CONST_INEQ with 1 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const point_expr 6
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const visited ce 0: z3.ce5
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const visited ce 1: z3.ce19
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const visited ce 2: z3.ce41
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const visited ce 3: z3.ce63
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const summary: number of exprs=1; number of visited CEs=4; number of preds=0
=m_lower_bound_signed_cur -2147483648
=m_upper_bound_signed_cur 2147483647
=m_lower_bound_unsigned_cur 0
=m_upper_bound_unsigned_cur 4294967295
=m_lower_bound_signed_known -2147483648
=m_upper_bound_signed_known 2147483647
=m_lower_bound_unsigned_known 0
=m_upper_bound_unsigned_known 4294967295
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 0
1 : 0 { 0x0 +1.0e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 1
1 : 1 { 0x1 +1.11e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 2
1 : 4 { 0x4 +1.47e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 3
1 : 8 { 0x8 +1.95e129 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_expr 4
1 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 4 type ineq_const const_bound_exprs done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini name dst-ineq
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini expr_group_type HOUDINI with 8 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 7
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 8
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 9
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvslt(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 10
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 11
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 12
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 13
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvsle(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini point_expr 14
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini pred 0
=Comment
dst-ineq-houdini-guess
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvule(1, 2) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini visited ce 0: z3.ce5
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini visited ce 1: z3.ce19
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini visited ce 2: z3.ce41
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 5 type houdini summary: number of exprs=8; number of visited CEs=3; number of preds=1
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based name spec-coupling-invariants
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based expr_group_type HOUDINI_AXIOM_BASED with 13 exprs
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 15
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 16
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 17
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : bvadd(14, 5) : BV:32
16 : 4 { 0x4 +1.0e1025 } : INT
17 : 0 { 0x0 } : BOOL
18 : select(10, 11, 12, 15, 16, 17) : BV:32
19 : lambda(9, 18) : FUNCTION[BV:32 -> BV:32]
20 : map(8, 19) : MAP[BV:32 -> BV:32]
21 : eq(1, 20) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 18
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 19
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 20
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 21
1 : spec-%tmpvar-10.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 0 { 0x0 +1.0e1025 } : INT
4 : unit : UNIT
5 : sum_init(2, 3, 4) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : eq(1, 5) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 22
1 : spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 23
1 : spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : SORT2EXPR.VAR : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
3 : 0 { 0x0 +1.0e1025 } : INT
4 : unit : UNIT
5 : sum_init(2, 3, 4) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
6 : eq(1, 5) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 24
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 25
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 26
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based point_expr 27
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 0
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 1
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
2 : Lambda0 : BV:32
3 : 0 { 0x0 +1.0e129 } : BV:32
4 : bvule(3, 2) : BOOL
5 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
6 : bvult(2, 5) : BOOL
7 : and(4, 6) : BOOL
8 : lambda(2, 7) : FUNCTION[BV:32 -> BOOL]
9 : Lambda1 : BV:32
10 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
11 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
12 : memlabel-top : MEMLABEL
13 : 4 { 0x4 +1.47e129 } : BV:32
14 : bvmul(9, 13) : BV:32
15 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
16 : bvadd(14, 15) : BV:32
17 : 4 { 0x4 +1.0e1025 } : INT
18 : 0 { 0x0 } : BOOL
19 : select(10, 11, 12, 16, 17, 18) : BV:32
20 : lambda(9, 19) : FUNCTION[BV:32 -> BV:32]
21 : map(8, 20) : MAP[BV:32 -> BV:32]
22 : eq(1, 21) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based pred 2
=Comment
houdini-axiom-based-guess
=LhsExpr
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based predicate_set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based is assumed eqclass : 0
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ce 0: z3.ce5
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based visited ces set done
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants smallest_point_cover 6 type houdini-axiom-based summary: number of exprs=13; number of visited CEs=1; number of preds=3
=pc L3%6%bbentry_Lfor.cond%1%bbentry inductive-invariants invariant_state done
=Invariant state at node E0%0%d_E0%0%d for reason inductive-invariants
=pc E0%0%d_E0%0%d inductive-invariants invariant_state 
is_top 0
is_stable 1
=pc E0%0%d_E0%0%d inductive-invariants invariant_state failcond.description

=pc E0%0%d_E0%0%d inductive-invariants invariant_state failcond.expr is null
=pc E0%0%d_E0%0%d inductive-invariants invariant_state failcond done
=pc E0%0%d_E0%0%d inductive-invariants invariant_state done
=invariant_state_changed_at_pcs for reason inductive-invariants:
=graph_with_guessing done
=graph_with_correctness_covers begin
=graph_with_correctness_covers done
=m_dst_fcall_edges_already_updated_from_pcs:
=m_internal_pcs:
=m_super_edges:
=AllocaPCLocalSprelAssumptionsBegin:
=Local offsets from compile log
=Local offsets from compile log done
=done
=AllocaPCLocalSprelAssumptionsEnd
=DeallocaPCLocalSprelAssumptionsBegin:
=Local offsets from compile log
=Local offsets from compile log done
=done
=DeallocaPCLocalSprelAssumptionsEnd
=src_tfg pcs reaching pcpair L0%0%d_L0%0%d
=src_tfg pc: L0%0%d
=exit_pc_asserts at E0%0%d_E0%0%d
=exit_pc_assert.0 at E0%0%d_E0%0%d
=Comment
ret-pointer-implements-inductive-list
=LhsExpr
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=well-formedness-conditions for L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry
=well-formedness-conditions for L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry edge well-formedness condition
=well-formedness-conditions for L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry edge well-formedness condition done
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd edge well-formedness condition
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd edge well-formedness condition done
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge well-formedness condition
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond cg_path
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond cg_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond src_path
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond src_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond dst_path
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond dst_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge-wf-cond pred.0
=Comment
wfcond.from_pcL3%6%bbentry_Lfor.body%1%fcallEnd.to_pcL3%6%bbentry_Lfor.cond%1%bbentry-dst-edgecond-implies-src-edgecond
=LhsExpr
1 : 1 { 0x1 } : BOOL
2 : not(1) : BOOL
3 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
4 : input.spec-%var-i-0.L3%6%bbentry : BV:32
5 : map_get(3, 4) : SUM[UNIT,BV:32]
6 : 1 { 0x1 +1.0e1025 } : INT
7 : sum_is(5, 6) : BOOL
8 : or(2, 7) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=well-formedness-conditions for L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry edge well-formedness condition done
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart edge well-formedness condition
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart edge well-formedness condition done
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge well-formedness condition
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond cg_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond cg_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond src_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond src_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond dst_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond dst_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond pred.0
=Comment
wfcond.from_pcL3%6%bbentry_Lfor.cond%1%bbentry.to_pcE0%0%d_E0%0%d-dst-edgecond-implies-src-edgecond
=LhsExpr
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
2 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
3 : bvult(1, 2) : BOOL
4 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
5 : input.spec-%var-i-0.L3%6%bbentry : BV:32
6 : map_get(4, 5) : SUM[UNIT,BV:32]
7 : 0 { 0x0 +1.0e1025 } : INT
8 : sum_is(6, 7) : BOOL
9 : or(3, 8) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond cg_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond cg_path.graph_edge_composition
(L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond src_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond src_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond dst_path
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond dst_path.graph_edge_composition
(epsilon)
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge-wf-cond pred.0
=Comment
ret-pointer-implements-inductive-list
=LhsExpr
1 : input.spec-%tmpvar-12.E0%0%d : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
2 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
3 : Indxform0 : BV:32
4 : Lambda1 : BV:32
5 : input.dst.llvm-mem.Lfor.cond%1%bbentry : ARRAY[BV:32 -> BV:8]
6 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
7 : memlabel-top : MEMLABEL
8 : 4 { 0x4 +1.47e129 } : BV:32
9 : bvadd(4, 8) : BV:32
10 : 4 { 0x4 +1.0e1025 } : INT
11 : 0 { 0x0 } : BOOL
12 : select(5, 6, 7, 9, 10, 11) : BV:32
13 : lambda(4, 12) : FUNCTION[BV:32 -> BV:32]
14 : Lambda0 : BV:32
15 : 0 { 0x0 +1.0e129 } : BV:32
16 : eq(15, 14) : BOOL
17 : 1 { 0x1 +1.11e129 } : BV:32
18 : ite(16, 15, 17) : BV:32
19 : unit : UNIT
20 : select(5, 6, 7, 14, 10, 11) : BV:32
21 : prod(20, 3) : PROD[BV:32,BV:32]
22 : sum(18, 19, 21) : SUM[UNIT,PROD[BV:32,BV:32]]
23 : lambda(14, 22) : FUNCTION[BV:32 -> SUM[UNIT,PROD[BV:32,BV:32]]]
24 : ind(2, 3, 13, 23) : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
25 : eq(1, 24) : BOOL
=RhsExpr
1 : 1 { 0x1 } : BOOL
=predicate done
=well-formedness-conditions for L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d edge well-formedness condition done
=Ranking exprs at node L3%6%bbentry_Lfor.body%1%fcallStart
=SRC Ranking expr 0
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=SRC Tie Breaking expr 0
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 1
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 2
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=DST Ranking expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 1
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 2
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 3
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=DST Tie Breaking expr 0
1 : input.dst.llvm-%cmp.Lfor.cond%2%d : BOOL
=bv_rank_exprs done
=Ranking exprs at node L3%6%bbentry_Lfor.body%1%fcallEnd
=SRC Ranking expr 0
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=SRC Tie Breaking expr 0
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 1
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 2
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=DST Ranking expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 1
1 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
=DST Ranking expr 2
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 3
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 4
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=bv_rank_exprs done
=Ranking exprs at node L3%6%bbentry_Lfor.cond%1%bbentry
=SRC Ranking expr 0
1 : input.spec-%var-i-0.L3%6%bbentry : BV:32
=SRC Tie Breaking expr 0
1 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 1
1 : input.spec-%var-arr-0.L3%6%bbentry : MAP[BV:32 -> BV:32]
=SRC Tie Breaking expr 2
1 : input.spec-%var-l-0.L3%6%bbentry : IND[Type0,SUM[UNIT,PROD[BV:32,DECL[Type0]]]]
=DST Ranking expr 0
1 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 1
1 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 2
1 : input.dst.llvm-%l.0.Lfor.cond%1%bbentry : BV:32
=DST Ranking expr 3
1 : input.dst.llvm-%n.Lfor.cond%1%bbentry : BV:32
=bv_rank_exprs done
=Ranking exprs done
=dst-to-src submaps done
=cg-edge-contains-repeated-src-tfg-edge at edge-id L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry
0
=cg-edge-contains-repeated-src-tfg-edge at edge-id L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd
1
=cg-edge-contains-repeated-src-tfg-edge at edge-id L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry
1
=cg-edge-contains-repeated-src-tfg-edge at edge-id L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart
1
=cg-edge-contains-repeated-src-tfg-edge at edge-id L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d
0
=cg-edge-contains-repeated-src-tfg-edge-map done
=cg.assumes_around_edge
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.ec
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.pred
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
140469 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
140470 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
140594 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/ : MEMLABEL
140472 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
140441 : 4 { 0x4 +1.0e1025 } : INT
140442 : 0 { 0x0 } : BOOL
140595 : select(140469, 140470, 140594, 140472, 140441, 140442) : BV:32
=RhsExpr
140468 : input.dst.llvm-%n : BV:32
=predicate done

cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.ec
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.pred
=Comment
arg-location-contents-are-consistent-with-arg-value
=LhsExpr
140469 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
140470 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
140596 : memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/ : MEMLABEL
140471 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
140441 : 4 { 0x4 +1.0e1025 } : INT
140442 : 0 { 0x0 } : BOOL
140597 : select(140469, 140470, 140596, 140471, 140441, 140442) : BV:32
=RhsExpr
140467 : input.dst.llvm-%arr : BV:32
=predicate done

cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.ec
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.pred
=Comment
undef-behaviour-align-assume.edge.L0%0%d=>Lfor.cond%1%bbentry
=LhsExpr
140467 : input.dst.llvm-%arr : BV:32
140441 : 4 { 0x4 +1.0e1025 } : INT
140478 : islangaligned(140467, 140441) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #3
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #3.ec
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #3.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #3.pred
=Comment
pointer-implements-map
=LhsExpr
140273 : input.spec-%var-arr-1 : MAP[BV:32 -> BV:32]
140328 : Lambda0 : BV:32
140276 : 0 { 0x0 +1.0e129 } : BV:32
140386 : bvule(140276, 140328) : BOOL
140468 : input.dst.llvm-%n : BV:32
141361 : bvult(140328, 140468) : BOOL
141362 : and(140386, 141361) : BOOL
141363 : lambda(140328, 141362) : FUNCTION[BV:32 -> BOOL]
140330 : Lambda1 : BV:32
140469 : input.dst.llvm-mem : ARRAY[BV:32 -> BV:8]
140470 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
140436 : memlabel-top : MEMLABEL
140438 : 4 { 0x4 +1.47e129 } : BV:32
140439 : bvmul(140330, 140438) : BV:32
140467 : input.dst.llvm-%arr : BV:32
141383 : bvadd(140439, 140467) : BV:32
140441 : 4 { 0x4 +1.0e1025 } : INT
140442 : 0 { 0x0 } : BOOL
141384 : select(140469, 140470, 140436, 141383, 140441, 140442) : BV:32
141386 : lambda(140330, 141384) : FUNCTION[BV:32 -> BV:32]
141387 : map(141363, 141386) : MAP[BV:32 -> BV:32]
141391 : eq(140273, 141387) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #4
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #4.ec
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #4.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry assume #4.pred
=Comment
precond-mlasserts
=LhsExpr
141333 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_begin : BV:32
141334 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum1=/_end : BV:32
141335 : bvule(141333, 141334) : BOOL
140438 : 4 { 0x4 +1.47e129 } : BV:32
140516 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
141336 : bvadd(140438, 140516) : BV:32
141337 : bvadd(141333, 141336) : BV:32
141338 : eq(141334, 141337) : BOOL
141339 : and(141335, 141338) : BOOL
141340 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_begin : BV:32
141341 : input.dst.memlabel-mem--local./*___y___make_list__x__=L0%0%argnum0=/_end : BV:32
141342 : bvule(141340, 141341) : BOOL
141343 : and(141339, 141342) : BOOL
141344 : bvadd(141340, 141336) : BV:32
141345 : eq(141341, 141344) : BOOL
141346 : and(141343, 141345) : BOOL
140472 : input.dst.local./*___y___make_list__x__=L0%0%argnum1=/ : BV:32
141347 : 3 { 0x3 +1.35e129 } : BV:32
141348 : bvand(140472, 141347) : BV:32
140276 : 0 { 0x0 +1.0e129 } : BV:32
141349 : eq(141348, 140276) : BOOL
140471 : input.dst.local./*___y___make_list__x__=L0%0%argnum0=/ : BV:32
141350 : bvand(140471, 141347) : BV:32
141351 : eq(141350, 140276) : BOOL
141352 : and(141349, 141351) : BOOL
141353 : and(141346, 141352) : BOOL
141354 : eq(140472, 141333) : BOOL
141355 : eq(140471, 141340) : BOOL
141356 : and(141354, 141355) : BOOL
141357 : and(141353, 141356) : BOOL
140470 : input.dst.llvm-mem.alloc : ARRAY[BV:32 -> MEMLABEL]
140298 : 1 { 0x1 +1.11e129 } : BV:32
140473 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
141358 : region_agrees_with_memlabel(140470, 140276, 140298, 140473) : BOOL
141359 : and(141357, 141358) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L0%0%d_L0%0%d=>L3%6%bbentry_Lfor.cond%1%bbentry done
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #0
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #0.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #0.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #0.pred
=Comment
undef-behavioursome
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140909 : eq(140276, 140719) : BOOL
140720 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
140485 : 8 { 0x8 +1.95e129 } : BV:32
140473 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
141263 : region_agrees_with_memlabel(140720, 140719, 140485, 140473) : BOOL
141269 : or(140909, 141263) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #1
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #1.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #1.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #1.pred
=Comment
undef-behavioursome
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140909 : eq(140276, 140719) : BOOL
140442 : 0 { 0x0 } : BOOL
140498 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
140727 : heap_alloc_ptr(140719, 140498) : BV:32
140658 : 7 { 0x7 +1.83e129 } : BV:32
140950 : bvadd(140658, 140727) : BV:32
140953 : bvule(140727, 140950) : BOOL
140956 : or(140442, 140953) : BOOL
140960 : or(140909, 140956) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #2
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #2.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #2.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd assume #2.pred
=Comment
undef-behaviour-align-assume
=LhsExpr
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140287 : 1 { 0x1 +1.0e1025 } : INT
140756 : islangaligned(140719, 140287) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallStart=>L3%6%bbentry_Lfor.body%1%fcallEnd done
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #0.pred
=Comment
undef-behaviour-align-assume.edge.Lfor.body%1%fcallEnd=>Lfor.body%1%intermediateVal1
=LhsExpr
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140287 : 1 { 0x1 +1.0e1025 } : INT
140756 : islangaligned(140719, 140287) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #1.pred
=Comment
merged-predicate
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140909 : eq(140276, 140719) : BOOL
140720 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
140485 : 8 { 0x8 +1.95e129 } : BV:32
140473 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
141263 : region_agrees_with_memlabel(140720, 140719, 140485, 140473) : BOOL
141269 : or(140909, 141263) : BOOL
140442 : 0 { 0x0 } : BOOL
140498 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
140727 : heap_alloc_ptr(140719, 140498) : BV:32
140658 : 7 { 0x7 +1.83e129 } : BV:32
140950 : bvadd(140658, 140727) : BV:32
140953 : bvule(140727, 140950) : BOOL
140956 : or(140442, 140953) : BOOL
140960 : or(140909, 140956) : BOOL
191617 : and(141269, 140960) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry assume #2.pred
=Comment
merged-predicate
=LhsExpr
140275 : 1 { 0x1 } : BOOL
140276 : 0 { 0x0 +1.0e129 } : BV:32
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140909 : eq(140276, 140719) : BOOL
140498 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
140727 : heap_alloc_ptr(140719, 140498) : BV:32
140917 : ite(140909, 140276, 140727) : BV:32
247904 : isgepoffset(140917, 140276) : BOOL
247911 : and(140275, 247904) : BOOL
140663 : 4 { 0x4 +1.0e1025 } : BV:64
140731 : input.dst.llvm-%i.0.Lfor.cond%1%bbentry : BV:32
140720 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
140485 : 8 { 0x8 +1.95e129 } : BV:32
140724 : heap_alloc(140720, 140498, 140719, 140485) : ARRAY[BV:32 -> MEMLABEL]
140911 : ite(140909, 140720, 140724) : ARRAY[BV:32 -> MEMLABEL]
140919 : malloc_side_effect(140731, 140911, 140498) : BV:32
140530 : 32 { 0x20 +1.0e1025 } : INT
247922 : bvsign_ext(140919, 140530) : BV:64
249831 : bvmul(140663, 247922) : BV:64
140534 : 63 { 0x3f +1.0e1025 } : INT
249832 : bvextract(249831, 140534, 140530) : BV:32
249833 : bvslt(140919, 140276) : BOOL
140516 : 4294967295 { 0xffffffff -1 -1.99999988e128 } : BV:32
249834 : ite(249833, 140516, 140276) : BV:32
250407 : eq(249832, 249834) : BOOL
140441 : 4 { 0x4 +1.0e1025 } : INT
251147 : isindexforsize(250407, 140441) : BOOL
140718 : input.dst.llvm-%arr.Lfor.cond%1%bbentry : BV:32
140914 : malloc_side_effect(140718, 140911, 140498) : BV:32
140438 : 4 { 0x4 +1.47e129 } : BV:32
246121 : bvmul(140438, 140919) : BV:32
246128 : bvadd(140914, 246121) : BV:32
251148 : isgepoffset(246128, 246121) : BOOL
251363 : and(251147, 251148) : BOOL
251364 : islangaligned(246128, 140441) : BOOL
251365 : and(251363, 251364, 247904, 247911) : BOOL
251366 : islangaligned(140917, 140441) : BOOL
246139 : bvadd(140438, 140917) : BV:32
251367 : isgepoffset(246139, 140438) : BOOL
251368 : and(247911, 251365, 251366, 251367) : BOOL
251369 : islangaligned(246139, 140441) : BOOL
251370 : and(251368, 251369) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.body%1%fcallEnd=>L3%6%bbentry_Lfor.cond%1%bbentry done
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #0
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #0.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #0.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #0.pred
=Comment
undef-behavioursome
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140909 : eq(140276, 140719) : BOOL
140720 : input.dst.llvm-mem.alloc.Lfor.cond%1%bbentry : ARRAY[BV:32 -> MEMLABEL]
140485 : 8 { 0x8 +1.95e129 } : BV:32
140473 : memlabel-mem-may-straddle-symbol.1-heap : MEMLABEL
141263 : region_agrees_with_memlabel(140720, 140719, 140485, 140473) : BOOL
141269 : or(140909, 141263) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #1
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #1.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #1.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #1.pred
=Comment
undef-behavioursome
=LhsExpr
140276 : 0 { 0x0 +1.0e129 } : BV:32
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140909 : eq(140276, 140719) : BOOL
140442 : 0 { 0x0 } : BOOL
140498 : memlabel-mem--hpalloc.R1./*___y___make_list__x__=Lfor.body%1%intermediateVal0=/ : MEMLABEL
140727 : heap_alloc_ptr(140719, 140498) : BV:32
140658 : 7 { 0x7 +1.83e129 } : BV:32
140950 : bvadd(140658, 140727) : BV:32
140953 : bvule(140727, 140950) : BOOL
140956 : or(140442, 140953) : BOOL
140960 : or(140909, 140956) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #2
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #2.ec
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #2.ec.graph_edge_composition
(epsilon)
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart assume #2.pred
=Comment
undef-behaviour-align-assume
=LhsExpr
140719 : input.dst.llvm-%call.Lfor.body%1%fcallEnd : BV:32
140287 : 1 { 0x1 +1.0e1025 } : INT
140756 : islangaligned(140719, 140287) : BOOL
=RhsExpr
140275 : 1 { 0x1 } : BOOL
=predicate done

cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>L3%6%bbentry_Lfor.body%1%fcallStart done
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d
cg.assumes_around_edge at L3%6%bbentry_Lfor.cond%1%bbentry=>E0%0%d_E0%0%d done
cg.assumes_around_edge done
=corr_graph_done
=bv_rank_map
=bv_rank at L0%0%d_L0%0%d
m_dst_rank: 0, m_src_rank: 0, m_spec_rank: 0
=bv_rank at L3%6%bbentry_Lfor.body%1%fcallStart
m_dst_rank: 3, m_src_rank: 0, m_spec_rank: 20
=bv_rank at L3%6%bbentry_Lfor.body%1%fcallEnd
m_dst_rank: 4, m_src_rank: 0, m_spec_rank: 24
=bv_rank at L3%6%bbentry_Lfor.cond%1%bbentry
m_dst_rank: 3, m_src_rank: 0, m_spec_rank: 11
=bv_rank at E0%0%d_E0%0%d
m_dst_rank: 0, m_src_rank: 0, m_spec_rank: 0
=cg_with_rank done
=cg_with_backtracker done
=asm filename

=cg_with_asm_annotation done
